
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module awt {
        export module font {
            export class NumericShaper extends java.lang.Object implements java.io.Serializable {
                public static ALL_RANGES: number;
                public static ARABIC: number;
                public static BENGALI: number;
                public static DEVANAGARI: number;
                public static EASTERN_ARABIC: number;
                public static ETHIOPIC: number;
                public static EUROPEAN: number;
                public static GUJARATI: number;
                public static GURMUKHI: number;
                public static KANNADA: number;
                public static KHMER: number;
                public static LAO: number;
                public static MALAYALAM: number;
                public static MONGOLIAN: number;
                public static MYANMAR: number;
                public static ORIYA: number;
                public static TAMIL: number;
                public static TELUGU: number;
                public static THAI: number;
                public static TIBETAN: number;

                public shape(param0: native.Array<string>, param1: number, param2: number, param3: number): void;

                public static getContextualShaper(param0: number): java.awt.font.NumericShaper;

                public equals(param0: java.lang.Object): boolean;

                public shape(param0: native.Array<string>, param1: number, param2: number): void;

                public static getContextualShaper(param0: number, param1: number): java.awt.font.NumericShaper;

                public static getShaper(param0: number): java.awt.font.NumericShaper;

                public hashCode(): number;

                public getRanges(): number;

                public toString(): string;

                public isContextual(): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Boolean.d.ts" />
/// <reference path="./java.lang.Float.d.ts" />
/// <reference path="./java.lang.Integer.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module awt {
        export module font {
            export class TextAttribute extends java.text.AttributedCharacterIterator.Attribute {
                public static BACKGROUND: java.awt.font.TextAttribute;
                public static BIDI_EMBEDDING: java.awt.font.TextAttribute;
                public static CHAR_REPLACEMENT: java.awt.font.TextAttribute;
                public static FAMILY: java.awt.font.TextAttribute;
                public static FONT: java.awt.font.TextAttribute;
                public static FOREGROUND: java.awt.font.TextAttribute;
                public static INPUT_METHOD_HIGHLIGHT: java.awt.font.TextAttribute;
                public static INPUT_METHOD_UNDERLINE: java.awt.font.TextAttribute;
                public static JUSTIFICATION: java.awt.font.TextAttribute;
                public static JUSTIFICATION_FULL: java.lang.Float;
                public static JUSTIFICATION_NONE: java.lang.Float;
                public static KERNING: java.awt.font.TextAttribute;
                public static KERNING_ON: java.lang.Integer;
                public static LIGATURES: java.awt.font.TextAttribute;
                public static LIGATURES_ON: java.lang.Integer;
                public static NUMERIC_SHAPING: java.awt.font.TextAttribute;
                public static POSTURE: java.awt.font.TextAttribute;
                public static POSTURE_OBLIQUE: java.lang.Float;
                public static POSTURE_REGULAR: java.lang.Float;
                public static RUN_DIRECTION: java.awt.font.TextAttribute;
                public static RUN_DIRECTION_LTR: java.lang.Boolean;
                public static RUN_DIRECTION_RTL: java.lang.Boolean;
                public static SIZE: java.awt.font.TextAttribute;
                public static STRIKETHROUGH: java.awt.font.TextAttribute;
                public static STRIKETHROUGH_ON: java.lang.Boolean;
                public static SUPERSCRIPT: java.awt.font.TextAttribute;
                public static SUPERSCRIPT_SUB: java.lang.Integer;
                public static SUPERSCRIPT_SUPER: java.lang.Integer;
                public static SWAP_COLORS: java.awt.font.TextAttribute;
                public static SWAP_COLORS_ON: java.lang.Boolean;
                public static TRACKING: java.awt.font.TextAttribute;
                public static TRACKING_LOOSE: java.lang.Float;
                public static TRACKING_TIGHT: java.lang.Float;
                public static TRANSFORM: java.awt.font.TextAttribute;
                public static UNDERLINE: java.awt.font.TextAttribute;
                public static UNDERLINE_LOW_DASHED: java.lang.Integer;
                public static UNDERLINE_LOW_DOTTED: java.lang.Integer;
                public static UNDERLINE_LOW_GRAY: java.lang.Integer;
                public static UNDERLINE_LOW_ONE_PIXEL: java.lang.Integer;
                public static UNDERLINE_LOW_TWO_PIXEL: java.lang.Integer;
                public static UNDERLINE_ON: java.lang.Integer;
                public static WEIGHT: java.awt.font.TextAttribute;
                public static WEIGHT_BOLD: java.lang.Float;
                public static WEIGHT_DEMIBOLD: java.lang.Float;
                public static WEIGHT_DEMILIGHT: java.lang.Float;
                public static WEIGHT_EXTRABOLD: java.lang.Float;
                public static WEIGHT_EXTRA_LIGHT: java.lang.Float;
                public static WEIGHT_HEAVY: java.lang.Float;
                public static WEIGHT_LIGHT: java.lang.Float;
                public static WEIGHT_MEDIUM: java.lang.Float;
                public static WEIGHT_REGULAR: java.lang.Float;
                public static WEIGHT_SEMIBOLD: java.lang.Float;
                public static WEIGHT_ULTRABOLD: java.lang.Float;
                public static WIDTH: java.awt.font.TextAttribute;
                public static WIDTH_CONDENSED: java.lang.Float;
                public static WIDTH_EXTENDED: java.lang.Float;
                public static WIDTH_REGULAR: java.lang.Float;
                public static WIDTH_SEMI_CONDENSED: java.lang.Float;
                public static WIDTH_SEMI_EXTENDED: java.lang.Float;

                public constructor(param0: string);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module beans {
        export class IndexedPropertyChangeEvent extends java.beans.PropertyChangeEvent {
            public constructor(param0: java.lang.Object, param1: string, param2: java.lang.Object, param3: java.lang.Object);

            public getIndex(): number;

            public constructor(param0: java.lang.Object);
            public constructor(param0: java.lang.Object, param1: string, param2: java.lang.Object, param3: java.lang.Object, param4: number);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module beans {
        export class PropertyChangeEvent extends java.util.EventObject {
            public getOldValue(): java.lang.Object;

            public constructor(param0: java.lang.Object, param1: string, param2: java.lang.Object, param3: java.lang.Object);

            public getNewValue(): java.lang.Object;

            public constructor(param0: java.lang.Object);

            public getPropertyName(): string;

            public getPropagationId(): java.lang.Object;

            public setPropagationId(param0: java.lang.Object): void;
        }
    }
}

/// <reference path="./java.beans.PropertyChangeEvent.d.ts" />
declare module java {
    export module beans {
        export class PropertyChangeListener extends java.lang.Object implements java.util.EventListener {
            /**
             * Constructs a new instance of the java.beans.PropertyChangeListener interface with the provided implementation.
             */
            public constructor(implementation: {
                propertyChange(param0: java.beans.PropertyChangeEvent): void;
            });

            public propertyChange(param0: java.beans.PropertyChangeEvent): void;
        }
    }
}

/// <reference path="./java.beans.PropertyChangeEvent.d.ts" />
/// <reference path="./java.beans.PropertyChangeListener.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.EventListener.d.ts" />
declare module java {
    export module beans {
        export class PropertyChangeListenerProxy extends java.util.EventListenerProxy implements java.beans.PropertyChangeListener {
            public constructor(param0: string, param1: java.beans.PropertyChangeListener);

            public propertyChange(param0: java.beans.PropertyChangeEvent): void;

            public getPropertyName(): string;

            public constructor(param0: java.util.EventListener);
        }
    }
}

/// <reference path="./java.beans.PropertyChangeEvent.d.ts" />
/// <reference path="./java.beans.PropertyChangeListener.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module beans {
        export class PropertyChangeSupport extends java.lang.Object implements java.io.Serializable {
            public getPropertyChangeListeners(param0: string): native.Array<java.beans.PropertyChangeListener>;

            public fireIndexedPropertyChange(param0: string, param1: number, param2: number, param3: number): void;
            public fireIndexedPropertyChange(param0: string, param1: number, param2: boolean, param3: boolean): void;

            public firePropertyChange(param0: string, param1: java.lang.Object, param2: java.lang.Object): void;

            public addPropertyChangeListener(param0: java.beans.PropertyChangeListener): void;

            public firePropertyChange(param0: string, param1: boolean, param2: boolean): void;

            public hasListeners(param0: string): boolean;

            public fireIndexedPropertyChange(param0: string, param1: number, param2: java.lang.Object, param3: java.lang.Object): void;

            public firePropertyChange(param0: java.beans.PropertyChangeEvent): void;

            public getPropertyChangeListeners(): native.Array<java.beans.PropertyChangeListener>;

            public addPropertyChangeListener(param0: string, param1: java.beans.PropertyChangeListener): void;

            public removePropertyChangeListener(param0: java.beans.PropertyChangeListener): void;

            public constructor(param0: java.lang.Object);

            public firePropertyChange(param0: string, param1: number, param2: number): void;

            public removePropertyChangeListener(param0: string, param1: java.beans.PropertyChangeListener): void;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
declare module java {
    export module io {
        export class BufferedInputStream extends java.io.FilterInputStream {
            public buf: native.Array<number>;
            public count: number;
            public marklimit: number;
            public markpos: number;
            public pos: number;

            public markSupported(): boolean;

            public constructor(param0: java.io.InputStream, param1: number);

            public read(param0: native.Array<number>): number;

            public skip(param0: number): number;

            public reset(): void;

            public constructor(param0: java.io.InputStream);

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public close(): void;

            public available(): number;

            public mark(param0: number): void;

            public read(): number;
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
declare module java {
    export module io {
        export class BufferedOutputStream extends java.io.FilterOutputStream {
            public buf: native.Array<number>;
            public count: number;

            public flush(): void;

            public constructor(param0: java.io.OutputStream, param1: number);

            public write(param0: number): void;

            public constructor(param0: java.io.OutputStream);

            public write(param0: native.Array<number>, param1: number, param2: number): void;

            public constructor();

            public write(param0: native.Array<number>): void;

            public close(): void;
        }
    }
}

/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
declare module java {
    export module io {
        export class BufferedReader extends java.io.Reader {
            public ready(): boolean;

            public markSupported(): boolean;

            public readLine(): string;

            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public constructor();

            public read(): number;

            public constructor(param0: java.io.Reader);

            public read(param0: native.Array<string>): number;

            public constructor(param0: java.io.Reader, param1: number);

            public read(param0: java.nio.CharBuffer): number;

            public skip(param0: number): number;

            public constructor(param0: java.lang.Object);

            public reset(): void;

            public close(): void;

            public mark(param0: number): void;
        }
    }
}

/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class BufferedWriter extends java.io.Writer {
            public constructor(param0: java.io.Writer);

            public flush(): void;

            public write(param0: string, param1: number, param2: number): void;
            public write(param0: native.Array<string>, param1: number, param2: number): void;
            public write(param0: native.Array<string>): void;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public write(param0: string): void;
            public write(param0: number): void;

            public append(param0: string): java.io.Writer;

            public constructor(param0: java.lang.Object);

            public newLine(): void;

            public append(param0: string, param1: number, param2: number): java.io.Writer;

            public close(): void;

            public constructor(param0: java.io.Writer, param1: number);

            public append(param0: string): java.lang.Appendable;
        }
    }
}

declare module java {
    export module io {
        export class ByteArrayInputStream extends java.io.InputStream {
            public buf: native.Array<number>;
            public count: number;
            public pos: number;

            public markSupported(): boolean;

            public read(param0: native.Array<number>): number;

            public skip(param0: number): number;

            public reset(): void;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();
            public constructor(param0: native.Array<number>);

            public close(): void;

            public constructor(param0: native.Array<number>, param1: number, param2: number);

            public available(): number;

            public mark(param0: number): void;

            public read(): number;
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class ByteArrayOutputStream extends java.io.OutputStream {
            public buf: native.Array<number>;
            public count: number;

            public flush(): void;

            public size(): number;

            public toByteArray(): native.Array<number>;

            public constructor(param0: number);
            public constructor();

            public toString(): string;

            public writeTo(param0: java.io.OutputStream): void;

            public write(param0: number): void;

            public toString(param0: number): string;

            public reset(): void;

            public write(param0: native.Array<number>, param1: number, param2: number): void;
            public write(param0: native.Array<number>): void;

            public close(): void;

            public toString(param0: string): string;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
declare module java {
    export module io {
        export class CharArrayReader extends java.io.Reader {
            public buf: native.Array<string>;
            public count: number;
            public markedPos: number;
            public pos: number;

            public ready(): boolean;

            public constructor(param0: native.Array<string>, param1: number, param2: number);

            public markSupported(): boolean;

            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public constructor();

            public read(): number;
            public read(param0: native.Array<string>): number;

            public constructor(param0: native.Array<string>);

            public read(param0: java.nio.CharBuffer): number;

            public skip(param0: number): number;

            public constructor(param0: java.lang.Object);

            public reset(): void;

            public close(): void;

            public mark(param0: number): void;
        }
    }
}

/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class CharArrayWriter extends java.io.Writer {
            public buf: native.Array<string>;
            public count: number;

            public flush(): void;

            public size(): number;

            public append(param0: string, param1: number, param2: number): java.io.CharArrayWriter;

            public write(param0: string, param1: number, param2: number): void;

            public constructor(param0: number);

            public write(param0: native.Array<string>, param1: number, param2: number): void;

            public toCharArray(): native.Array<string>;

            public write(param0: native.Array<string>): void;

            public writeTo(param0: java.io.Writer): void;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public write(param0: string): void;

            public toString(): string;

            public append(param0: string): java.io.CharArrayWriter;

            public write(param0: number): void;

            public append(param0: string): java.io.Writer;

            public constructor(param0: java.lang.Object);

            public reset(): void;

            public append(param0: string, param1: number, param2: number): java.io.Writer;

            public close(): void;

            public append(param0: string): java.lang.Appendable;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class CharConversionException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

declare module java {
    export module io {
        export class Closeable extends java.lang.Object implements java.lang.AutoCloseable {
            /**
             * Constructs a new instance of the java.io.Closeable interface with the provided implementation.
             */
            public constructor(implementation: {
                close(): void;
                close(): void;
            });

            public close(): void;
        }
    }
}

/// <reference path="./java.io.PrintWriter.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class Console extends java.lang.Object implements java.io.Flushable {
            public flush(): void;

            public readLine(): string;

            public printf(param0: string, param1: native.Array<java.lang.Object>): java.io.Console;

            public reader(): java.io.Reader;

            public writer(): java.io.PrintWriter;

            public format(param0: string, param1: native.Array<java.lang.Object>): java.io.Console;

            public readLine(param0: string, param1: native.Array<java.lang.Object>): string;

            public readPassword(): native.Array<string>;
            public readPassword(param0: string, param1: native.Array<java.lang.Object>): native.Array<string>;
        }
    }
}

declare module java {
    export module io {
        export class DataInput extends java.lang.Object {
            /**
             * Constructs a new instance of the java.io.DataInput interface with the provided implementation.
             */
            public constructor(implementation: {
                readBoolean(): boolean;
                readByte(): number;
                readChar(): string;
                readDouble(): number;
                readFloat(): number;
                readFully(param0: native.Array<number>): void;
                readFully(param0: native.Array<number>, param1: number, param2: number): void;
                readInt(): number;
                readLine(): string;
                readLong(): number;
                readShort(): number;
                readUnsignedByte(): number;
                readUnsignedShort(): number;
                readUTF(): string;
                skipBytes(param0: number): number;
            });

            public readLine(): string;

            public readUnsignedShort(): number;

            public readLong(): number;

            public readFully(param0: native.Array<number>, param1: number, param2: number): void;

            public readByte(): number;

            public readUnsignedByte(): number;

            public readBoolean(): boolean;

            public readShort(): number;

            public readDouble(): number;

            public readChar(): string;

            public skipBytes(param0: number): number;

            public readUTF(): string;

            public readFloat(): number;

            public readInt(): number;

            public readFully(param0: native.Array<number>): void;
        }
    }
}

/// <reference path="./java.io.DataInput.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
declare module java {
    export module io {
        export class DataInputStream extends java.io.FilterInputStream implements java.io.DataInput {
            public readLine(): string;

            public readUnsignedShort(): number;

            public readLong(): number;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public readFully(param0: native.Array<number>, param1: number, param2: number): void;

            public readByte(): number;

            public readUnsignedByte(): number;

            public read(): number;

            public readBoolean(): boolean;

            public readShort(): number;

            public read(param0: native.Array<number>): number;

            public static readUTF(param0: java.io.DataInput): string;

            public readDouble(): number;

            public constructor(param0: java.io.InputStream);

            public readChar(): string;

            public skipBytes(param0: number): number;

            public readUTF(): string;

            public close(): void;

            public readFloat(): number;

            public readInt(): number;

            public readFully(param0: native.Array<number>): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class DataOutput extends java.lang.Object {
            /**
             * Constructs a new instance of the java.io.DataOutput interface with the provided implementation.
             */
            public constructor(implementation: {
                write(param0: native.Array<number>): void;
                write(param0: native.Array<number>, param1: number, param2: number): void;
                write(param0: number): void;
                writeBoolean(param0: boolean): void;
                writeByte(param0: number): void;
                writeBytes(param0: string): void;
                writeChar(param0: number): void;
                writeChars(param0: string): void;
                writeDouble(param0: number): void;
                writeFloat(param0: number): void;
                writeInt(param0: number): void;
                writeLong(param0: number): void;
                writeShort(param0: number): void;
                writeUTF(param0: string): void;
            });

            public writeInt(param0: number): void;

            public writeLong(param0: number): void;

            public writeUTF(param0: string): void;

            public writeByte(param0: number): void;

            public writeDouble(param0: number): void;

            public writeBoolean(param0: boolean): void;

            public writeBytes(param0: string): void;

            public writeFloat(param0: number): void;

            public writeShort(param0: number): void;

            public write(param0: number): void;

            public writeChar(param0: number): void;

            public write(param0: native.Array<number>, param1: number, param2: number): void;
            public write(param0: native.Array<number>): void;

            public writeChars(param0: string): void;
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class DataOutputStream extends java.io.FilterOutputStream implements java.io.DataOutput {
            public written: number;

            public flush(): void;

            public size(): number;

            public writeInt(param0: number): void;

            public writeLong(param0: number): void;

            public writeUTF(param0: string): void;

            public writeByte(param0: number): void;

            public writeDouble(param0: number): void;

            public constructor();

            public writeBoolean(param0: boolean): void;

            public writeBytes(param0: string): void;

            public writeFloat(param0: number): void;

            public writeShort(param0: number): void;

            public write(param0: number): void;

            public writeChar(param0: number): void;

            public constructor(param0: java.io.OutputStream);

            public write(param0: native.Array<number>, param1: number, param2: number): void;
            public write(param0: native.Array<number>): void;

            public close(): void;

            public writeChars(param0: string): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class EOFException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.ObjectInput.d.ts" />
/// <reference path="./java.io.ObjectOutput.d.ts" />
declare module java {
    export module io {
        export class Externalizable extends java.lang.Object implements java.io.Serializable {
            /**
             * Constructs a new instance of the java.io.Externalizable interface with the provided implementation.
             */
            public constructor(implementation: {
                readExternal(param0: java.io.ObjectInput): void;
                writeExternal(param0: java.io.ObjectOutput): void;
            });

            public readExternal(param0: java.io.ObjectInput): void;

            public writeExternal(param0: java.io.ObjectOutput): void;
        }
    }
}

/// <reference path="./java.io.FileFilter.d.ts" />
/// <reference path="./java.io.FilenameFilter.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.URI.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
declare module java {
    export module io {
        export class File extends java.lang.Object implements java.io.Serializable {
            public static pathSeparator: string;
            public static pathSeparatorChar: string;
            public static separator: string;
            public static separatorChar: string;

            public canWrite(): boolean;

            public getParentFile(): java.io.File;

            public getTotalSpace(): number;

            public equals(param0: java.lang.Object): boolean;

            public getFreeSpace(): number;

            public getAbsoluteFile(): java.io.File;

            public getParent(): string;

            public isDirectory(): boolean;

            public constructor(param0: java.io.File, param1: string);

            public canExecute(): boolean;

            public static createTempFile(param0: string, param1: string, param2: java.io.File): java.io.File;

            public constructor(param0: java.net.URI);

            public setLastModified(param0: number): boolean;

            public setExecutable(param0: boolean, param1: boolean): boolean;

            public constructor(param0: string);

            public getUsableSpace(): number;

            public mkdir(): boolean;

            public toURI(): java.net.URI;

            public compareTo(param0: java.io.File): number;

            public isHidden(): boolean;

            public lastModified(): number;

            public isFile(): boolean;

            public list(param0: java.io.FilenameFilter): native.Array<string>;

            public listFiles(param0: java.io.FilenameFilter): native.Array<java.io.File>;

            public renameTo(param0: java.io.File): boolean;

            public getCanonicalPath(): string;

            public canRead(): boolean;

            public list(): native.Array<string>;

            public getCanonicalFile(): java.io.File;

            public constructor(param0: string, param1: string);

            public createNewFile(): boolean;

            public listFiles(param0: java.io.FileFilter): native.Array<java.io.File>;

            public delete(): boolean;

            public listFiles(): native.Array<java.io.File>;

            public static listRoots(): native.Array<java.io.File>;

            public setReadable(param0: boolean): boolean;
            public setReadable(param0: boolean, param1: boolean): boolean;

            public length(): number;

            public setReadOnly(): boolean;

            public toURL(): java.net.URL;

            public exists(): boolean;

            public getPath(): string;

            public toString(): string;

            public getName(): string;

            public deleteOnExit(): void;

            public isAbsolute(): boolean;

            public getAbsolutePath(): string;

            public static createTempFile(param0: string, param1: string): java.io.File;

            public setWritable(param0: boolean, param1: boolean): boolean;
            public setWritable(param0: boolean): boolean;

            public mkdirs(): boolean;

            public setExecutable(param0: boolean): boolean;

            public hashCode(): number;
        }
    }
}

declare module java {
    export module io {
        export class FileDescriptor extends java.lang.Object {
            public static err: java.io.FileDescriptor;
            public static in: java.io.FileDescriptor;
            public static out: java.io.FileDescriptor;

            public toString(): string;

            public sync(): void;

            public valid(): boolean;

            public constructor();
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
declare module java {
    export module io {
        export class FileFilter extends java.lang.Object {
            /**
             * Constructs a new instance of the java.io.FileFilter interface with the provided implementation.
             */
            public constructor(implementation: {
                accept(param0: java.io.File): boolean;
            });

            public accept(param0: java.io.File): boolean;
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.FileDescriptor.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.channels.FileChannel.d.ts" />
declare module java {
    export module io {
        export class FileInputStream extends java.io.InputStream {
            public getFD(): java.io.FileDescriptor;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public available(): number;

            public read(): number;

            public getChannel(): java.nio.channels.FileChannel;

            public read(param0: native.Array<number>): number;

            public constructor(param0: java.io.FileDescriptor);

            public skip(param0: number): number;

            public constructor(param0: java.io.File);

            public close(): void;

            public constructor(param0: string);

            public finalize(): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class FileNotFoundException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.FileDescriptor.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.channels.FileChannel.d.ts" />
declare module java {
    export module io {
        export class FileOutputStream extends java.io.OutputStream {
            public flush(): void;

            public getFD(): java.io.FileDescriptor;

            public constructor();
            public constructor(param0: java.io.File, param1: boolean);

            public getChannel(): java.nio.channels.FileChannel;

            public write(param0: number): void;

            public constructor(param0: java.io.FileDescriptor);
            public constructor(param0: java.io.File);
            public constructor(param0: string, param1: boolean);

            public write(param0: native.Array<number>, param1: number, param2: number): void;
            public write(param0: native.Array<number>): void;

            public close(): void;

            public constructor(param0: string);

            public finalize(): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module io {
        export class FilePermission extends java.security.Permission implements java.io.Serializable {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.FileDescriptor.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
/// <reference path="./java.nio.charset.Charset.d.ts" />
/// <reference path="./java.nio.charset.CharsetDecoder.d.ts" />
declare module java {
    export module io {
        export class FileReader extends java.io.InputStreamReader {
            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public constructor();

            public read(): number;

            public constructor(param0: java.io.InputStream, param1: java.nio.charset.CharsetDecoder);

            public read(param0: native.Array<string>): number;

            public constructor(param0: java.io.InputStream, param1: string);

            public read(param0: java.nio.CharBuffer): number;

            public constructor(param0: java.io.FileDescriptor);
            public constructor(param0: java.lang.Object);
            public constructor(param0: java.io.File);
            public constructor(param0: java.io.InputStream);
            public constructor(param0: java.io.InputStream, param1: java.nio.charset.Charset);

            public close(): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.FileDescriptor.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.charset.Charset.d.ts" />
/// <reference path="./java.nio.charset.CharsetEncoder.d.ts" />
declare module java {
    export module io {
        export class FileWriter extends java.io.OutputStreamWriter {
            public flush(): void;

            public constructor(param0: java.io.OutputStream, param1: java.nio.charset.CharsetEncoder);
            public constructor(param0: java.io.OutputStream, param1: string);
            public constructor(param0: java.io.OutputStream, param1: java.nio.charset.Charset);

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();
            public constructor(param0: java.io.File, param1: boolean);

            public append(param0: string): java.io.Writer;

            public constructor(param0: java.io.FileDescriptor);
            public constructor(param0: java.lang.Object);
            public constructor(param0: java.io.File);
            public constructor(param0: string, param1: boolean);
            public constructor(param0: java.io.OutputStream);

            public append(param0: string, param1: number, param2: number): java.io.Writer;

            public close(): void;

            public constructor(param0: string);

            public append(param0: string): java.lang.Appendable;
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class FilenameFilter extends java.lang.Object {
            /**
             * Constructs a new instance of the java.io.FilenameFilter interface with the provided implementation.
             */
            public constructor(implementation: {
                accept(param0: java.io.File, param1: string): boolean;
            });

            public accept(param0: java.io.File, param1: string): boolean;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
declare module java {
    export module io {
        export class FilterInputStream extends java.io.InputStream {
            public in: java.io.InputStream;

            public markSupported(): boolean;

            public read(param0: native.Array<number>): number;

            public skip(param0: number): number;

            public reset(): void;

            public constructor(param0: java.io.InputStream);

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public close(): void;

            public available(): number;

            public mark(param0: number): void;

            public read(): number;
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
declare module java {
    export module io {
        export class FilterOutputStream extends java.io.OutputStream {
            public out: java.io.OutputStream;

            public flush(): void;

            public write(param0: number): void;

            public constructor(param0: java.io.OutputStream);

            public write(param0: native.Array<number>, param1: number, param2: number): void;

            public constructor();

            public write(param0: native.Array<number>): void;

            public close(): void;
        }
    }
}

/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
declare module java {
    export module io {
        export abstract class FilterReader extends java.io.Reader {
            public in: java.io.Reader;

            public ready(): boolean;

            public markSupported(): boolean;

            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public constructor();

            public read(): number;

            public constructor(param0: java.io.Reader);

            public read(param0: native.Array<string>): number;
            public read(param0: java.nio.CharBuffer): number;

            public skip(param0: number): number;

            public constructor(param0: java.lang.Object);

            public reset(): void;

            public close(): void;

            public mark(param0: number): void;
        }
    }
}

/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export abstract class FilterWriter extends java.io.Writer {
            public out: java.io.Writer;

            public constructor(param0: java.io.Writer);

            public flush(): void;

            public write(param0: string, param1: number, param2: number): void;
            public write(param0: native.Array<string>, param1: number, param2: number): void;
            public write(param0: native.Array<string>): void;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public write(param0: string): void;
            public write(param0: number): void;

            public append(param0: string): java.io.Writer;

            public constructor(param0: java.lang.Object);

            public append(param0: string, param1: number, param2: number): java.io.Writer;

            public close(): void;

            public append(param0: string): java.lang.Appendable;
        }
    }
}

declare module java {
    export module io {
        export class Flushable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.io.Flushable interface with the provided implementation.
             */
            public constructor(implementation: {
                flush(): void;
            });

            public flush(): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class IOError extends java.lang.Error {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class IOException extends java.lang.Exception {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

declare module java {
    export module io {
        export abstract class InputStream extends java.lang.Object implements java.io.Closeable {
            public markSupported(): boolean;

            public read(param0: native.Array<number>): number;

            public skip(param0: number): number;

            public reset(): void;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public close(): void;

            public available(): number;

            public mark(param0: number): void;

            public read(): number;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
/// <reference path="./java.nio.charset.Charset.d.ts" />
/// <reference path="./java.nio.charset.CharsetDecoder.d.ts" />
declare module java {
    export module io {
        export class InputStreamReader extends java.io.Reader {
            public ready(): boolean;

            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public constructor();

            public read(): number;

            public constructor(param0: java.io.InputStream, param1: java.nio.charset.CharsetDecoder);

            public read(param0: native.Array<string>): number;

            public getEncoding(): string;

            public constructor(param0: java.io.InputStream, param1: string);

            public read(param0: java.nio.CharBuffer): number;

            public constructor(param0: java.lang.Object);
            public constructor(param0: java.io.InputStream);
            public constructor(param0: java.io.InputStream, param1: java.nio.charset.Charset);

            public close(): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class InterruptedIOException extends java.io.IOException {
            public bytesTransferred: number;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class InvalidClassException extends java.io.ObjectStreamException {
            public classname: string;

            public constructor(param0: string, param1: string);

            public getMessage(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class InvalidObjectException extends java.io.ObjectStreamException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
declare module java {
    export module io {
        export class LineNumberInputStream extends java.io.FilterInputStream {
            public setLineNumber(param0: number): void;

            public read(param0: native.Array<number>): number;

            public getLineNumber(): number;

            public skip(param0: number): number;

            public reset(): void;

            public constructor(param0: java.io.InputStream);

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public close(): void;

            public available(): number;

            public mark(param0: number): void;

            public read(): number;
        }
    }
}

/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
declare module java {
    export module io {
        export class LineNumberReader extends java.io.BufferedReader {
            public readLine(): string;

            public getLineNumber(): number;

            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public constructor();

            public read(): number;

            public setLineNumber(param0: number): void;

            public constructor(param0: java.io.Reader);

            public read(param0: native.Array<string>): number;

            public constructor(param0: java.io.Reader, param1: number);

            public read(param0: java.nio.CharBuffer): number;

            public skip(param0: number): number;

            public constructor(param0: java.lang.Object);

            public reset(): void;

            public close(): void;

            public mark(param0: number): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class NotActiveException extends java.io.ObjectStreamException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class NotSerializableException extends java.io.ObjectStreamException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module io {
        export class ObjectInput extends java.lang.Object implements java.io.DataInput, java.lang.AutoCloseable {
            /**
             * Constructs a new instance of the java.io.ObjectInput interface with the provided implementation.
             */
            public constructor(implementation: {
                available(): number;
                close(): void;
                read(): number;
                read(param0: native.Array<number>): number;
                read(param0: native.Array<number>, param1: number, param2: number): number;
                readObject(): java.lang.Object;
                skip(param0: number): number;
                readBoolean(): boolean;
                readByte(): number;
                readChar(): string;
                readDouble(): number;
                readFloat(): number;
                readFully(param0: native.Array<number>): void;
                readFully(param0: native.Array<number>, param1: number, param2: number): void;
                readInt(): number;
                readLine(): string;
                readLong(): number;
                readShort(): number;
                readUnsignedByte(): number;
                readUnsignedShort(): number;
                readUTF(): string;
                skipBytes(param0: number): number;
                close(): void;
            });

            public readLine(): string;

            public readUnsignedShort(): number;

            public readLong(): number;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public readFully(param0: native.Array<number>, param1: number, param2: number): void;

            public readByte(): number;

            public readUnsignedByte(): number;

            public available(): number;

            public read(): number;

            public readBoolean(): boolean;

            public readShort(): number;

            public readObject(): java.lang.Object;

            public read(param0: native.Array<number>): number;

            public readDouble(): number;

            public skip(param0: number): number;

            public readChar(): string;

            public skipBytes(param0: number): number;

            public close(): void;

            public readUTF(): string;

            public readFloat(): number;

            public readInt(): number;

            public readFully(param0: native.Array<number>): void;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.ObjectInputValidation.d.ts" />
/// <reference path="./java.io.ObjectStreamClass.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class ObjectInputStream extends java.io.InputStream implements java.io.ObjectInput, java.io.ObjectStreamConstants {
            public enableResolveObject(param0: boolean): boolean;

            public readUnshared(): java.lang.Object;

            public readFully(param0: native.Array<number>, param1: number, param2: number): void;

            public readByte(): number;

            public readStreamHeader(): void;

            public readUnsignedByte(): number;

            public available(): number;

            public read(): number;

            public readShort(): number;

            public resolveProxyClass(param0: native.Array<string>): java.lang.Class;

            public readFields(): java.io.ObjectInputStream.GetField;

            public defaultReadObject(): void;

            public readDouble(): number;

            public resolveObject(param0: java.lang.Object): java.lang.Object;

            public skip(param0: number): number;

            public constructor(param0: java.io.InputStream);

            public readChar(): string;

            public skipBytes(param0: number): number;

            public close(): void;

            public readUTF(): string;

            public readFloat(): number;

            public readInt(): number;

            public readLine(): string;

            public readUnsignedShort(): number;

            public readLong(): number;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public readBoolean(): boolean;

            public readObject(): java.lang.Object;

            public readClassDescriptor(): java.io.ObjectStreamClass;

            public resolveClass(param0: java.io.ObjectStreamClass): java.lang.Class;

            public read(param0: native.Array<number>): number;

            public readObjectOverride(): java.lang.Object;

            public registerValidation(param0: java.io.ObjectInputValidation, param1: number): void;

            public readFully(param0: native.Array<number>): void;
        }
        export module ObjectInputStream {
            export abstract class GetField extends java.lang.Object {
                public get(param0: string, param1: number): number;

                public getObjectStreamClass(): java.io.ObjectStreamClass;

                public defaulted(param0: string): boolean;

                public get(param0: string, param1: string): string;
                public get(param0: string, param1: java.lang.Object): java.lang.Object;

                public constructor();

                public get(param0: string, param1: boolean): boolean;
            }
        }
    }
}

declare module java {
    export module io {
        export class ObjectInputValidation extends java.lang.Object {
            /**
             * Constructs a new instance of the java.io.ObjectInputValidation interface with the provided implementation.
             */
            public constructor(implementation: {
                validateObject(): void;
            });

            public validateObject(): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class ObjectOutput extends java.lang.Object implements java.io.DataOutput, java.lang.AutoCloseable {
            /**
             * Constructs a new instance of the java.io.ObjectOutput interface with the provided implementation.
             */
            public constructor(implementation: {
                close(): void;
                flush(): void;
                write(param0: native.Array<number>): void;
                write(param0: native.Array<number>, param1: number, param2: number): void;
                write(param0: number): void;
                writeObject(param0: java.lang.Object): void;
                write(param0: native.Array<number>): void;
                write(param0: native.Array<number>, param1: number, param2: number): void;
                write(param0: number): void;
                writeBoolean(param0: boolean): void;
                writeByte(param0: number): void;
                writeBytes(param0: string): void;
                writeChar(param0: number): void;
                writeChars(param0: string): void;
                writeDouble(param0: number): void;
                writeFloat(param0: number): void;
                writeInt(param0: number): void;
                writeLong(param0: number): void;
                writeShort(param0: number): void;
                writeUTF(param0: string): void;
                close(): void;
            });

            public flush(): void;

            public writeInt(param0: number): void;

            public writeLong(param0: number): void;

            public writeUTF(param0: string): void;

            public writeByte(param0: number): void;

            public writeDouble(param0: number): void;

            public writeBoolean(param0: boolean): void;

            public writeBytes(param0: string): void;

            public writeFloat(param0: number): void;

            public writeShort(param0: number): void;

            public writeObject(param0: java.lang.Object): void;

            public write(param0: number): void;

            public writeChar(param0: number): void;

            public write(param0: native.Array<number>, param1: number, param2: number): void;
            public write(param0: native.Array<number>): void;

            public close(): void;

            public writeChars(param0: string): void;
        }
    }
}

/// <reference path="./java.io.ObjectOutput.d.ts" />
/// <reference path="./java.io.ObjectStreamClass.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class ObjectOutputStream extends java.io.OutputStream implements java.io.ObjectOutput, java.io.ObjectStreamConstants {
            public writeFields(): void;

            public writeUTF(param0: string): void;

            public writeFloat(param0: number): void;

            public annotateProxyClass(param0: java.lang.Class): void;

            public writeObject(param0: java.lang.Object): void;

            public annotateClass(param0: java.lang.Class): void;

            public enableReplaceObject(param0: boolean): boolean;

            public replaceObject(param0: java.lang.Object): java.lang.Object;

            public useProtocolVersion(param0: number): void;

            public reset(): void;

            public writeChar(param0: number): void;

            public write(param0: native.Array<number>): void;

            public writeObjectOverride(param0: java.lang.Object): void;

            public close(): void;

            public flush(): void;

            public writeUnshared(param0: java.lang.Object): void;

            public writeInt(param0: number): void;

            public writeLong(param0: number): void;

            public writeByte(param0: number): void;

            public writeDouble(param0: number): void;

            public writeClassDescriptor(param0: java.io.ObjectStreamClass): void;

            public constructor();

            public writeBoolean(param0: boolean): void;

            public writeBytes(param0: string): void;

            public defaultWriteObject(): void;

            public writeShort(param0: number): void;

            public putFields(): java.io.ObjectOutputStream.PutField;

            public write(param0: number): void;

            public constructor(param0: java.io.OutputStream);

            public write(param0: native.Array<number>, param1: number, param2: number): void;

            public writeStreamHeader(): void;

            public drain(): void;

            public writeChars(param0: string): void;
        }
        export module ObjectOutputStream {
            export abstract class PutField extends java.lang.Object {
                public put(param0: string, param1: java.lang.Object): void;
                public put(param0: string, param1: number): void;
                public put(param0: string, param1: boolean): void;
                public put(param0: string, param1: string): void;

                public write(param0: java.io.ObjectOutput): void;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.ObjectStreamField.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class ObjectStreamClass extends java.lang.Object implements java.io.Serializable {
            public static NO_FIELDS: native.Array<java.io.ObjectStreamField>;

            public forClass(): java.lang.Class;

            public getSerialVersionUID(): number;

            public toString(): string;

            public getName(): string;

            public static lookupAny(param0: java.lang.Class): java.io.ObjectStreamClass;

            public getFields(): native.Array<java.io.ObjectStreamField>;

            public getField(param0: string): java.io.ObjectStreamField;

            public static lookup(param0: java.lang.Class): java.io.ObjectStreamClass;
        }
    }
}

/// <reference path="./java.io.SerializablePermission.d.ts" />
declare module java {
    export module io {
        export class ObjectStreamConstants extends java.lang.Object {
            /**
             * Constructs a new instance of the java.io.ObjectStreamConstants interface with the provided implementation.
             */
            public constructor(implementation: {
                <clinit>(): void;
            });

            public static TC_BLOCKDATA: number;
            public static TC_REFERENCE: number;
            public static TC_MAX: number;
            public static SC_ENUM: number;
            public static TC_BLOCKDATALONG: number;
            public static TC_PROXYCLASSDESC: number;
            public static SC_EXTERNALIZABLE: number;
            public static TC_ARRAY: number;
            public static TC_EXCEPTION: number;
            public static TC_ENDBLOCKDATA: number;
            public static STREAM_VERSION: number;
            public static TC_STRING: number;
            public static TC_BASE: number;
            public static SUBCLASS_IMPLEMENTATION_PERMISSION: java.io.SerializablePermission;
            public static TC_CLASS: number;
            public static PROTOCOL_VERSION_2: number;
            public static STREAM_MAGIC: number;
            public static PROTOCOL_VERSION_1: number;
            public static SC_BLOCK_DATA: number;
            public static TC_ENUM: number;
            public static baseWireHandle: number;
            public static TC_CLASSDESC: number;
            public static TC_NULL: number;
            public static TC_OBJECT: number;
            public static SUBSTITUTION_PERMISSION: java.io.SerializablePermission;
            public static SC_SERIALIZABLE: number;
            public static TC_RESET: number;
            public static TC_LONGSTRING: number;
            public static SC_WRITE_METHOD: number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export abstract class ObjectStreamException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class ObjectStreamField extends java.lang.Object {
            public isUnshared(): boolean;

            public compareTo(param0: java.lang.Object): number;

            public toString(): string;

            public getName(): string;

            public getType(): java.lang.Class;

            public getTypeCode(): string;

            public isPrimitive(): boolean;

            public constructor(param0: string, param1: java.lang.Class);
            public constructor(param0: string, param1: java.lang.Class, param2: boolean);

            public getOffset(): number;

            public setOffset(param0: number): void;

            public getTypeString(): string;
        }
    }
}

declare module java {
    export module io {
        export class OptionalDataException extends java.io.ObjectStreamException {
            public eof: boolean;
            public length: number;
        }
    }
}

declare module java {
    export module io {
        export abstract class OutputStream extends java.lang.Object implements java.io.Closeable, java.io.Flushable {
            public flush(): void;

            public write(param0: number): void;
            public write(param0: native.Array<number>, param1: number, param2: number): void;

            public constructor();

            public write(param0: native.Array<number>): void;

            public close(): void;
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.charset.Charset.d.ts" />
/// <reference path="./java.nio.charset.CharsetEncoder.d.ts" />
declare module java {
    export module io {
        export class OutputStreamWriter extends java.io.Writer {
            public flush(): void;

            public constructor(param0: java.io.OutputStream, param1: java.nio.charset.CharsetEncoder);

            public write(param0: string, param1: number, param2: number): void;
            public write(param0: native.Array<string>, param1: number, param2: number): void;

            public constructor(param0: java.io.OutputStream, param1: string);
            public constructor(param0: java.io.OutputStream, param1: java.nio.charset.Charset);

            public write(param0: native.Array<string>): void;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public write(param0: string): void;

            public getEncoding(): string;

            public write(param0: number): void;

            public append(param0: string): java.io.Writer;

            public constructor(param0: java.lang.Object);
            public constructor(param0: java.io.OutputStream);

            public append(param0: string, param1: number, param2: number): java.io.Writer;

            public close(): void;

            public append(param0: string): java.lang.Appendable;
        }
    }
}

/// <reference path="./java.io.PipedOutputStream.d.ts" />
declare module java {
    export module io {
        export class PipedInputStream extends java.io.InputStream {
            public static PIPE_SIZE: number;
            public buffer: native.Array<number>;
            public in: number;
            public out: number;

            public receive(param0: number): void;

            public read(param0: native.Array<number>): number;

            public constructor(param0: number);

            public connect(param0: java.io.PipedOutputStream): void;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public close(): void;

            public constructor(param0: java.io.PipedOutputStream);
            public constructor(param0: java.io.PipedOutputStream, param1: number);

            public available(): number;

            public read(): number;
        }
    }
}

/// <reference path="./java.io.PipedInputStream.d.ts" />
declare module java {
    export module io {
        export class PipedOutputStream extends java.io.OutputStream {
            public flush(): void;

            public connect(param0: java.io.PipedInputStream): void;

            public write(param0: number): void;
            public write(param0: native.Array<number>, param1: number, param2: number): void;

            public constructor();

            public write(param0: native.Array<number>): void;

            public close(): void;

            public constructor(param0: java.io.PipedInputStream);
        }
    }
}

/// <reference path="./java.io.PipedWriter.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
declare module java {
    export module io {
        export class PipedReader extends java.io.Reader {
            public ready(): boolean;

            public read(param0: native.Array<string>): number;

            public constructor(param0: java.io.PipedWriter, param1: number);

            public read(param0: java.nio.CharBuffer): number;

            public constructor(param0: java.io.PipedWriter);
            public constructor(param0: number);
            public constructor(param0: java.lang.Object);

            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public constructor();

            public close(): void;

            public connect(param0: java.io.PipedWriter): void;

            public read(): number;
        }
    }
}

/// <reference path="./java.io.PipedReader.d.ts" />
/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class PipedWriter extends java.io.Writer {
            public flush(): void;

            public write(param0: string, param1: number, param2: number): void;
            public write(param0: native.Array<string>, param1: number, param2: number): void;
            public write(param0: native.Array<string>): void;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public connect(param0: java.io.PipedReader): void;

            public write(param0: string): void;
            public write(param0: number): void;

            public append(param0: string): java.io.Writer;

            public constructor(param0: java.lang.Object);
            public constructor(param0: java.io.PipedReader);

            public append(param0: string, param1: number, param2: number): java.io.Writer;

            public close(): void;

            public append(param0: string): java.lang.Appendable;
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module io {
        export class PrintStream extends java.io.FilterOutputStream implements java.lang.Appendable, java.io.Closeable {
            public print(param0: number): void;

            public println(): void;

            public constructor(param0: java.io.OutputStream, param1: boolean);

            public format(param0: string, param1: native.Array<java.lang.Object>): java.io.PrintStream;

            public print(param0: java.lang.Object): void;
            public print(param0: boolean): void;

            public constructor(param0: string, param1: string);

            public append(param0: string, param1: number, param2: number): java.io.PrintStream;

            public setError(): void;

            public constructor(param0: java.io.File, param1: string);

            public println(param0: number): void;
            public println(param0: boolean): void;

            public format(param0: java.util.Locale, param1: string, param2: native.Array<java.lang.Object>): java.io.PrintStream;

            public constructor(param0: java.io.File);

            public print(param0: string): void;

            public checkError(): boolean;

            public constructor(param0: java.io.OutputStream, param1: boolean, param2: string);

            public write(param0: native.Array<number>): void;

            public close(): void;

            public clearError(): void;

            public constructor(param0: string);

            public flush(): void;

            public printf(param0: string, param1: native.Array<java.lang.Object>): java.io.PrintStream;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public println(param0: string): void;

            public printf(param0: java.util.Locale, param1: string, param2: native.Array<java.lang.Object>): java.io.PrintStream;

            public print(param0: native.Array<string>): void;

            public println(param0: native.Array<string>): void;

            public write(param0: number): void;

            public constructor(param0: java.io.OutputStream);

            public write(param0: native.Array<number>, param1: number, param2: number): void;

            public println(param0: java.lang.Object): void;

            public append(param0: string): java.io.PrintStream;
            public append(param0: string): java.lang.Appendable;
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module io {
        export class PrintWriter extends java.io.Writer {
            public out: java.io.Writer;

            public print(param0: number): void;

            public println(): void;

            public constructor(param0: java.io.OutputStream, param1: boolean);

            public format(param0: string, param1: native.Array<java.lang.Object>): java.io.PrintWriter;

            public write(param0: native.Array<string>, param1: number, param2: number): void;
            public write(param0: native.Array<string>): void;

            public append(param0: string, param1: number, param2: number): java.io.PrintWriter;

            public print(param0: java.lang.Object): void;
            public print(param0: boolean): void;

            public constructor(param0: string, param1: string);

            public setError(): void;

            public constructor(param0: java.io.File, param1: string);

            public println(param0: number): void;
            public println(param0: boolean): void;

            public append(param0: string): java.io.Writer;
            public append(param0: string): java.io.PrintWriter;

            public constructor(param0: java.lang.Object);
            public constructor(param0: java.io.File);

            public print(param0: string): void;

            public checkError(): boolean;

            public append(param0: string, param1: number, param2: number): java.io.Writer;

            public close(): void;

            public clearError(): void;

            public constructor(param0: string);

            public printf(param0: java.util.Locale, param1: string, param2: native.Array<java.lang.Object>): java.io.PrintWriter;

            public constructor(param0: java.io.Writer);

            public flush(): void;

            public printf(param0: string, param1: native.Array<java.lang.Object>): java.io.PrintWriter;

            public constructor(param0: java.io.Writer, param1: boolean);

            public write(param0: string, param1: number, param2: number): void;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public println(param0: string): void;

            public write(param0: string): void;

            public print(param0: native.Array<string>): void;

            public println(param0: native.Array<string>): void;

            public write(param0: number): void;

            public format(param0: java.util.Locale, param1: string, param2: native.Array<java.lang.Object>): java.io.PrintWriter;

            public constructor(param0: java.io.OutputStream);

            public println(param0: java.lang.Object): void;

            public append(param0: string): java.lang.Appendable;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
declare module java {
    export module io {
        export class PushbackInputStream extends java.io.FilterInputStream {
            public buf: native.Array<number>;
            public pos: number;

            public unread(param0: number): void;

            public markSupported(): boolean;

            public unread(param0: native.Array<number>, param1: number, param2: number): void;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public unread(param0: native.Array<number>): void;

            public available(): number;

            public read(): number;

            public constructor(param0: java.io.InputStream, param1: number);

            public read(param0: native.Array<number>): number;

            public skip(param0: number): number;

            public reset(): void;

            public constructor(param0: java.io.InputStream);

            public close(): void;

            public mark(param0: number): void;
        }
    }
}

/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
declare module java {
    export module io {
        export class PushbackReader extends java.io.FilterReader {
            public ready(): boolean;

            public unread(param0: number): void;

            public markSupported(): boolean;

            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public constructor();

            public read(): number;

            public constructor(param0: java.io.Reader);

            public read(param0: native.Array<string>): number;

            public constructor(param0: java.io.Reader, param1: number);

            public read(param0: java.nio.CharBuffer): number;

            public skip(param0: number): number;

            public constructor(param0: java.lang.Object);

            public reset(): void;

            public close(): void;

            public unread(param0: native.Array<string>): void;
            public unread(param0: native.Array<string>, param1: number, param2: number): void;

            public mark(param0: number): void;
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.FileDescriptor.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.channels.FileChannel.d.ts" />
declare module java {
    export module io {
        export class RandomAccessFile extends java.lang.Object implements java.io.DataInput, java.io.DataOutput, java.io.Closeable {
            public writeUTF(param0: string): void;

            public readFully(param0: native.Array<number>, param1: number, param2: number): void;

            public seek(param0: number): void;

            public readByte(): number;

            public readUnsignedByte(): number;

            public read(): number;

            public readShort(): number;

            public writeFloat(param0: number): void;

            public constructor(param0: string, param1: string);
            public constructor(param0: java.io.File, param1: string);

            public readDouble(): number;

            public writeChar(param0: number): void;

            public readChar(): string;

            public skipBytes(param0: number): number;

            public write(param0: native.Array<number>): void;

            public close(): void;

            public readUTF(): string;

            public readFloat(): number;

            public readInt(): number;

            public finalize(): void;

            public readLine(): string;

            public setLength(param0: number): void;

            public getFD(): java.io.FileDescriptor;

            public readUnsignedShort(): number;

            public writeInt(param0: number): void;

            public writeLong(param0: number): void;

            public length(): number;

            public readLong(): number;

            public writeByte(param0: number): void;

            public writeDouble(param0: number): void;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public writeBoolean(param0: boolean): void;

            public readBoolean(): boolean;

            public writeBytes(param0: string): void;

            public getChannel(): java.nio.channels.FileChannel;

            public writeShort(param0: number): void;

            public getFilePointer(): number;

            public read(param0: native.Array<number>): number;

            public write(param0: number): void;
            public write(param0: native.Array<number>, param1: number, param2: number): void;

            public readFully(param0: native.Array<number>): void;

            public writeChars(param0: string): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
declare module java {
    export module io {
        export abstract class Reader extends java.lang.Object implements java.lang.Readable, java.io.Closeable {
            public lock: java.lang.Object;

            public ready(): boolean;

            public markSupported(): boolean;

            public read(param0: native.Array<string>): number;
            public read(param0: java.nio.CharBuffer): number;

            public skip(param0: number): number;

            public constructor(param0: java.lang.Object);

            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public reset(): void;

            public constructor();

            public close(): void;

            public mark(param0: number): void;

            public read(): number;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module io {
        export class SequenceInputStream extends java.io.InputStream {
            public constructor(param0: java.util.Enumeration);

            public read(param0: native.Array<number>): number;
            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();
            public constructor(param0: java.io.InputStream, param1: java.io.InputStream);

            public close(): void;

            public available(): number;

            public read(): number;
        }
    }
}

declare module java {
    export module io {
        export class Serializable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.io.Serializable interface with the provided implementation.
             */
            public constructor(implementation: {});
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module io {
        export class SerializablePermission extends java.security.BasicPermission {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class StreamCorruptedException extends java.io.ObjectStreamException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
declare module java {
    export module io {
        export class StreamTokenizer extends java.lang.Object {
            public static TT_EOF: number;
            public static TT_EOL: number;
            public static TT_NUMBER: number;
            public static TT_WORD: number;
            public nval: number;
            public sval: string;
            public ttype: number;

            public eolIsSignificant(param0: boolean): void;

            public nextToken(): number;

            public resetSyntax(): void;

            public slashStarComments(param0: boolean): void;

            public wordChars(param0: number, param1: number): void;

            public commentChar(param0: number): void;

            public ordinaryChars(param0: number, param1: number): void;

            public pushBack(): void;

            public lineno(): number;

            public constructor(param0: java.io.Reader);

            public parseNumbers(): void;

            public toString(): string;

            public whitespaceChars(param0: number, param1: number): void;

            public slashSlashComments(param0: boolean): void;

            public quoteChar(param0: number): void;

            public constructor(param0: java.io.InputStream);

            public lowerCaseMode(param0: boolean): void;

            public ordinaryChar(param0: number): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export class StringBufferInputStream extends java.io.InputStream {
            public buffer: string;
            public count: number;
            public pos: number;

            public read(param0: native.Array<number>): number;

            public skip(param0: number): number;

            public reset(): void;

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public close(): void;

            public constructor(param0: string);

            public available(): number;

            public read(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
declare module java {
    export module io {
        export class StringReader extends java.io.Reader {
            public ready(): boolean;

            public markSupported(): boolean;

            public read(param0: native.Array<string>, param1: number, param2: number): number;

            public constructor();

            public read(): number;
            public read(param0: native.Array<string>): number;
            public read(param0: java.nio.CharBuffer): number;

            public skip(param0: number): number;

            public constructor(param0: java.lang.Object);

            public reset(): void;

            public close(): void;

            public constructor(param0: string);

            public mark(param0: number): void;
        }
    }
}

/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
declare module java {
    export module io {
        export class StringWriter extends java.io.Writer {
            public flush(): void;

            public write(param0: string, param1: number, param2: number): void;

            public constructor(param0: number);

            public write(param0: native.Array<string>, param1: number, param2: number): void;
            public write(param0: native.Array<string>): void;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public write(param0: string): void;

            public getBuffer(): java.lang.StringBuffer;

            public toString(): string;

            public write(param0: number): void;

            public append(param0: string, param1: number, param2: number): java.io.StringWriter;
            public append(param0: string): java.io.Writer;

            public constructor(param0: java.lang.Object);

            public append(param0: string, param1: number, param2: number): java.io.Writer;

            public close(): void;

            public append(param0: string): java.lang.Appendable;
            public append(param0: string): java.io.StringWriter;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class SyncFailedException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class UTFDataFormatException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class UnsupportedEncodingException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Exception.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module io {
        export class WriteAbortedException extends java.io.ObjectStreamException {
            public detail: java.lang.Exception;

            public getMessage(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);

            public getCause(): java.lang.Throwable;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string, param1: java.lang.Exception);
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module io {
        export abstract class Writer extends java.lang.Object implements java.lang.Appendable, java.io.Closeable, java.io.Flushable {
            public lock: java.lang.Object;

            public flush(): void;

            public write(param0: string, param1: number, param2: number): void;
            public write(param0: native.Array<string>, param1: number, param2: number): void;
            public write(param0: native.Array<string>): void;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public write(param0: string): void;
            public write(param0: number): void;

            public append(param0: string): java.io.Writer;

            public constructor(param0: java.lang.Object);

            public append(param0: string, param1: number, param2: number): java.io.Writer;

            public close(): void;

            public append(param0: string): java.lang.Appendable;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class AbstractMethodError extends java.lang.IncompatibleClassChangeError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export abstract class AbstractStringBuilder extends java.lang.Object {
            public setLength(param0: number): void;

            public length(): number;

            public indexOf(param0: string, param1: number): number;

            public lastIndexOf(param0: string, param1: number): number;

            public indexOf(param0: string): number;

            public substring(param0: number, param1: number): string;

            public ensureCapacity(param0: number): void;

            public codePointAt(param0: number): number;

            public codePointCount(param0: number, param1: number): number;

            public setCharAt(param0: number, param1: string): void;

            public charAt(param0: number): string;

            public getChars(param0: number, param1: number, param2: native.Array<string>, param3: number): void;

            public toString(): string;

            public subSequence(param0: number, param1: number): string;

            public codePointBefore(param0: number): number;

            public offsetByCodePoints(param0: number, param1: number): number;

            public capacity(): number;

            public trimToSize(): void;

            public substring(param0: number): string;

            public lastIndexOf(param0: string): number;
        }
    }
}

/// <reference path="./java.lang.CharSequence.d.ts" />
declare module java {
    export module lang {
        export class Appendable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.lang.Appendable interface with the provided implementation.
             */
            public constructor(implementation: {
                append(param0: string): java.lang.Appendable;
                append(param0: string): java.lang.Appendable;
                append(param0: string, param1: number, param2: number): java.lang.Appendable;
            });

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;
            public append(param0: string): java.lang.Appendable;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ArithmeticException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ArrayIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: number);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ArrayStoreException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class AssertionError extends java.lang.Error {
            public constructor(param0: boolean);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: number);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor(param0: java.lang.Object);
            public constructor();
            public constructor(param0: string);
        }
    }
}

declare module java {
    export module lang {
        export class AutoCloseable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.lang.AutoCloseable interface with the provided implementation.
             */
            public constructor(implementation: {
                close(): void;
            });

            public close(): void;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Boolean extends java.lang.Object implements java.io.Serializable {
            public static FALSE: java.lang.Boolean;
            public static TRUE: java.lang.Boolean;
            public static TYPE: java.lang.Class;

            public booleanValue(): boolean;

            public constructor(param0: boolean);

            public static getBoolean(param0: string): boolean;

            public static toString(param0: boolean): string;

            public static valueOf(param0: string): java.lang.Boolean;

            public equals(param0: java.lang.Object): boolean;

            public compareTo(param0: java.lang.Boolean): number;

            public static compare(param0: boolean, param1: boolean): number;

            public static valueOf(param0: boolean): java.lang.Boolean;

            public static parseBoolean(param0: string): boolean;

            public toString(): string;

            public constructor(param0: string);

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Byte extends java.lang.Number {
            public static MAX_VALUE: number;
            public static MIN_VALUE: number;
            public static SIZE: number;
            public static TYPE: java.lang.Class;

            public static parseByte(param0: string, param1: number): number;

            public constructor(param0: number);
            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public shortValue(): number;

            public compareTo(param0: java.lang.Byte): number;

            public doubleValue(): number;

            public floatValue(): number;

            public static valueOf(param0: string, param1: number): java.lang.Byte;
            public static valueOf(param0: number): java.lang.Byte;

            public intValue(): number;

            public toString(): string;

            public static compare(param0: number, param1: number): number;

            public byteValue(): number;

            public static valueOf(param0: string): java.lang.Byte;

            public static parseByte(param0: string): number;

            public constructor(param0: string);

            public static toString(param0: number): string;

            public static decode(param0: string): java.lang.Byte;

            public hashCode(): number;

            public longValue(): number;
        }
    }
}

declare module java {
    export module lang {
        export class CharSequence extends java.lang.Object {
            /**
             * Constructs a new instance of the java.lang.CharSequence interface with the provided implementation.
             */
            public constructor(implementation: {
                length(): number;
                charAt(param0: number): string;
                subSequence(param0: number, param1: number): string;
                toString(): string;
            });

            public charAt(param0: number): string;

            public subSequence(param0: number, param1: number): string;

            public toString(): string;

            public length(): number;
        }
    }
}

/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Character extends java.lang.Object implements java.io.Serializable {
            public static COMBINING_SPACING_MARK: number;
            public static CONNECTOR_PUNCTUATION: number;
            public static CONTROL: number;
            public static CURRENCY_SYMBOL: number;
            public static DASH_PUNCTUATION: number;
            public static DECIMAL_DIGIT_NUMBER: number;
            public static DIRECTIONALITY_ARABIC_NUMBER: number;
            public static DIRECTIONALITY_BOUNDARY_NEUTRAL: number;
            public static DIRECTIONALITY_COMMON_NUMBER_SEPARATOR: number;
            public static DIRECTIONALITY_EUROPEAN_NUMBER: number;
            public static DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR: number;
            public static DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR: number;
            public static DIRECTIONALITY_LEFT_TO_RIGHT: number;
            public static DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING: number;
            public static DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE: number;
            public static DIRECTIONALITY_NONSPACING_MARK: number;
            public static DIRECTIONALITY_OTHER_NEUTRALS: number;
            public static DIRECTIONALITY_PARAGRAPH_SEPARATOR: number;
            public static DIRECTIONALITY_POP_DIRECTIONAL_FORMAT: number;
            public static DIRECTIONALITY_RIGHT_TO_LEFT: number;
            public static DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC: number;
            public static DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING: number;
            public static DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE: number;
            public static DIRECTIONALITY_SEGMENT_SEPARATOR: number;
            public static DIRECTIONALITY_UNDEFINED: number;
            public static DIRECTIONALITY_WHITESPACE: number;
            public static ENCLOSING_MARK: number;
            public static END_PUNCTUATION: number;
            public static FINAL_QUOTE_PUNCTUATION: number;
            public static FORMAT: number;
            public static INITIAL_QUOTE_PUNCTUATION: number;
            public static LETTER_NUMBER: number;
            public static LINE_SEPARATOR: number;
            public static LOWERCASE_LETTER: number;
            public static MATH_SYMBOL: number;
            public static MAX_CODE_POINT: number;
            public static MAX_HIGH_SURROGATE: string;
            public static MAX_LOW_SURROGATE: string;
            public static MAX_RADIX: number;
            public static MAX_SURROGATE: string;
            public static MAX_VALUE: string;
            public static MIN_CODE_POINT: number;
            public static MIN_HIGH_SURROGATE: string;
            public static MIN_LOW_SURROGATE: string;
            public static MIN_RADIX: number;
            public static MIN_SUPPLEMENTARY_CODE_POINT: number;
            public static MIN_SURROGATE: string;
            public static MIN_VALUE: string;
            public static MODIFIER_LETTER: number;
            public static MODIFIER_SYMBOL: number;
            public static NON_SPACING_MARK: number;
            public static OTHER_LETTER: number;
            public static OTHER_NUMBER: number;
            public static OTHER_PUNCTUATION: number;
            public static OTHER_SYMBOL: number;
            public static PARAGRAPH_SEPARATOR: number;
            public static PRIVATE_USE: number;
            public static SIZE: number;
            public static SPACE_SEPARATOR: number;
            public static START_PUNCTUATION: number;
            public static SURROGATE: number;
            public static TITLECASE_LETTER: number;
            public static TYPE: java.lang.Class;
            public static UNASSIGNED: number;
            public static UPPERCASE_LETTER: number;

            public static isUnicodeIdentifierPart(param0: number): boolean;

            public static isUnicodeIdentifierStart(param0: number): boolean;

            public static toTitleCase(param0: string): string;

            public static highSurrogate(param0: number): string;

            public static codePointBefore(param0: native.Array<string>, param1: number, param2: number): number;

            public static isLowSurrogate(param0: string): boolean;

            public static getDirectionality(param0: string): number;

            public static getType(param0: string): number;

            public static isDefined(param0: string): boolean;

            public charValue(): string;

            public equals(param0: java.lang.Object): boolean;

            public static isMirrored(param0: number): boolean;

            public static isJavaIdentifierStart(param0: string): boolean;

            public static isValidCodePoint(param0: number): boolean;

            public static isISOControl(param0: number): boolean;

            public static lowSurrogate(param0: number): string;

            public static isDigit(param0: number): boolean;

            public static charCount(param0: number): number;

            public static isIdentifierIgnorable(param0: number): boolean;

            public static isLetterOrDigit(param0: string): boolean;

            public static toLowerCase(param0: string): string;

            public static isDigit(param0: string): boolean;

            public static codePointBefore(param0: native.Array<string>, param1: number): number;

            public static isDefined(param0: number): boolean;

            public constructor(param0: string);

            public static isUpperCase(param0: string): boolean;

            public static isJavaIdentifierStart(param0: number): boolean;

            public static toCodePoint(param0: string, param1: string): number;

            public static isSpace(param0: string): boolean;

            public static isIdeographic(param0: number): boolean;

            public static codePointCount(param0: string, param1: number, param2: number): number;

            public static getType(param0: number): number;

            public static isLetterOrDigit(param0: number): boolean;

            public static getNumericValue(param0: number): number;

            public static isJavaLetterOrDigit(param0: string): boolean;

            public static getNumericValue(param0: string): number;

            public static getDirectionality(param0: number): number;

            public static isLetter(param0: number): boolean;

            public static forDigit(param0: number, param1: number): string;

            public static offsetByCodePoints(param0: string, param1: number, param2: number): number;

            public static isSpaceChar(param0: string): boolean;

            public static isWhitespace(param0: number): boolean;

            public static toChars(param0: number): native.Array<string>;

            public static digit(param0: number, param1: number): number;

            public static toTitleCase(param0: number): number;

            public static isJavaIdentifierPart(param0: number): boolean;

            public static toLowerCase(param0: number): number;

            public static isTitleCase(param0: number): boolean;

            public static isSupplementaryCodePoint(param0: number): boolean;

            public static offsetByCodePoints(param0: native.Array<string>, param1: number, param2: number, param3: number, param4: number): number;

            public static toString(param0: string): string;

            public static isSurrogatePair(param0: string, param1: string): boolean;

            public static toUpperCase(param0: string): string;

            public static isAlphabetic(param0: number): boolean;

            public static isIdentifierIgnorable(param0: string): boolean;

            public static toUpperCase(param0: number): number;

            public static isLowerCase(param0: number): boolean;

            public static valueOf(param0: string): java.lang.Character;

            public static codePointAt(param0: string, param1: number): number;

            public static isUpperCase(param0: number): boolean;

            public static isBmpCodePoint(param0: number): boolean;

            public static isMirrored(param0: string): boolean;

            public static isHighSurrogate(param0: string): boolean;

            public static codePointBefore(param0: string, param1: number): number;

            public static codePointAt(param0: native.Array<string>, param1: number, param2: number): number;

            public static toChars(param0: number, param1: native.Array<string>, param2: number): number;

            public static isUnicodeIdentifierStart(param0: string): boolean;

            public static isJavaLetter(param0: string): boolean;

            public static isLowerCase(param0: string): boolean;

            public static compare(param0: string, param1: string): number;

            public static isLetter(param0: string): boolean;

            public static isUnicodeIdentifierPart(param0: string): boolean;

            public static getName(param0: number): string;

            public static isSpaceChar(param0: number): boolean;

            public toString(): string;

            public static isTitleCase(param0: string): boolean;

            public static digit(param0: string, param1: number): number;

            public static isISOControl(param0: string): boolean;

            public static isJavaIdentifierPart(param0: string): boolean;

            public compareTo(param0: java.lang.Character): number;

            public static codePointAt(param0: native.Array<string>, param1: number): number;

            public static reverseBytes(param0: string): string;

            public static codePointCount(param0: native.Array<string>, param1: number, param2: number): number;

            public static isSurrogate(param0: string): boolean;

            public static isWhitespace(param0: string): boolean;

            public hashCode(): number;
        }
        export module Character {
            export class Subset extends java.lang.Object {
                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public toString(): string;

                public constructor(param0: string);
            }
            export class UnicodeBlock extends java.lang.Character.Subset {
                public static AEGEAN_NUMBERS: java.lang.Character.UnicodeBlock;
                public static ALCHEMICAL_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static ALPHABETIC_PRESENTATION_FORMS: java.lang.Character.UnicodeBlock;
                public static ANCIENT_GREEK_MUSICAL_NOTATION: java.lang.Character.UnicodeBlock;
                public static ANCIENT_GREEK_NUMBERS: java.lang.Character.UnicodeBlock;
                public static ANCIENT_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static ARABIC: java.lang.Character.UnicodeBlock;
                public static ARABIC_PRESENTATION_FORMS_A: java.lang.Character.UnicodeBlock;
                public static ARABIC_PRESENTATION_FORMS_B: java.lang.Character.UnicodeBlock;
                public static ARABIC_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static ARMENIAN: java.lang.Character.UnicodeBlock;
                public static ARROWS: java.lang.Character.UnicodeBlock;
                public static AVESTAN: java.lang.Character.UnicodeBlock;
                public static BALINESE: java.lang.Character.UnicodeBlock;
                public static BAMUM: java.lang.Character.UnicodeBlock;
                public static BAMUM_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static BASIC_LATIN: java.lang.Character.UnicodeBlock;
                public static BATAK: java.lang.Character.UnicodeBlock;
                public static BENGALI: java.lang.Character.UnicodeBlock;
                public static BLOCK_ELEMENTS: java.lang.Character.UnicodeBlock;
                public static BOPOMOFO: java.lang.Character.UnicodeBlock;
                public static BOPOMOFO_EXTENDED: java.lang.Character.UnicodeBlock;
                public static BOX_DRAWING: java.lang.Character.UnicodeBlock;
                public static BRAHMI: java.lang.Character.UnicodeBlock;
                public static BRAILLE_PATTERNS: java.lang.Character.UnicodeBlock;
                public static BUGINESE: java.lang.Character.UnicodeBlock;
                public static BUHID: java.lang.Character.UnicodeBlock;
                public static BYZANTINE_MUSICAL_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static CARIAN: java.lang.Character.UnicodeBlock;
                public static CHAM: java.lang.Character.UnicodeBlock;
                public static CHEROKEE: java.lang.Character.UnicodeBlock;
                public static CJK_COMPATIBILITY: java.lang.Character.UnicodeBlock;
                public static CJK_COMPATIBILITY_FORMS: java.lang.Character.UnicodeBlock;
                public static CJK_COMPATIBILITY_IDEOGRAPHS: java.lang.Character.UnicodeBlock;
                public static CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static CJK_RADICALS_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static CJK_STROKES: java.lang.Character.UnicodeBlock;
                public static CJK_SYMBOLS_AND_PUNCTUATION: java.lang.Character.UnicodeBlock;
                public static CJK_UNIFIED_IDEOGRAPHS: java.lang.Character.UnicodeBlock;
                public static CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A: java.lang.Character.UnicodeBlock;
                public static CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B: java.lang.Character.UnicodeBlock;
                public static CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C: java.lang.Character.UnicodeBlock;
                public static CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D: java.lang.Character.UnicodeBlock;
                public static COMBINING_DIACRITICAL_MARKS: java.lang.Character.UnicodeBlock;
                public static COMBINING_DIACRITICAL_MARKS_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static COMBINING_HALF_MARKS: java.lang.Character.UnicodeBlock;
                public static COMBINING_MARKS_FOR_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static COMMON_INDIC_NUMBER_FORMS: java.lang.Character.UnicodeBlock;
                public static CONTROL_PICTURES: java.lang.Character.UnicodeBlock;
                public static COPTIC: java.lang.Character.UnicodeBlock;
                public static COUNTING_ROD_NUMERALS: java.lang.Character.UnicodeBlock;
                public static CUNEIFORM: java.lang.Character.UnicodeBlock;
                public static CUNEIFORM_NUMBERS_AND_PUNCTUATION: java.lang.Character.UnicodeBlock;
                public static CURRENCY_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static CYPRIOT_SYLLABARY: java.lang.Character.UnicodeBlock;
                public static CYRILLIC: java.lang.Character.UnicodeBlock;
                public static CYRILLIC_EXTENDED_A: java.lang.Character.UnicodeBlock;
                public static CYRILLIC_EXTENDED_B: java.lang.Character.UnicodeBlock;
                public static CYRILLIC_SUPPLEMENTARY: java.lang.Character.UnicodeBlock;
                public static DESERET: java.lang.Character.UnicodeBlock;
                public static DEVANAGARI: java.lang.Character.UnicodeBlock;
                public static DEVANAGARI_EXTENDED: java.lang.Character.UnicodeBlock;
                public static DINGBATS: java.lang.Character.UnicodeBlock;
                public static DOMINO_TILES: java.lang.Character.UnicodeBlock;
                public static EGYPTIAN_HIEROGLYPHS: java.lang.Character.UnicodeBlock;
                public static EMOTICONS: java.lang.Character.UnicodeBlock;
                public static ENCLOSED_ALPHANUMERICS: java.lang.Character.UnicodeBlock;
                public static ENCLOSED_ALPHANUMERIC_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static ENCLOSED_CJK_LETTERS_AND_MONTHS: java.lang.Character.UnicodeBlock;
                public static ENCLOSED_IDEOGRAPHIC_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static ETHIOPIC: java.lang.Character.UnicodeBlock;
                public static ETHIOPIC_EXTENDED: java.lang.Character.UnicodeBlock;
                public static ETHIOPIC_EXTENDED_A: java.lang.Character.UnicodeBlock;
                public static ETHIOPIC_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static GENERAL_PUNCTUATION: java.lang.Character.UnicodeBlock;
                public static GEOMETRIC_SHAPES: java.lang.Character.UnicodeBlock;
                public static GEORGIAN: java.lang.Character.UnicodeBlock;
                public static GEORGIAN_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static GLAGOLITIC: java.lang.Character.UnicodeBlock;
                public static GOTHIC: java.lang.Character.UnicodeBlock;
                public static GREEK: java.lang.Character.UnicodeBlock;
                public static GREEK_EXTENDED: java.lang.Character.UnicodeBlock;
                public static GUJARATI: java.lang.Character.UnicodeBlock;
                public static GURMUKHI: java.lang.Character.UnicodeBlock;
                public static HALFWIDTH_AND_FULLWIDTH_FORMS: java.lang.Character.UnicodeBlock;
                public static HANGUL_COMPATIBILITY_JAMO: java.lang.Character.UnicodeBlock;
                public static HANGUL_JAMO: java.lang.Character.UnicodeBlock;
                public static HANGUL_JAMO_EXTENDED_A: java.lang.Character.UnicodeBlock;
                public static HANGUL_JAMO_EXTENDED_B: java.lang.Character.UnicodeBlock;
                public static HANGUL_SYLLABLES: java.lang.Character.UnicodeBlock;
                public static HANUNOO: java.lang.Character.UnicodeBlock;
                public static HEBREW: java.lang.Character.UnicodeBlock;
                public static HIGH_PRIVATE_USE_SURROGATES: java.lang.Character.UnicodeBlock;
                public static HIGH_SURROGATES: java.lang.Character.UnicodeBlock;
                public static HIRAGANA: java.lang.Character.UnicodeBlock;
                public static IDEOGRAPHIC_DESCRIPTION_CHARACTERS: java.lang.Character.UnicodeBlock;
                public static IMPERIAL_ARAMAIC: java.lang.Character.UnicodeBlock;
                public static INSCRIPTIONAL_PAHLAVI: java.lang.Character.UnicodeBlock;
                public static INSCRIPTIONAL_PARTHIAN: java.lang.Character.UnicodeBlock;
                public static IPA_EXTENSIONS: java.lang.Character.UnicodeBlock;
                public static JAVANESE: java.lang.Character.UnicodeBlock;
                public static KAITHI: java.lang.Character.UnicodeBlock;
                public static KANA_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static KANBUN: java.lang.Character.UnicodeBlock;
                public static KANGXI_RADICALS: java.lang.Character.UnicodeBlock;
                public static KANNADA: java.lang.Character.UnicodeBlock;
                public static KATAKANA: java.lang.Character.UnicodeBlock;
                public static KATAKANA_PHONETIC_EXTENSIONS: java.lang.Character.UnicodeBlock;
                public static KAYAH_LI: java.lang.Character.UnicodeBlock;
                public static KHAROSHTHI: java.lang.Character.UnicodeBlock;
                public static KHMER: java.lang.Character.UnicodeBlock;
                public static KHMER_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static LAO: java.lang.Character.UnicodeBlock;
                public static LATIN_1_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static LATIN_EXTENDED_A: java.lang.Character.UnicodeBlock;
                public static LATIN_EXTENDED_ADDITIONAL: java.lang.Character.UnicodeBlock;
                public static LATIN_EXTENDED_B: java.lang.Character.UnicodeBlock;
                public static LATIN_EXTENDED_C: java.lang.Character.UnicodeBlock;
                public static LATIN_EXTENDED_D: java.lang.Character.UnicodeBlock;
                public static LEPCHA: java.lang.Character.UnicodeBlock;
                public static LETTERLIKE_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static LIMBU: java.lang.Character.UnicodeBlock;
                public static LINEAR_B_IDEOGRAMS: java.lang.Character.UnicodeBlock;
                public static LINEAR_B_SYLLABARY: java.lang.Character.UnicodeBlock;
                public static LISU: java.lang.Character.UnicodeBlock;
                public static LOW_SURROGATES: java.lang.Character.UnicodeBlock;
                public static LYCIAN: java.lang.Character.UnicodeBlock;
                public static LYDIAN: java.lang.Character.UnicodeBlock;
                public static MAHJONG_TILES: java.lang.Character.UnicodeBlock;
                public static MALAYALAM: java.lang.Character.UnicodeBlock;
                public static MANDAIC: java.lang.Character.UnicodeBlock;
                public static MATHEMATICAL_ALPHANUMERIC_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static MATHEMATICAL_OPERATORS: java.lang.Character.UnicodeBlock;
                public static MEETEI_MAYEK: java.lang.Character.UnicodeBlock;
                public static MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A: java.lang.Character.UnicodeBlock;
                public static MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B: java.lang.Character.UnicodeBlock;
                public static MISCELLANEOUS_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static MISCELLANEOUS_SYMBOLS_AND_ARROWS: java.lang.Character.UnicodeBlock;
                public static MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS: java.lang.Character.UnicodeBlock;
                public static MISCELLANEOUS_TECHNICAL: java.lang.Character.UnicodeBlock;
                public static MODIFIER_TONE_LETTERS: java.lang.Character.UnicodeBlock;
                public static MONGOLIAN: java.lang.Character.UnicodeBlock;
                public static MUSICAL_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static MYANMAR: java.lang.Character.UnicodeBlock;
                public static MYANMAR_EXTENDED_A: java.lang.Character.UnicodeBlock;
                public static NEW_TAI_LUE: java.lang.Character.UnicodeBlock;
                public static NKO: java.lang.Character.UnicodeBlock;
                public static NUMBER_FORMS: java.lang.Character.UnicodeBlock;
                public static OGHAM: java.lang.Character.UnicodeBlock;
                public static OLD_ITALIC: java.lang.Character.UnicodeBlock;
                public static OLD_PERSIAN: java.lang.Character.UnicodeBlock;
                public static OLD_SOUTH_ARABIAN: java.lang.Character.UnicodeBlock;
                public static OLD_TURKIC: java.lang.Character.UnicodeBlock;
                public static OL_CHIKI: java.lang.Character.UnicodeBlock;
                public static OPTICAL_CHARACTER_RECOGNITION: java.lang.Character.UnicodeBlock;
                public static ORIYA: java.lang.Character.UnicodeBlock;
                public static OSMANYA: java.lang.Character.UnicodeBlock;
                public static PHAGS_PA: java.lang.Character.UnicodeBlock;
                public static PHAISTOS_DISC: java.lang.Character.UnicodeBlock;
                public static PHOENICIAN: java.lang.Character.UnicodeBlock;
                public static PHONETIC_EXTENSIONS: java.lang.Character.UnicodeBlock;
                public static PHONETIC_EXTENSIONS_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static PLAYING_CARDS: java.lang.Character.UnicodeBlock;
                public static PRIVATE_USE_AREA: java.lang.Character.UnicodeBlock;
                public static REJANG: java.lang.Character.UnicodeBlock;
                public static RUMI_NUMERAL_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static RUNIC: java.lang.Character.UnicodeBlock;
                public static SAMARITAN: java.lang.Character.UnicodeBlock;
                public static SAURASHTRA: java.lang.Character.UnicodeBlock;
                public static SHAVIAN: java.lang.Character.UnicodeBlock;
                public static SINHALA: java.lang.Character.UnicodeBlock;
                public static SMALL_FORM_VARIANTS: java.lang.Character.UnicodeBlock;
                public static SPACING_MODIFIER_LETTERS: java.lang.Character.UnicodeBlock;
                public static SPECIALS: java.lang.Character.UnicodeBlock;
                public static SUNDANESE: java.lang.Character.UnicodeBlock;
                public static SUPERSCRIPTS_AND_SUBSCRIPTS: java.lang.Character.UnicodeBlock;
                public static SUPPLEMENTAL_ARROWS_A: java.lang.Character.UnicodeBlock;
                public static SUPPLEMENTAL_ARROWS_B: java.lang.Character.UnicodeBlock;
                public static SUPPLEMENTAL_MATHEMATICAL_OPERATORS: java.lang.Character.UnicodeBlock;
                public static SUPPLEMENTAL_PUNCTUATION: java.lang.Character.UnicodeBlock;
                public static SUPPLEMENTARY_PRIVATE_USE_AREA_A: java.lang.Character.UnicodeBlock;
                public static SUPPLEMENTARY_PRIVATE_USE_AREA_B: java.lang.Character.UnicodeBlock;
                public static SURROGATES_AREA: java.lang.Character.UnicodeBlock;
                public static SYLOTI_NAGRI: java.lang.Character.UnicodeBlock;
                public static SYRIAC: java.lang.Character.UnicodeBlock;
                public static TAGALOG: java.lang.Character.UnicodeBlock;
                public static TAGBANWA: java.lang.Character.UnicodeBlock;
                public static TAGS: java.lang.Character.UnicodeBlock;
                public static TAI_LE: java.lang.Character.UnicodeBlock;
                public static TAI_THAM: java.lang.Character.UnicodeBlock;
                public static TAI_VIET: java.lang.Character.UnicodeBlock;
                public static TAI_XUAN_JING_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static TAMIL: java.lang.Character.UnicodeBlock;
                public static TELUGU: java.lang.Character.UnicodeBlock;
                public static THAANA: java.lang.Character.UnicodeBlock;
                public static THAI: java.lang.Character.UnicodeBlock;
                public static TIBETAN: java.lang.Character.UnicodeBlock;
                public static TIFINAGH: java.lang.Character.UnicodeBlock;
                public static TRANSPORT_AND_MAP_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static UGARITIC: java.lang.Character.UnicodeBlock;
                public static UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS: java.lang.Character.UnicodeBlock;
                public static UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED: java.lang.Character.UnicodeBlock;
                public static VAI: java.lang.Character.UnicodeBlock;
                public static VARIATION_SELECTORS: java.lang.Character.UnicodeBlock;
                public static VARIATION_SELECTORS_SUPPLEMENT: java.lang.Character.UnicodeBlock;
                public static VEDIC_EXTENSIONS: java.lang.Character.UnicodeBlock;
                public static VERTICAL_FORMS: java.lang.Character.UnicodeBlock;
                public static YIJING_HEXAGRAM_SYMBOLS: java.lang.Character.UnicodeBlock;
                public static YI_RADICALS: java.lang.Character.UnicodeBlock;
                public static YI_SYLLABLES: java.lang.Character.UnicodeBlock;

                public static forName(param0: string): java.lang.Character.UnicodeBlock;

                public static of(param0: string): java.lang.Character.UnicodeBlock;
                public static of(param0: number): java.lang.Character.UnicodeBlock;
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.ClassLoader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Package.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.annotation.Annotation.d.ts" />
/// <reference path="./java.lang.reflect.Constructor.d.ts" />
/// <reference path="./java.lang.reflect.Field.d.ts" />
/// <reference path="./java.lang.reflect.Method.d.ts" />
/// <reference path="./java.lang.reflect.Type.d.ts" />
/// <reference path="./java.lang.reflect.TypeVariable.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.security.ProtectionDomain.d.ts" />
declare module java {
    export module lang {
        export class Class extends java.lang.Object implements java.io.Serializable, java.lang.reflect.AnnotatedElement, java.lang.reflect.GenericDeclaration, java.lang.reflect.Type {
            public getClassLoader(): java.lang.ClassLoader;

            public isInterface(): boolean;

            public getEnclosingConstructor(): java.lang.reflect.Constructor;

            public isArray(): boolean;

            public desiredAssertionStatus(): boolean;

            public getProtectionDomain(): java.security.ProtectionDomain;

            public getCanonicalName(): string;

            public isInstance(param0: java.lang.Object): boolean;

            public isPrimitive(): boolean;

            public getDeclaredFields(): native.Array<java.lang.reflect.Field>;

            public getModifiers(): number;

            public getEnumConstants(): native.Array<java.lang.Object>;

            public cast(param0: java.lang.Object): java.lang.Object;

            public getDeclaredField(param0: string): java.lang.reflect.Field;

            public getConstructors(): native.Array<java.lang.reflect.Constructor>;

            public getDeclaredClasses(): native.Array<java.lang.Class>;

            public getMethod(param0: string, param1: native.Array<java.lang.Class>): java.lang.reflect.Method;

            public getMethods(): native.Array<java.lang.reflect.Method>;

            public getClasses(): native.Array<java.lang.Class>;

            public getGenericSuperclass(): java.lang.reflect.Type;

            public isAnnotationPresent(param0: java.lang.Class): boolean;

            public isAssignableFrom(param0: java.lang.Class): boolean;

            public isEnum(): boolean;

            public getTypeParameters(): native.Array<java.lang.reflect.TypeVariable>;

            public isAnnotation(): boolean;

            public getSuperclass(): java.lang.Class;

            public newInstance(): java.lang.Object;

            public getSigners(): native.Array<java.lang.Object>;

            public getDeclaredMethods(): native.Array<java.lang.reflect.Method>;

            public static forName(param0: string, param1: boolean, param2: java.lang.ClassLoader): java.lang.Class;

            public getResourceAsStream(param0: string): java.io.InputStream;

            public getDeclaredConstructors(): native.Array<java.lang.reflect.Constructor>;

            public getGenericInterfaces(): native.Array<java.lang.reflect.Type>;

            public getDeclaredMethod(param0: string, param1: native.Array<java.lang.Class>): java.lang.reflect.Method;

            public getConstructor(param0: native.Array<java.lang.Class>): java.lang.reflect.Constructor;

            public getSimpleName(): string;

            public getDeclaredAnnotations(): native.Array<java.lang.annotation.Annotation>;

            public getInterfaces(): native.Array<java.lang.Class>;

            public getFields(): native.Array<java.lang.reflect.Field>;

            public isAnonymousClass(): boolean;

            public getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;

            public getField(param0: string): java.lang.reflect.Field;

            public getDeclaredConstructor(param0: native.Array<java.lang.Class>): java.lang.reflect.Constructor;

            public getEnclosingClass(): java.lang.Class;

            public getDeclaringClass(): java.lang.Class;

            public getComponentType(): java.lang.Class;

            public getPackage(): java.lang.Package;

            public isSynthetic(): boolean;

            public toString(): string;

            public getEnclosingMethod(): java.lang.reflect.Method;

            public getName(): string;

            public getAnnotations(): native.Array<java.lang.annotation.Annotation>;

            public isLocalClass(): boolean;

            public asSubclass(param0: java.lang.Class): java.lang.Class;

            public isMemberClass(): boolean;

            public getResource(param0: string): java.net.URL;

            public static forName(param0: string): java.lang.Class;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ClassCastException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ClassCircularityError extends java.lang.LinkageError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ClassFormatError extends java.lang.LinkageError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Package.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.security.ProtectionDomain.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module lang {
        export abstract class ClassLoader extends java.lang.Object {
            public defineClass(param0: string, param1: native.Array<number>, param2: number, param3: number, param4: java.security.ProtectionDomain): java.lang.Class;

            public findLibrary(param0: string): string;

            public findResource(param0: string): java.net.URL;

            public constructor(param0: java.lang.ClassLoader);

            public getParent(): java.lang.ClassLoader;

            public getPackage(param0: string): java.lang.Package;

            public defineClass(param0: string, param1: java.nio.ByteBuffer, param2: java.security.ProtectionDomain): java.lang.Class;

            public setSigners(param0: java.lang.Class, param1: native.Array<java.lang.Object>): void;

            public setPackageAssertionStatus(param0: string, param1: boolean): void;

            public getPackages(): native.Array<java.lang.Package>;

            public setClassAssertionStatus(param0: string, param1: boolean): void;

            public static getSystemResource(param0: string): java.net.URL;

            public defineClass(param0: string, param1: native.Array<number>, param2: number, param3: number): java.lang.Class;

            public resolveClass(param0: java.lang.Class): void;

            public loadClass(param0: string, param1: boolean): java.lang.Class;

            public static getSystemResources(param0: string): java.util.Enumeration;

            public loadClass(param0: string): java.lang.Class;

            public findLoadedClass(param0: string): java.lang.Class;

            public getResources(param0: string): java.util.Enumeration;

            public constructor();

            public static getSystemResourceAsStream(param0: string): java.io.InputStream;

            public defineClass(param0: native.Array<number>, param1: number, param2: number): java.lang.Class;

            public definePackage(param0: string, param1: string, param2: string, param3: string, param4: string, param5: string, param6: string, param7: java.net.URL): java.lang.Package;

            public static getSystemClassLoader(): java.lang.ClassLoader;

            public findClass(param0: string): java.lang.Class;

            public getResourceAsStream(param0: string): java.io.InputStream;

            public findSystemClass(param0: string): java.lang.Class;

            public getResource(param0: string): java.net.URL;

            public setDefaultAssertionStatus(param0: boolean): void;

            public clearAssertionStatus(): void;

            public findResources(param0: string): java.util.Enumeration;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ClassNotFoundException extends java.lang.ReflectiveOperationException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);

            public getException(): java.lang.Throwable;

            public getCause(): java.lang.Throwable;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class CloneNotSupportedException extends java.lang.Exception {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

declare module java {
    export module lang {
        export class Cloneable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.lang.Cloneable interface with the provided implementation.
             */
            public constructor(implementation: {});
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export class Comparable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.lang.Comparable interface with the provided implementation.
             */
            public constructor(implementation: {
                compareTo(param0: java.lang.Object): number;
            });

            public compareTo(param0: java.lang.Object): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Compiler extends java.lang.Object {
            public static compileClass(param0: java.lang.Class): boolean;

            public static enable(): void;

            public static command(param0: java.lang.Object): java.lang.Object;

            public static disable(): void;

            public static compileClasses(param0: string): boolean;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export class Deprecated extends java.lang.Object implements java.lang.annotation.Annotation {
            /**
             * Constructs a new instance of the java.lang.Deprecated interface with the provided implementation.
             */
            public constructor(implementation: {
                annotationType(): java.lang.Class;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                toString(): string;
            });

            public annotationType(): java.lang.Class;

            public toString(): string;

            public equals(param0: java.lang.Object): boolean;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Double extends java.lang.Number {
            public static MAX_EXPONENT: number;
            public static MAX_VALUE: number;
            public static MIN_EXPONENT: number;
            public static MIN_NORMAL: number;
            public static MIN_VALUE: number;
            public static NEGATIVE_INFINITY: number;
            public static NaN: number;
            public static POSITIVE_INFINITY: number;
            public static SIZE: number;
            public static TYPE: java.lang.Class;

            public static doubleToRawLongBits(param0: number): number;

            public static valueOf(param0: string): java.lang.Double;

            public equals(param0: java.lang.Object): boolean;

            public static longBitsToDouble(param0: number): number;

            public shortValue(): number;

            public static valueOf(param0: number): java.lang.Double;

            public doubleValue(): number;

            public static parseDouble(param0: string): number;

            public isInfinite(): boolean;

            public compareTo(param0: java.lang.Double): number;

            public constructor(param0: string);

            public static doubleToLongBits(param0: number): number;

            public constructor(param0: number);
            public constructor();

            public floatValue(): number;

            public isNaN(): boolean;

            public intValue(): number;

            public toString(): string;

            public static toHexString(param0: number): string;

            public static compare(param0: number, param1: number): number;

            public byteValue(): number;

            public static isNaN(param0: number): boolean;

            public static isInfinite(param0: number): boolean;

            public static toString(param0: number): string;

            public hashCode(): number;

            public longValue(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export abstract class Enum extends java.lang.Object implements java.io.Serializable {
            public getDeclaringClass(): java.lang.Class;

            public toString(): string;

            public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;

            public name(): string;

            public constructor(param0: string, param1: number);

            public compareTo(param0: java.lang.Enum): number;

            public ordinal(): number;

            public equals(param0: java.lang.Object): boolean;

            public clone(): java.lang.Object;

            public finalize(): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class EnumConstantNotPresentException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);

            public enumType(): java.lang.Class;

            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: java.lang.Class, param1: string);

            public constantName(): string;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class Error extends java.lang.Throwable {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class Exception extends java.lang.Throwable {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ExceptionInInitializerError extends java.lang.LinkageError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);

            public getException(): java.lang.Throwable;

            public getCause(): java.lang.Throwable;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Float extends java.lang.Number {
            public static MAX_EXPONENT: number;
            public static MAX_VALUE: number;
            public static MIN_EXPONENT: number;
            public static MIN_NORMAL: number;
            public static MIN_VALUE: number;
            public static NEGATIVE_INFINITY: number;
            public static NaN: number;
            public static POSITIVE_INFINITY: number;
            public static SIZE: number;
            public static TYPE: java.lang.Class;

            public static parseFloat(param0: string): number;

            public equals(param0: java.lang.Object): boolean;

            public static floatToRawIntBits(param0: number): number;

            public shortValue(): number;

            public compareTo(param0: java.lang.Float): number;

            public doubleValue(): number;

            public isInfinite(): boolean;

            public constructor(param0: string);
            public constructor(param0: number);

            public static intBitsToFloat(param0: number): number;

            public static valueOf(param0: string): java.lang.Float;

            public constructor();

            public floatValue(): number;

            public isNaN(): boolean;

            public intValue(): number;

            public toString(): string;

            public static toHexString(param0: number): string;

            public static floatToIntBits(param0: number): number;

            public static compare(param0: number, param1: number): number;

            public byteValue(): number;

            public static isNaN(param0: number): boolean;

            public static valueOf(param0: number): java.lang.Float;

            public static isInfinite(param0: number): boolean;

            public static toString(param0: number): string;

            public hashCode(): number;

            public longValue(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class IllegalAccessError extends java.lang.IncompatibleClassChangeError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class IllegalAccessException extends java.lang.ReflectiveOperationException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class IllegalArgumentException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class IllegalMonitorStateException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class IllegalStateException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class IllegalThreadStateException extends java.lang.IllegalArgumentException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class IncompatibleClassChangeError extends java.lang.LinkageError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class IndexOutOfBoundsException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export class InheritableThreadLocal extends java.lang.ThreadLocal {
            public childValue(param0: java.lang.Object): java.lang.Object;

            public constructor();
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class InstantiationError extends java.lang.IncompatibleClassChangeError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class InstantiationException extends java.lang.ReflectiveOperationException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Integer extends java.lang.Number {
            public static MAX_VALUE: number;
            public static MIN_VALUE: number;
            public static SIZE: number;
            public static TYPE: java.lang.Class;

            public static bitCount(param0: number): number;

            public static toOctalString(param0: number): string;

            public static lowestOneBit(param0: number): number;

            public static highestOneBit(param0: number): number;

            public static valueOf(param0: number): java.lang.Integer;

            public equals(param0: java.lang.Object): boolean;

            public shortValue(): number;

            public doubleValue(): number;

            public static parseInt(param0: string): number;

            public static signum(param0: number): number;

            public static reverseBytes(param0: number): number;

            public static getInteger(param0: string): java.lang.Integer;

            public static rotateLeft(param0: number, param1: number): number;

            public static parseInt(param0: string, param1: number): number;

            public constructor(param0: string);

            public static getInteger(param0: string, param1: java.lang.Integer): java.lang.Integer;

            public static numberOfLeadingZeros(param0: number): number;

            public static rotateRight(param0: number, param1: number): number;

            public static toString(param0: number, param1: number): string;

            public constructor(param0: number);

            public static reverse(param0: number): number;

            public constructor();

            public static getInteger(param0: string, param1: number): java.lang.Integer;

            public static valueOf(param0: string, param1: number): java.lang.Integer;

            public floatValue(): number;

            public compareTo(param0: java.lang.Integer): number;

            public intValue(): number;

            public static toHexString(param0: number): string;

            public toString(): string;

            public static compare(param0: number, param1: number): number;

            public static numberOfTrailingZeros(param0: number): number;

            public static toBinaryString(param0: number): string;

            public byteValue(): number;

            public static decode(param0: string): java.lang.Integer;

            public static valueOf(param0: string): java.lang.Integer;

            public static toString(param0: number): string;

            public hashCode(): number;

            public longValue(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class InternalError extends java.lang.VirtualMachineError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class InterruptedException extends java.lang.Exception {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module lang {
        export class Iterable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.lang.Iterable interface with the provided implementation.
             */
            public constructor(implementation: {
                iterator(): java.util.Iterator;
            });

            public iterator(): java.util.Iterator;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class LinkageError extends java.lang.Error {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Long extends java.lang.Number {
            public static MAX_VALUE: number;
            public static MIN_VALUE: number;
            public static SIZE: number;
            public static TYPE: java.lang.Class;

            public static parseLong(param0: string, param1: number): number;

            public static bitCount(param0: number): number;

            public static toOctalString(param0: number): string;

            public static decode(param0: string): java.lang.Long;

            public static valueOf(param0: string): java.lang.Long;

            public static lowestOneBit(param0: number): number;

            public static highestOneBit(param0: number): number;

            public static getLong(param0: string, param1: number): java.lang.Long;

            public equals(param0: java.lang.Object): boolean;

            public static parseLong(param0: string): number;

            public static valueOf(param0: number): java.lang.Long;

            public shortValue(): number;

            public compareTo(param0: java.lang.Long): number;

            public doubleValue(): number;

            public static signum(param0: number): number;

            public static reverseBytes(param0: number): number;

            public static getLong(param0: string, param1: java.lang.Long): java.lang.Long;

            public static rotateLeft(param0: number, param1: number): number;

            public constructor(param0: string);

            public static numberOfLeadingZeros(param0: number): number;

            public static rotateRight(param0: number, param1: number): number;

            public static toString(param0: number, param1: number): string;

            public constructor(param0: number);

            public static reverse(param0: number): number;

            public constructor();

            public static valueOf(param0: string, param1: number): java.lang.Long;

            public floatValue(): number;

            public intValue(): number;

            public static toHexString(param0: number): string;

            public toString(): string;

            public static compare(param0: number, param1: number): number;

            public static numberOfTrailingZeros(param0: number): number;

            public static toBinaryString(param0: number): string;

            public byteValue(): number;

            public static getLong(param0: string): java.lang.Long;

            public static toString(param0: number): string;

            public hashCode(): number;

            public longValue(): number;
        }
    }
}

declare module java {
    export module lang {
        export class Math extends java.lang.Object {
            public static E: number;
            public static PI: number;

            public static getExponent(param0: number): number;

            public static ulp(param0: number): number;

            public static acos(param0: number): number;

            public static sin(param0: number): number;

            public static expm1(param0: number): number;

            public static log1p(param0: number): number;

            public static copySign(param0: number, param1: number): number;

            public static ceil(param0: number): number;

            public static atan2(param0: number, param1: number): number;

            public static signum(param0: number): number;

            public static cosh(param0: number): number;

            public static sqrt(param0: number): number;

            public static nextAfter(param0: number, param1: number): number;

            public static min(param0: number, param1: number): number;

            public static toDegrees(param0: number): number;

            public static random(): number;

            public static asin(param0: number): number;

            public static log10(param0: number): number;

            public static exp(param0: number): number;

            public static log(param0: number): number;

            public static floor(param0: number): number;

            public static round(param0: number): number;

            public static toRadians(param0: number): number;

            public static hypot(param0: number, param1: number): number;

            public static sinh(param0: number): number;

            public static tanh(param0: number): number;

            public static tan(param0: number): number;

            public static cos(param0: number): number;

            public static rint(param0: number): number;

            public static cbrt(param0: number): number;

            public static IEEEremainder(param0: number, param1: number): number;

            public static max(param0: number, param1: number): number;

            public static pow(param0: number, param1: number): number;

            public static scalb(param0: number, param1: number): number;

            public static abs(param0: number): number;

            public static atan(param0: number): number;

            public static nextUp(param0: number): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class NegativeArraySizeException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class NoClassDefFoundError extends java.lang.LinkageError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class NoSuchFieldError extends java.lang.IncompatibleClassChangeError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class NoSuchFieldException extends java.lang.ReflectiveOperationException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class NoSuchMethodError extends java.lang.IncompatibleClassChangeError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class NoSuchMethodException extends java.lang.ReflectiveOperationException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class NullPointerException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

declare module java {
    export module lang {
        export abstract class Number extends java.lang.Object implements java.io.Serializable {
            public doubleValue(): number;

            public floatValue(): number;

            public intValue(): number;

            public byteValue(): number;

            public constructor();

            public shortValue(): number;

            public longValue(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class NumberFormatException extends java.lang.IllegalArgumentException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
declare module java {
    export module lang {
        export class Object {
            public wait(): void;
            public wait(param0: number): void;

            public toString(): string;

            public notify(): void;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public clone(): java.lang.Object;

            public wait(param0: number, param1: number): void;

            public finalize(): void;

            public getClass(): java.lang.Class;

            public hashCode(): number;

            public notifyAll(): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class OutOfMemoryError extends java.lang.VirtualMachineError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export class Override extends java.lang.Object implements java.lang.annotation.Annotation {
            /**
             * Constructs a new instance of the java.lang.Override interface with the provided implementation.
             */
            public constructor(implementation: {
                annotationType(): java.lang.Class;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                toString(): string;
            });

            public annotationType(): java.lang.Class;

            public toString(): string;

            public equals(param0: java.lang.Object): boolean;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.annotation.Annotation.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
declare module java {
    export module lang {
        export class Package extends java.lang.Object implements java.lang.reflect.AnnotatedElement {
            public getImplementationVendor(): string;

            public static getPackage(param0: string): java.lang.Package;

            public getImplementationVersion(): string;

            public getDeclaredAnnotations(): native.Array<java.lang.annotation.Annotation>;

            public getSpecificationVersion(): string;

            public isAnnotationPresent(param0: java.lang.Class): boolean;

            public getSpecificationVendor(): string;

            public isSealed(): boolean;

            public toString(): string;

            public getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;

            public getName(): string;

            public isCompatibleWith(param0: string): boolean;

            public getAnnotations(): native.Array<java.lang.annotation.Annotation>;

            public isSealed(param0: java.net.URL): boolean;

            public static getPackages(): native.Array<java.lang.Package>;

            public getImplementationTitle(): string;

            public getSpecificationTitle(): string;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
declare module java {
    export module lang {
        export abstract class Process extends java.lang.Object {
            public getInputStream(): java.io.InputStream;

            public exitValue(): number;

            public destroy(): void;

            public getOutputStream(): java.io.OutputStream;

            public constructor();

            public getErrorStream(): java.io.InputStream;

            public waitFor(): number;
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.lang.Process.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module lang {
        export class ProcessBuilder extends java.lang.Object {
            public command(): java.util.List;

            public constructor(param0: native.Array<string>);

            public command(param0: native.Array<string>): java.lang.ProcessBuilder;

            public directory(): java.io.File;

            public redirectErrorStream(): boolean;

            public constructor(param0: java.util.List);

            public start(): java.lang.Process;

            public command(param0: java.util.List): java.lang.ProcessBuilder;

            public directory(param0: java.io.File): java.lang.ProcessBuilder;

            public environment(): java.util.Map;

            public redirectErrorStream(param0: boolean): java.lang.ProcessBuilder;
        }
    }
}

/// <reference path="./java.nio.CharBuffer.d.ts" />
declare module java {
    export module lang {
        export class Readable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.lang.Readable interface with the provided implementation.
             */
            public constructor(implementation: {
                read(param0: java.nio.CharBuffer): number;
            });

            public read(param0: java.nio.CharBuffer): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ReflectiveOperationException extends java.lang.Exception {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

declare module java {
    export module lang {
        export class Runnable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.lang.Runnable interface with the provided implementation.
             */
            public constructor(implementation: {
                run(): void;
            });

            public run(): void;
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Process.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Thread.d.ts" />
declare module java {
    export module lang {
        export class Runtime extends java.lang.Object {
            public static runFinalizersOnExit(param0: boolean): void;

            public exit(param0: number): void;

            public totalMemory(): number;

            public exec(param0: native.Array<string>): java.lang.Process;

            public loadLibrary(param0: string): void;

            public addShutdownHook(param0: java.lang.Thread): void;

            public traceMethodCalls(param0: boolean): void;

            public availableProcessors(): number;

            public exec(param0: string, param1: native.Array<string>, param2: java.io.File): java.lang.Process;

            public load(param0: string): void;

            public maxMemory(): number;

            public exec(param0: string, param1: native.Array<string>): java.lang.Process;

            public gc(): void;

            public exec(param0: native.Array<string>, param1: native.Array<string>, param2: java.io.File): java.lang.Process;

            public removeShutdownHook(param0: java.lang.Thread): boolean;

            public exec(param0: string): java.lang.Process;

            public freeMemory(): number;

            public exec(param0: native.Array<string>, param1: native.Array<string>): java.lang.Process;

            public static getRuntime(): java.lang.Runtime;

            public traceInstructions(param0: boolean): void;

            public runFinalization(): void;

            public halt(param0: number): void;

            public getLocalizedInputStream(param0: java.io.InputStream): java.io.InputStream;

            public getLocalizedOutputStream(param0: java.io.OutputStream): java.io.OutputStream;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class RuntimeException extends java.lang.Exception {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module lang {
        export class RuntimePermission extends java.security.BasicPermission {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export class SafeVarargs extends java.lang.Object implements java.lang.annotation.Annotation {
            /**
             * Constructs a new instance of the java.lang.SafeVarargs interface with the provided implementation.
             */
            public constructor(implementation: {
                annotationType(): java.lang.Class;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                toString(): string;
            });

            public annotationType(): java.lang.Class;

            public toString(): string;

            public equals(param0: java.lang.Object): boolean;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class SecurityException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.FileDescriptor.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.ClassLoader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Thread.d.ts" />
/// <reference path="./java.lang.ThreadGroup.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module lang {
        export class SecurityManager extends java.lang.Object {
            public inCheck: boolean;

            public checkAccess(param0: java.lang.Thread): void;

            public checkLink(param0: string): void;

            public checkPropertyAccess(param0: string): void;

            public getSecurityContext(): java.lang.Object;

            public checkExec(param0: string): void;

            public getInCheck(): boolean;

            public checkWrite(param0: java.io.FileDescriptor): void;

            public currentLoadedClass(): java.lang.Class;

            public checkPermission(param0: java.security.Permission, param1: java.lang.Object): void;

            public inClassLoader(): boolean;

            public classLoaderDepth(): number;

            public checkRead(param0: string, param1: java.lang.Object): void;

            public checkPackageDefinition(param0: string): void;

            public checkMulticast(param0: java.net.InetAddress): void;

            public checkRead(param0: java.io.FileDescriptor): void;

            public checkExit(param0: number): void;

            public checkRead(param0: string): void;

            public checkMemberAccess(param0: java.lang.Class, param1: number): void;

            public checkPropertiesAccess(): void;

            public checkSystemClipboardAccess(): void;

            public checkCreateClassLoader(): void;

            public checkAccess(param0: java.lang.ThreadGroup): void;

            public checkAwtEventQueueAccess(): void;

            public currentClassLoader(): java.lang.ClassLoader;

            public checkPermission(param0: java.security.Permission): void;

            public checkDelete(param0: string): void;

            public constructor();

            public checkConnect(param0: string, param1: number): void;

            public getClassContext(): native.Array<java.lang.Class>;

            public classDepth(param0: string): number;

            public checkAccept(param0: string, param1: number): void;

            public checkListen(param0: number): void;

            public checkMulticast(param0: java.net.InetAddress, param1: number): void;

            public checkSetFactory(): void;

            public getThreadGroup(): java.lang.ThreadGroup;

            public checkConnect(param0: string, param1: number, param2: java.lang.Object): void;

            public checkPrintJobAccess(): void;

            public checkTopLevelWindow(param0: java.lang.Object): boolean;

            public checkWrite(param0: string): void;

            public inClass(param0: string): boolean;

            public checkSecurityAccess(param0: string): void;

            public checkPackageAccess(param0: string): void;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Short extends java.lang.Number {
            public static MAX_VALUE: number;
            public static MIN_VALUE: number;
            public static SIZE: number;
            public static TYPE: java.lang.Class;

            public static valueOf(param0: string): java.lang.Short;
            public static valueOf(param0: number): java.lang.Short;

            public static parseShort(param0: string, param1: number): number;

            public constructor(param0: number);
            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public shortValue(): number;

            public doubleValue(): number;

            public floatValue(): number;

            public intValue(): number;

            public toString(): string;

            public static reverseBytes(param0: number): number;

            public static compare(param0: number, param1: number): number;

            public byteValue(): number;

            public compareTo(param0: java.lang.Short): number;

            public static decode(param0: string): java.lang.Short;

            public static parseShort(param0: string): number;

            public static valueOf(param0: string, param1: number): java.lang.Short;

            public constructor(param0: string);

            public static toString(param0: number): string;

            public hashCode(): number;

            public longValue(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class StackOverflowError extends java.lang.VirtualMachineError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class StackTraceElement extends java.lang.Object implements java.io.Serializable {
            public isNativeMethod(): boolean;

            public toString(): string;

            public getClassName(): string;

            public getFileName(): string;

            public getLineNumber(): number;

            public constructor(param0: string, param1: string, param2: string, param3: number);

            public equals(param0: java.lang.Object): boolean;

            public getMethodName(): string;

            public hashCode(): number;
        }
    }
}

declare module java {
    export module lang {
        export class StrictMath extends java.lang.Object {
            public static E: number;
            public static PI: number;

            public static getExponent(param0: number): number;

            public static ulp(param0: number): number;

            public static acos(param0: number): number;

            public static sin(param0: number): number;

            public static expm1(param0: number): number;

            public static log1p(param0: number): number;

            public static copySign(param0: number, param1: number): number;

            public static ceil(param0: number): number;

            public static atan2(param0: number, param1: number): number;

            public static signum(param0: number): number;

            public static cosh(param0: number): number;

            public static sqrt(param0: number): number;

            public static nextAfter(param0: number, param1: number): number;

            public static min(param0: number, param1: number): number;

            public static toDegrees(param0: number): number;

            public static random(): number;

            public static asin(param0: number): number;

            public static log10(param0: number): number;

            public static exp(param0: number): number;

            public static log(param0: number): number;

            public static floor(param0: number): number;

            public static round(param0: number): number;

            public static toRadians(param0: number): number;

            public static hypot(param0: number, param1: number): number;

            public static sinh(param0: number): number;

            public static tanh(param0: number): number;

            public static tan(param0: number): number;

            public static cos(param0: number): number;

            public static rint(param0: number): number;

            public static cbrt(param0: number): number;

            public static IEEEremainder(param0: number, param1: number): number;

            public static max(param0: number, param1: number): number;

            public static pow(param0: number, param1: number): number;

            public static scalb(param0: number, param1: number): number;

            public static abs(param0: number): number;

            public static atan(param0: number): number;

            public static nextUp(param0: number): number;
        }
    }
}

/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
/// <reference path="./java.lang.StringBuilder.d.ts" />
/// <reference path="./java.nio.charset.Charset.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module lang {
        export class String extends java.lang.Object implements java.io.Serializable, java.lang.CharSequence {
            public static CASE_INSENSITIVE_ORDER: java.util.Comparator;

            public getBytes(param0: java.nio.charset.Charset): native.Array<number>;
            public getBytes(): native.Array<number>;
            public getBytes(param0: number, param1: number, param2: native.Array<number>, param3: number): void;

            public compareToIgnoreCase(param0: string): number;

            public indexOf(param0: string, param1: number): number;

            public equalsIgnoreCase(param0: string): boolean;

            public static valueOf(param0: string): string;

            public lastIndexOf(param0: string, param1: number): number;

            public startsWith(param0: string): boolean;

            public equals(param0: java.lang.Object): boolean;

            public indexOf(param0: number): number;

            public constructor(param0: java.lang.StringBuilder);

            public codePointCount(param0: number, param1: number): number;

            public replaceAll(param0: string, param1: string): string;

            public subSequence(param0: number, param1: number): string;

            public lastIndexOf(param0: number): number;

            public constructor(param0: native.Array<number>, param1: number, param2: number, param3: number);

            public contains(param0: string): boolean;

            public intern(): string;

            public toUpperCase(): string;

            public trim(): string;

            public constructor(param0: string);

            public static valueOf(param0: java.lang.Object): string;

            public constructor(param0: native.Array<string>, param1: number, param2: number);

            public getBytes(param0: string): native.Array<number>;

            public static format(param0: string, param1: native.Array<java.lang.Object>): string;

            public lastIndexOf(param0: number, param1: number): number;

            public constructor();
            public constructor(param0: native.Array<number>);

            public toUpperCase(param0: java.util.Locale): string;

            public static valueOf(param0: native.Array<string>): string;
            public static valueOf(param0: number): string;

            public endsWith(param0: string): boolean;

            public static valueOf(param0: boolean): string;

            public charAt(param0: number): string;

            public toLowerCase(): string;
            public toLowerCase(param0: java.util.Locale): string;

            public split(param0: string, param1: number): native.Array<string>;

            public lastIndexOf(param0: string): number;

            public matches(param0: string): boolean;

            public regionMatches(param0: boolean, param1: number, param2: string, param3: number, param4: number): boolean;

            public replace(param0: string, param1: string): string;

            public toCharArray(): native.Array<string>;

            public constructor(param0: native.Array<number>, param1: number);

            public substring(param0: number, param1: number): string;

            public codePointAt(param0: number): number;

            public getChars(param0: number, param1: number, param2: native.Array<string>, param3: number): void;

            public constructor(param0: native.Array<string>);

            public codePointBefore(param0: number): number;

            public static copyValueOf(param0: native.Array<string>, param1: number, param2: number): string;

            public contentEquals(param0: java.lang.StringBuffer): boolean;

            public constructor(param0: native.Array<number>, param1: number, param2: number);
            public constructor(param0: native.Array<number>, param1: number, param2: number, param3: string);

            public replaceFirst(param0: string, param1: string): string;

            public constructor(param0: native.Array<number>, param1: java.nio.charset.Charset);
            public constructor(param0: java.lang.StringBuffer);

            public isEmpty(): boolean;

            public constructor(param0: native.Array<number>, param1: string);

            public static copyValueOf(param0: native.Array<string>): string;

            public length(): number;

            public startsWith(param0: string, param1: number): boolean;

            public constructor(param0: native.Array<number>, param1: number, param2: number, param3: java.nio.charset.Charset);

            public regionMatches(param0: number, param1: string, param2: number, param3: number): boolean;

            public indexOf(param0: string): number;
            public indexOf(param0: number, param1: number): number;

            public static format(param0: java.util.Locale, param1: string, param2: native.Array<java.lang.Object>): string;

            public concat(param0: string): string;

            public toString(): string;

            public split(param0: string): native.Array<string>;

            public offsetByCodePoints(param0: number, param1: number): number;

            public contentEquals(param0: string): boolean;

            public substring(param0: number): string;

            public compareTo(param0: string): number;

            public static valueOf(param0: native.Array<string>, param1: number, param2: number): string;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class StringBuffer extends java.lang.AbstractStringBuilder implements java.lang.Appendable, java.io.Serializable, java.lang.CharSequence {
            public append(param0: string): java.lang.StringBuffer;

            public indexOf(param0: string, param1: number): number;

            public insert(param0: number, param1: string, param2: number, param3: number): java.lang.StringBuffer;

            public lastIndexOf(param0: string, param1: number): number;

            public insert(param0: number, param1: string): java.lang.StringBuffer;
            public insert(param0: number, param1: number): java.lang.StringBuffer;

            public substring(param0: number, param1: number): string;

            public replace(param0: number, param1: number, param2: string): java.lang.StringBuffer;

            public ensureCapacity(param0: number): void;

            public append(param0: string, param1: number, param2: number): java.lang.StringBuffer;

            public codePointAt(param0: number): number;

            public codePointCount(param0: number, param1: number): number;

            public delete(param0: number, param1: number): java.lang.StringBuffer;

            public setCharAt(param0: number, param1: string): void;

            public getChars(param0: number, param1: number, param2: native.Array<string>, param3: number): void;

            public codePointBefore(param0: number): number;

            public insert(param0: number, param1: native.Array<string>, param2: number, param3: number): java.lang.StringBuffer;

            public subSequence(param0: number, param1: number): string;

            public append(param0: native.Array<string>): java.lang.StringBuffer;

            public insert(param0: number, param1: java.lang.Object): java.lang.StringBuffer;

            public constructor(param0: string);

            public deleteCharAt(param0: number): java.lang.StringBuffer;

            public setLength(param0: number): void;

            public reverse(): java.lang.StringBuffer;

            public append(param0: java.lang.StringBuffer): java.lang.StringBuffer;
            public append(param0: native.Array<string>, param1: number, param2: number): java.lang.StringBuffer;

            public length(): number;

            public constructor(param0: number);

            public append(param0: java.lang.Object): java.lang.StringBuffer;
            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public indexOf(param0: string): number;

            public insert(param0: number, param1: boolean): java.lang.StringBuffer;

            public append(param0: number): java.lang.StringBuffer;

            public appendCodePoint(param0: number): java.lang.StringBuffer;

            public charAt(param0: number): string;

            public toString(): string;

            public insert(param0: number, param1: native.Array<string>): java.lang.StringBuffer;

            public offsetByCodePoints(param0: number, param1: number): number;

            public trimToSize(): void;

            public substring(param0: number): string;

            public append(param0: string): java.lang.Appendable;
            public append(param0: boolean): java.lang.StringBuffer;

            public lastIndexOf(param0: string): number;
        }
    }
}

/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
declare module java {
    export module lang {
        export class StringBuilder extends java.lang.AbstractStringBuilder implements java.lang.Appendable, java.lang.CharSequence, java.io.Serializable {
            public append(param0: number): java.lang.StringBuilder;

            public insert(param0: number, param1: string): java.lang.StringBuilder;
            public insert(param0: number, param1: java.lang.Object): java.lang.StringBuilder;

            public deleteCharAt(param0: number): java.lang.StringBuilder;

            public replace(param0: number, param1: number, param2: string): java.lang.StringBuilder;

            public subSequence(param0: number, param1: number): string;

            public append(param0: native.Array<string>): java.lang.StringBuilder;
            public append(param0: string): java.lang.StringBuilder;
            public append(param0: native.Array<string>, param1: number, param2: number): java.lang.StringBuilder;

            public constructor(param0: string);

            public insert(param0: number, param1: boolean): java.lang.StringBuilder;

            public appendCodePoint(param0: number): java.lang.StringBuilder;

            public insert(param0: number, param1: string, param2: number, param3: number): java.lang.StringBuilder;
            public insert(param0: number, param1: number): java.lang.StringBuilder;

            public length(): number;

            public constructor(param0: number);

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public constructor();

            public append(param0: java.lang.Object): java.lang.StringBuilder;

            public insert(param0: number, param1: native.Array<string>): java.lang.StringBuilder;

            public charAt(param0: number): string;

            public toString(): string;

            public append(param0: string, param1: number, param2: number): java.lang.StringBuilder;

            public insert(param0: number, param1: native.Array<string>, param2: number, param3: number): java.lang.StringBuilder;

            public append(param0: java.lang.StringBuffer): java.lang.StringBuilder;
            public append(param0: boolean): java.lang.StringBuilder;

            public delete(param0: number, param1: number): java.lang.StringBuilder;

            public reverse(): java.lang.StringBuilder;

            public append(param0: string): java.lang.Appendable;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class StringIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: number);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export class SuppressWarnings extends java.lang.Object implements java.lang.annotation.Annotation {
            /**
             * Constructs a new instance of the java.lang.SuppressWarnings interface with the provided implementation.
             */
            public constructor(implementation: {
                value(): native.Array<string>;
                annotationType(): java.lang.Class;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                toString(): string;
            });

            public annotationType(): java.lang.Class;

            public toString(): string;

            public value(): native.Array<string>;

            public equals(param0: java.lang.Object): boolean;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.io.Console.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.PrintStream.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.SecurityManager.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.channels.Channel.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Properties.d.ts" />
declare module java {
    export module lang {
        export class System extends java.lang.Object {
            public static err: java.io.PrintStream;
            public static in: java.io.InputStream;
            public static out: java.io.PrintStream;

            public static getenv(param0: string): string;

            public static runFinalizersOnExit(param0: boolean): void;

            public static gc(): void;

            public static arraycopy(param0: java.lang.Object, param1: number, param2: java.lang.Object, param3: number, param4: number): void;

            public static getProperty(param0: string, param1: string): string;

            public static getProperties(): java.util.Properties;

            public static setOut(param0: java.io.PrintStream): void;

            public static identityHashCode(param0: java.lang.Object): number;

            public static mapLibraryName(param0: string): string;

            public static setProperty(param0: string, param1: string): string;

            public static runFinalization(): void;

            public static setProperties(param0: java.util.Properties): void;

            public static load(param0: string): void;

            public static setSecurityManager(param0: java.lang.SecurityManager): void;

            public static console(): java.io.Console;

            public static currentTimeMillis(): number;

            public static getProperty(param0: string): string;

            public static setErr(param0: java.io.PrintStream): void;

            public static inheritedChannel(): java.nio.channels.Channel;

            public static setIn(param0: java.io.InputStream): void;

            public static getenv(): java.util.Map;

            public static lineSeparator(): string;

            public static getSecurityManager(): java.lang.SecurityManager;

            public static nanoTime(): number;

            public static exit(param0: number): void;

            public static clearProperty(param0: string): string;

            public static loadLibrary(param0: string): void;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.ClassLoader.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.lang.StackTraceElement.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Thread.d.ts" />
/// <reference path="./java.lang.ThreadGroup.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module lang {
        export class Thread extends java.lang.Object implements java.lang.Runnable {
            public static MAX_PRIORITY: number;
            public static MIN_PRIORITY: number;
            public static NORM_PRIORITY: number;

            public getState(): java.lang.Thread.State;

            public static setDefaultUncaughtExceptionHandler(param0: java.lang.Thread.UncaughtExceptionHandler): void;

            public static enumerate(param0: native.Array<java.lang.Thread>): number;

            public getId(): number;

            public isInterrupted(): boolean;

            public setUncaughtExceptionHandler(param0: java.lang.Thread.UncaughtExceptionHandler): void;

            public stop(): void;

            public start(): void;

            public constructor(param0: string);

            public setContextClassLoader(param0: java.lang.ClassLoader): void;

            public constructor();

            public suspend(): void;

            public static getAllStackTraces(): java.util.Map;

            public getUncaughtExceptionHandler(): java.lang.Thread.UncaughtExceptionHandler;

            public getStackTrace(): native.Array<java.lang.StackTraceElement>;

            public join(param0: number, param1: number): void;

            public constructor(param0: java.lang.ThreadGroup, param1: string);

            public isAlive(): boolean;

            public constructor(param0: java.lang.Runnable);

            public static currentThread(): java.lang.Thread;

            public static sleep(param0: number, param1: number): void;

            public resume(): void;

            public static activeCount(): number;

            public getContextClassLoader(): java.lang.ClassLoader;

            public static holdsLock(param0: java.lang.Object): boolean;

            public countStackFrames(): number;

            public run(): void;

            public constructor(param0: java.lang.ThreadGroup, param1: java.lang.Runnable);

            public isDaemon(): boolean;

            public static sleep(param0: number): void;

            public static dumpStack(): void;

            public interrupt(): void;

            public destroy(): void;

            public join(): void;

            public checkAccess(): void;

            public setDaemon(param0: boolean): void;

            public static getDefaultUncaughtExceptionHandler(): java.lang.Thread.UncaughtExceptionHandler;

            public constructor(param0: java.lang.ThreadGroup, param1: java.lang.Runnable, param2: string);

            public join(param0: number): void;

            public getPriority(): number;

            public toString(): string;

            public constructor(param0: java.lang.Runnable, param1: string);
            public constructor(param0: java.lang.ThreadGroup, param1: java.lang.Runnable, param2: string, param3: number);

            public getName(): string;

            public getThreadGroup(): java.lang.ThreadGroup;

            public setPriority(param0: number): void;

            public static yield(): void;

            public stop(param0: java.lang.Throwable): void;

            public static interrupted(): boolean;

            public setName(param0: string): void;
        }
        export module Thread {
            export class State extends java.lang.Enum {
                public static BLOCKED: java.lang.Thread.State;
                public static NEW: java.lang.Thread.State;
                public static RUNNABLE: java.lang.Thread.State;
                public static TERMINATED: java.lang.Thread.State;
                public static TIMED_WAITING: java.lang.Thread.State;
                public static WAITING: java.lang.Thread.State;

                public static values(): native.Array<java.lang.Thread.State>;

                public static valueOf(param0: string): java.lang.Thread.State;
                public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            }
            export class UncaughtExceptionHandler extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.lang.Thread$UncaughtExceptionHandler interface with the provided implementation.
                 */
                public constructor(implementation: {
                    uncaughtException(param0: java.lang.Thread, param1: java.lang.Throwable): void;
                });

                public uncaughtException(param0: java.lang.Thread, param1: java.lang.Throwable): void;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ThreadDeath extends java.lang.Error {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Thread.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class ThreadGroup extends java.lang.Object implements java.lang.Thread.UncaughtExceptionHandler {
            public isDestroyed(): boolean;

            public uncaughtException(param0: java.lang.Thread, param1: java.lang.Throwable): void;

            public enumerate(param0: native.Array<java.lang.Thread>): number;

            public allowThreadSuspension(param0: boolean): boolean;

            public enumerate(param0: native.Array<java.lang.Thread>, param1: boolean): number;

            public resume(): void;

            public getParent(): java.lang.ThreadGroup;

            public stop(): void;

            public setMaxPriority(param0: number): void;

            public constructor(param0: string);

            public activeGroupCount(): number;

            public isDaemon(): boolean;

            public activeCount(): number;

            public interrupt(): void;

            public destroy(): void;

            public suspend(): void;

            public enumerate(param0: native.Array<java.lang.ThreadGroup>): number;

            public checkAccess(): void;

            public parentOf(param0: java.lang.ThreadGroup): boolean;

            public setDaemon(param0: boolean): void;

            public toString(): string;

            public getName(): string;

            public getMaxPriority(): number;

            public enumerate(param0: native.Array<java.lang.ThreadGroup>, param1: boolean): number;

            public list(): void;

            public constructor(param0: java.lang.ThreadGroup, param1: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export class ThreadLocal extends java.lang.Object {
            public get(): java.lang.Object;

            public set(param0: java.lang.Object): void;

            public constructor();

            public initialValue(): java.lang.Object;

            public remove(): void;
        }
    }
}

/// <reference path="./java.io.PrintStream.d.ts" />
/// <reference path="./java.io.PrintWriter.d.ts" />
/// <reference path="./java.lang.StackTraceElement.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export class Throwable extends java.lang.Object implements java.io.Serializable {
            public initCause(param0: java.lang.Throwable): java.lang.Throwable;

            public constructor(param0: java.lang.Throwable);

            public getCause(): java.lang.Throwable;

            public constructor();

            public setStackTrace(param0: native.Array<java.lang.StackTraceElement>): void;

            public getMessage(): string;

            public printStackTrace(param0: java.io.PrintStream): void;

            public addSuppressed(param0: java.lang.Throwable): void;

            public toString(): string;

            public fillInStackTrace(): java.lang.Throwable;

            public constructor(param0: string, param1: java.lang.Throwable);

            public printStackTrace(): void;

            public getLocalizedMessage(): string;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);

            public getStackTrace(): native.Array<java.lang.StackTraceElement>;

            public getSuppressed(): native.Array<java.lang.Throwable>;

            public constructor(param0: string);

            public printStackTrace(param0: java.io.PrintWriter): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class TypeNotPresentException extends java.lang.RuntimeException {
            public typeName(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class UnknownError extends java.lang.VirtualMachineError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class UnsatisfiedLinkError extends java.lang.LinkageError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class UnsupportedClassVersionError extends java.lang.ClassFormatError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class UnsupportedOperationException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export class VerifyError extends java.lang.LinkageError {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export abstract class VirtualMachineError extends java.lang.Error {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
declare module java {
    export module lang {
        export class Void extends java.lang.Object {
            public static TYPE: java.lang.Class;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class Annotation extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.lang.annotation.Annotation interface with the provided implementation.
                 */
                public constructor(implementation: {
                    annotationType(): java.lang.Class;
                    equals(param0: java.lang.Object): boolean;
                    hashCode(): number;
                    toString(): string;
                });

                public annotationType(): java.lang.Class;

                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class AnnotationFormatError extends java.lang.Error {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.lang.reflect.Method.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class AnnotationTypeMismatchException extends java.lang.RuntimeException {
                public constructor(param0: java.lang.reflect.Method, param1: string);

                public element(): java.lang.reflect.Method;

                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);

                public foundType(): string;

                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class Documented extends java.lang.Object implements java.lang.annotation.Annotation {
                /**
                 * Constructs a new instance of the java.lang.annotation.Documented interface with the provided implementation.
                 */
                public constructor(implementation: {
                    annotationType(): java.lang.Class;
                    equals(param0: java.lang.Object): boolean;
                    hashCode(): number;
                    toString(): string;
                });

                public annotationType(): java.lang.Class;

                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class ElementType extends java.lang.Enum {
                public static ANNOTATION_TYPE: java.lang.annotation.ElementType;
                public static CONSTRUCTOR: java.lang.annotation.ElementType;
                public static FIELD: java.lang.annotation.ElementType;
                public static LOCAL_VARIABLE: java.lang.annotation.ElementType;
                public static METHOD: java.lang.annotation.ElementType;
                public static PACKAGE: java.lang.annotation.ElementType;
                public static PARAMETER: java.lang.annotation.ElementType;
                public static TYPE: java.lang.annotation.ElementType;

                public static values(): native.Array<java.lang.annotation.ElementType>;

                public static valueOf(param0: string): java.lang.annotation.ElementType;
                public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class IncompleteAnnotationException extends java.lang.RuntimeException {
                public constructor(param0: java.lang.Class, param1: string);

                public annotationType(): java.lang.Class;

                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);

                public elementName(): string;

                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class Inherited extends java.lang.Object implements java.lang.annotation.Annotation {
                /**
                 * Constructs a new instance of the java.lang.annotation.Inherited interface with the provided implementation.
                 */
                public constructor(implementation: {
                    annotationType(): java.lang.Class;
                    equals(param0: java.lang.Object): boolean;
                    hashCode(): number;
                    toString(): string;
                });

                public annotationType(): java.lang.Class;

                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.annotation.RetentionPolicy.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class Retention extends java.lang.Object implements java.lang.annotation.Annotation {
                /**
                 * Constructs a new instance of the java.lang.annotation.Retention interface with the provided implementation.
                 */
                public constructor(implementation: {
                    value(): java.lang.annotation.RetentionPolicy;
                    annotationType(): java.lang.Class;
                    equals(param0: java.lang.Object): boolean;
                    hashCode(): number;
                    toString(): string;
                });

                public annotationType(): java.lang.Class;

                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public value(): java.lang.annotation.RetentionPolicy;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class RetentionPolicy extends java.lang.Enum {
                public static CLASS: java.lang.annotation.RetentionPolicy;
                public static RUNTIME: java.lang.annotation.RetentionPolicy;
                public static SOURCE: java.lang.annotation.RetentionPolicy;

                public static valueOf(param0: string): java.lang.annotation.RetentionPolicy;

                public static values(): native.Array<java.lang.annotation.RetentionPolicy>;

                public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.annotation.ElementType.d.ts" />
declare module java {
    export module lang {
        export module annotation {
            export class Target extends java.lang.Object implements java.lang.annotation.Annotation {
                /**
                 * Constructs a new instance of the java.lang.annotation.Target interface with the provided implementation.
                 */
                public constructor(implementation: {
                    value(): native.Array<java.lang.annotation.ElementType>;
                    annotationType(): java.lang.Class;
                    equals(param0: java.lang.Object): boolean;
                    hashCode(): number;
                    toString(): string;
                });

                public annotationType(): java.lang.Class;

                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public value(): native.Array<java.lang.annotation.ElementType>;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.ref.ReferenceQueue.d.ts" />
declare module java {
    export module lang {
        export module ref {
            export class PhantomReference extends java.lang.ref.Reference {
                public constructor(param0: java.lang.Object, param1: java.lang.ref.ReferenceQueue);

                public get(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export module ref {
            export abstract class Reference extends java.lang.Object {
                public enqueue(): boolean;

                public clear(): void;

                public isEnqueued(): boolean;

                public get(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.ref.Reference.d.ts" />
declare module java {
    export module lang {
        export module ref {
            export class ReferenceQueue extends java.lang.Object {
                public remove(): java.lang.ref.Reference;
                public remove(param0: number): java.lang.ref.Reference;

                public poll(): java.lang.ref.Reference;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.ref.ReferenceQueue.d.ts" />
declare module java {
    export module lang {
        export module ref {
            export class SoftReference extends java.lang.ref.Reference {
                public constructor(param0: java.lang.Object, param1: java.lang.ref.ReferenceQueue);
                public constructor(param0: java.lang.Object);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.ref.ReferenceQueue.d.ts" />
declare module java {
    export module lang {
        export module ref {
            export class WeakReference extends java.lang.ref.Reference {
                public constructor(param0: java.lang.Object, param1: java.lang.ref.ReferenceQueue);
                public constructor(param0: java.lang.Object);
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.annotation.Annotation.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class AccessibleObject extends java.lang.Object implements java.lang.reflect.AnnotatedElement {
                public getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;

                public getDeclaredAnnotations(): native.Array<java.lang.annotation.Annotation>;

                public isAccessible(): boolean;

                public isAnnotationPresent(param0: java.lang.Class): boolean;

                public static setAccessible(param0: native.Array<java.lang.reflect.AccessibleObject>, param1: boolean): void;
                public setAccessible(param0: boolean): void;

                public getAnnotations(): native.Array<java.lang.annotation.Annotation>;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.annotation.Annotation.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class AnnotatedElement extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.lang.reflect.AnnotatedElement interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;
                    getAnnotations(): native.Array<java.lang.annotation.Annotation>;
                    getDeclaredAnnotations(): native.Array<java.lang.annotation.Annotation>;
                    isAnnotationPresent(param0: java.lang.Class): boolean;
                });

                public getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;

                public getDeclaredAnnotations(): native.Array<java.lang.annotation.Annotation>;

                public isAnnotationPresent(param0: java.lang.Class): boolean;

                public getAnnotations(): native.Array<java.lang.annotation.Annotation>;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class Array extends java.lang.Object {
                public static getLong(param0: java.lang.Object, param1: number): number;

                public static setLong(param0: java.lang.Object, param1: number, param2: number): void;

                public static setInt(param0: java.lang.Object, param1: number, param2: number): void;

                public static newInstance(param0: java.lang.Class, param1: number): java.lang.Object;

                public static getBoolean(param0: java.lang.Object, param1: number): boolean;

                public static getByte(param0: java.lang.Object, param1: number): number;

                public static setChar(param0: java.lang.Object, param1: number, param2: string): void;

                public static getFloat(param0: java.lang.Object, param1: number): number;

                public static set(param0: java.lang.Object, param1: number, param2: java.lang.Object): void;

                public static getInt(param0: java.lang.Object, param1: number): number;

                public static getShort(param0: java.lang.Object, param1: number): number;

                public static getLength(param0: java.lang.Object): number;

                public static setBoolean(param0: java.lang.Object, param1: number, param2: boolean): void;

                public static setDouble(param0: java.lang.Object, param1: number, param2: number): void;

                public static getChar(param0: java.lang.Object, param1: number): string;

                public static setByte(param0: java.lang.Object, param1: number, param2: number): void;

                public static getDouble(param0: java.lang.Object, param1: number): number;

                public static setShort(param0: java.lang.Object, param1: number, param2: number): void;

                public static get(param0: java.lang.Object, param1: number): java.lang.Object;

                public static newInstance(param0: java.lang.Class, param1: native.Array<number>): java.lang.Object;

                public static setFloat(param0: java.lang.Object, param1: number, param2: number): void;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.annotation.Annotation.d.ts" />
/// <reference path="./java.lang.reflect.AccessibleObject.d.ts" />
/// <reference path="./java.lang.reflect.Type.d.ts" />
/// <reference path="./java.lang.reflect.TypeVariable.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class Constructor extends java.lang.reflect.AccessibleObject implements java.lang.reflect.GenericDeclaration, java.lang.reflect.Member {
                public getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;

                public getParameterTypes(): native.Array<java.lang.Class>;

                public equals(param0: java.lang.Object): boolean;

                public getDeclaredAnnotations(): native.Array<java.lang.annotation.Annotation>;

                public getParameterAnnotations(): native.Array<native.Array<java.lang.annotation.Annotation>>;

                public getExceptionTypes(): native.Array<java.lang.Class>;

                public getModifiers(): number;

                public getName(): string;

                public setAccessible(param0: boolean): void;

                public toString(): string;

                public isSynthetic(): boolean;

                public getGenericParameterTypes(): native.Array<java.lang.reflect.Type>;

                public isVarArgs(): boolean;

                public getGenericExceptionTypes(): native.Array<java.lang.reflect.Type>;

                public hashCode(): number;

                public isAnnotationPresent(param0: java.lang.Class): boolean;

                public static setAccessible(param0: native.Array<java.lang.reflect.AccessibleObject>, param1: boolean): void;

                public getDeclaringClass(): java.lang.Class;

                public getTypeParameters(): native.Array<java.lang.reflect.TypeVariable>;

                public getAnnotations(): native.Array<java.lang.annotation.Annotation>;

                public toGenericString(): string;

                public newInstance(param0: native.Array<java.lang.Object>): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.annotation.Annotation.d.ts" />
/// <reference path="./java.lang.reflect.Type.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class Field extends java.lang.reflect.AccessibleObject implements java.lang.reflect.Member {
                public equals(param0: java.lang.Object): boolean;

                public setBoolean(param0: java.lang.Object, param1: boolean): void;

                public setLong(param0: java.lang.Object, param1: number): void;

                public getModifiers(): number;

                public setChar(param0: java.lang.Object, param1: string): void;

                public isSynthetic(): boolean;

                public getByte(param0: java.lang.Object): number;

                public getChar(param0: java.lang.Object): string;

                public get(param0: java.lang.Object): java.lang.Object;

                public getInt(param0: java.lang.Object): number;

                public hashCode(): number;

                public isAnnotationPresent(param0: java.lang.Class): boolean;

                public setShort(param0: java.lang.Object, param1: number): void;

                public getAnnotations(): native.Array<java.lang.annotation.Annotation>;

                public toGenericString(): string;

                public getLong(param0: java.lang.Object): number;

                public setFloat(param0: java.lang.Object, param1: number): void;

                public setInt(param0: java.lang.Object, param1: number): void;

                public getGenericType(): java.lang.reflect.Type;

                public getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;

                public set(param0: java.lang.Object, param1: java.lang.Object): void;

                public setByte(param0: java.lang.Object, param1: number): void;

                public getDeclaredAnnotations(): native.Array<java.lang.annotation.Annotation>;

                public setDouble(param0: java.lang.Object, param1: number): void;

                public getName(): string;

                public toString(): string;

                public getShort(param0: java.lang.Object): number;

                public isEnumConstant(): boolean;

                public getDouble(param0: java.lang.Object): number;

                public getDeclaringClass(): java.lang.Class;

                public getFloat(param0: java.lang.Object): number;

                public getType(): java.lang.Class;

                public getBoolean(param0: java.lang.Object): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.reflect.Type.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class GenericArrayType extends java.lang.Object implements java.lang.reflect.Type {
                /**
                 * Constructs a new instance of the java.lang.reflect.GenericArrayType interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getGenericComponentType(): java.lang.reflect.Type;
                });

                public getGenericComponentType(): java.lang.reflect.Type;
            }
        }
    }
}

/// <reference path="./java.lang.reflect.TypeVariable.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class GenericDeclaration extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.lang.reflect.GenericDeclaration interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getTypeParameters(): native.Array<java.lang.reflect.TypeVariable>;
                });

                public getTypeParameters(): native.Array<java.lang.reflect.TypeVariable>;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class GenericSignatureFormatError extends java.lang.ClassFormatError {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.reflect.Method.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class InvocationHandler extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.lang.reflect.InvocationHandler interface with the provided implementation.
                 */
                public constructor(implementation: {
                    invoke(param0: java.lang.Object, param1: java.lang.reflect.Method, param2: native.Array<java.lang.Object>): java.lang.Object;
                });

                public invoke(param0: java.lang.Object, param1: java.lang.reflect.Method, param2: native.Array<java.lang.Object>): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class InvocationTargetException extends java.lang.ReflectiveOperationException {
                public constructor(param0: java.lang.Throwable, param1: string);
                public constructor(param0: string, param1: java.lang.Throwable);

                public getTargetException(): java.lang.Throwable;

                public getCause(): java.lang.Throwable;

                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class MalformedParameterizedTypeException extends java.lang.RuntimeException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class Member extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.lang.reflect.Member interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getDeclaringClass(): java.lang.Class;
                    getModifiers(): number;
                    getName(): string;
                    isSynthetic(): boolean;
                });

                public static PUBLIC: number;
                public static DECLARED: number;

                public getModifiers(): number;

                public getDeclaringClass(): java.lang.Class;

                public getName(): string;

                public isSynthetic(): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.annotation.Annotation.d.ts" />
/// <reference path="./java.lang.reflect.Type.d.ts" />
/// <reference path="./java.lang.reflect.TypeVariable.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class Method extends java.lang.reflect.AccessibleObject implements java.lang.reflect.GenericDeclaration, java.lang.reflect.Member {
                public getAnnotation(param0: java.lang.Class): java.lang.annotation.Annotation;

                public getParameterTypes(): native.Array<java.lang.Class>;

                public equals(param0: java.lang.Object): boolean;

                public getDeclaredAnnotations(): native.Array<java.lang.annotation.Annotation>;

                public getParameterAnnotations(): native.Array<native.Array<java.lang.annotation.Annotation>>;

                public getExceptionTypes(): native.Array<java.lang.Class>;

                public getModifiers(): number;

                public getName(): string;

                public getDefaultValue(): java.lang.Object;

                public toString(): string;

                public isSynthetic(): boolean;

                public getGenericParameterTypes(): native.Array<java.lang.reflect.Type>;

                public isVarArgs(): boolean;

                public invoke(param0: java.lang.Object, param1: native.Array<java.lang.Object>): java.lang.Object;

                public getGenericExceptionTypes(): native.Array<java.lang.reflect.Type>;

                public isBridge(): boolean;

                public getReturnType(): java.lang.Class;

                public hashCode(): number;

                public isAnnotationPresent(param0: java.lang.Class): boolean;

                public getDeclaringClass(): java.lang.Class;

                public getTypeParameters(): native.Array<java.lang.reflect.TypeVariable>;

                public getAnnotations(): native.Array<java.lang.annotation.Annotation>;

                public toGenericString(): string;

                public getGenericReturnType(): java.lang.reflect.Type;
            }
        }
    }
}

declare module java {
    export module lang {
        export module reflect {
            export class Modifier extends java.lang.Object {
                public static ABSTRACT: number;
                public static FINAL: number;
                public static INTERFACE: number;
                public static NATIVE: number;
                public static PRIVATE: number;
                public static PROTECTED: number;
                public static PUBLIC: number;
                public static STATIC: number;
                public static STRICT: number;
                public static SYNCHRONIZED: number;
                public static TRANSIENT: number;
                public static VOLATILE: number;

                public static constructorModifiers(): number;

                public static isSynchronized(param0: number): boolean;

                public static isPublic(param0: number): boolean;

                public static isStrict(param0: number): boolean;

                public static methodModifiers(): number;

                public static isProtected(param0: number): boolean;

                public toString(): string;

                public constructor();

                public static isFinal(param0: number): boolean;

                public static isInterface(param0: number): boolean;

                public static toString(param0: number): string;

                public static classModifiers(): number;

                public static isNative(param0: number): boolean;

                public static isStatic(param0: number): boolean;

                public static isVolatile(param0: number): boolean;

                public static isAbstract(param0: number): boolean;

                public static isPrivate(param0: number): boolean;

                public static interfaceModifiers(): number;

                public static isTransient(param0: number): boolean;

                public static fieldModifiers(): number;
            }
        }
    }
}

/// <reference path="./java.lang.reflect.Type.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class ParameterizedType extends java.lang.Object implements java.lang.reflect.Type {
                /**
                 * Constructs a new instance of the java.lang.reflect.ParameterizedType interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getActualTypeArguments(): native.Array<java.lang.reflect.Type>;
                    getOwnerType(): java.lang.reflect.Type;
                    getRawType(): java.lang.reflect.Type;
                });

                public getOwnerType(): java.lang.reflect.Type;

                public getRawType(): java.lang.reflect.Type;

                public getActualTypeArguments(): native.Array<java.lang.reflect.Type>;
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.ClassLoader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.reflect.InvocationHandler.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class Proxy extends java.lang.Object implements java.io.Serializable {
                public h: java.lang.reflect.InvocationHandler;

                public static isProxyClass(param0: java.lang.Class): boolean;

                public static getInvocationHandler(param0: java.lang.Object): java.lang.reflect.InvocationHandler;

                public constructor(param0: java.lang.reflect.InvocationHandler);

                public static newProxyInstance(param0: java.lang.ClassLoader, param1: native.Array<java.lang.Class>, param2: java.lang.reflect.InvocationHandler): java.lang.Object;

                public static getProxyClass(param0: java.lang.ClassLoader, param1: native.Array<java.lang.Class>): java.lang.Class;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class ReflectPermission extends java.security.BasicPermission {
                public implies(param0: java.security.Permission): boolean;

                public getActions(): string;

                public checkGuard(param0: java.lang.Object): void;

                public constructor(param0: string, param1: string);
                public constructor(param0: string);
            }
        }
    }
}

declare module java {
    export module lang {
        export module reflect {
            export class Type extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.lang.reflect.Type interface with the provided implementation.
                 */
                public constructor(implementation: {});
            }
        }
    }
}

/// <reference path="./java.lang.reflect.GenericDeclaration.d.ts" />
/// <reference path="./java.lang.reflect.Type.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class TypeVariable extends java.lang.Object implements java.lang.reflect.Type {
                /**
                 * Constructs a new instance of the java.lang.reflect.TypeVariable interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getBounds(): native.Array<java.lang.reflect.Type>;
                    getGenericDeclaration(): java.lang.reflect.GenericDeclaration;
                    getName(): string;
                });

                public getBounds(): native.Array<java.lang.reflect.Type>;

                public getGenericDeclaration(): java.lang.reflect.GenericDeclaration;

                public getName(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class UndeclaredThrowableException extends java.lang.RuntimeException {
                public getUndeclaredThrowable(): java.lang.Throwable;

                public constructor(param0: java.lang.Throwable, param1: string);
                public constructor(param0: string, param1: java.lang.Throwable);

                public getCause(): java.lang.Throwable;

                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.reflect.Type.d.ts" />
declare module java {
    export module lang {
        export module reflect {
            export class WildcardType extends java.lang.Object implements java.lang.reflect.Type {
                /**
                 * Constructs a new instance of the java.lang.reflect.WildcardType interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getUpperBounds(): native.Array<java.lang.reflect.Type>;
                    getLowerBounds(): native.Array<java.lang.reflect.Type>;
                });

                public getLowerBounds(): native.Array<java.lang.reflect.Type>;

                public getUpperBounds(): native.Array<java.lang.reflect.Type>;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.math.MathContext.d.ts" />
/// <reference path="./java.math.RoundingMode.d.ts" />
declare module java {
    export module math {
        export class BigDecimal extends java.lang.Number implements java.io.Serializable {
            public static ONE: java.math.BigDecimal;
            public static ROUND_CEILING: number;
            public static ROUND_DOWN: number;
            public static ROUND_FLOOR: number;
            public static ROUND_HALF_DOWN: number;
            public static ROUND_HALF_EVEN: number;
            public static ROUND_HALF_UP: number;
            public static ROUND_UNNECESSARY: number;
            public static ROUND_UP: number;
            public static TEN: java.math.BigDecimal;
            public static ZERO: java.math.BigDecimal;

            public divide(param0: java.math.BigDecimal): java.math.BigDecimal;

            public pow(param0: number): java.math.BigDecimal;

            public divideToIntegralValue(param0: java.math.BigDecimal): java.math.BigDecimal;

            public equals(param0: java.lang.Object): boolean;

            public max(param0: java.math.BigDecimal): java.math.BigDecimal;

            public scaleByPowerOfTen(param0: number): java.math.BigDecimal;

            public shortValueExact(): number;

            public divide(param0: java.math.BigDecimal, param1: java.math.MathContext): java.math.BigDecimal;

            public remainder(param0: java.math.BigDecimal): java.math.BigDecimal;

            public divideAndRemainder(param0: java.math.BigDecimal): native.Array<java.math.BigDecimal>;

            public toPlainString(): string;

            public multiply(param0: java.math.BigDecimal): java.math.BigDecimal;

            public constructor(param0: string);
            public constructor(param0: native.Array<string>, param1: java.math.MathContext);
            public constructor(param0: native.Array<string>, param1: number, param2: number);

            public subtract(param0: java.math.BigDecimal): java.math.BigDecimal;

            public byteValueExact(): number;

            public constructor(param0: number);

            public divide(param0: java.math.BigDecimal, param1: java.math.RoundingMode): java.math.BigDecimal;

            public constructor();
            public constructor(param0: java.math.BigInteger, param1: java.math.MathContext);

            public divideToIntegralValue(param0: java.math.BigDecimal, param1: java.math.MathContext): java.math.BigDecimal;

            public setScale(param0: number): java.math.BigDecimal;

            public pow(param0: number, param1: java.math.MathContext): java.math.BigDecimal;

            public toBigIntegerExact(): java.math.BigInteger;

            public constructor(param0: string, param1: java.math.MathContext);

            public floatValue(): number;

            public intValue(): number;

            public ulp(): java.math.BigDecimal;

            public abs(param0: java.math.MathContext): java.math.BigDecimal;

            public negate(param0: java.math.MathContext): java.math.BigDecimal;

            public unscaledValue(): java.math.BigInteger;

            public setScale(param0: number, param1: java.math.RoundingMode): java.math.BigDecimal;
            public setScale(param0: number, param1: number): java.math.BigDecimal;

            public abs(): java.math.BigDecimal;

            public plus(param0: java.math.MathContext): java.math.BigDecimal;

            public longValue(): number;

            public plus(): java.math.BigDecimal;

            public min(param0: java.math.BigDecimal): java.math.BigDecimal;

            public compareTo(param0: java.math.BigDecimal): number;

            public constructor(param0: java.math.BigInteger, param1: number);

            public intValueExact(): number;

            public constructor(param0: java.math.BigInteger);
            public constructor(param0: java.math.BigInteger, param1: number, param2: java.math.MathContext);

            public stripTrailingZeros(): java.math.BigDecimal;

            public longValueExact(): number;

            public scale(): number;

            public doubleValue(): number;

            public constructor(param0: native.Array<string>, param1: number, param2: number, param3: java.math.MathContext);

            public subtract(param0: java.math.BigDecimal, param1: java.math.MathContext): java.math.BigDecimal;

            public constructor(param0: native.Array<string>);

            public toEngineeringString(): string;

            public remainder(param0: java.math.BigDecimal, param1: java.math.MathContext): java.math.BigDecimal;

            public toBigInteger(): java.math.BigInteger;

            public negate(): java.math.BigDecimal;

            public signum(): number;

            public static valueOf(param0: number): java.math.BigDecimal;

            public round(param0: java.math.MathContext): java.math.BigDecimal;

            public divide(param0: java.math.BigDecimal, param1: number): java.math.BigDecimal;
            public divide(param0: java.math.BigDecimal, param1: number, param2: number): java.math.BigDecimal;

            public static valueOf(param0: number, param1: number): java.math.BigDecimal;

            public add(param0: java.math.BigDecimal, param1: java.math.MathContext): java.math.BigDecimal;

            public multiply(param0: java.math.BigDecimal, param1: java.math.MathContext): java.math.BigDecimal;

            public divide(param0: java.math.BigDecimal, param1: number, param2: java.math.RoundingMode): java.math.BigDecimal;

            public toString(): string;

            public precision(): number;

            public movePointRight(param0: number): java.math.BigDecimal;

            public add(param0: java.math.BigDecimal): java.math.BigDecimal;

            public divideAndRemainder(param0: java.math.BigDecimal, param1: java.math.MathContext): native.Array<java.math.BigDecimal>;

            public movePointLeft(param0: number): java.math.BigDecimal;

            public constructor(param0: number, param1: java.math.MathContext);

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Random.d.ts" />
declare module java {
    export module math {
        export class BigInteger extends java.lang.Number implements java.io.Serializable {
            public static ONE: java.math.BigInteger;
            public static TEN: java.math.BigInteger;
            public static ZERO: java.math.BigInteger;

            public remainder(param0: java.math.BigInteger): java.math.BigInteger;

            public isProbablePrime(param0: number): boolean;

            public constructor(param0: number, param1: native.Array<number>);

            public multiply(param0: java.math.BigInteger): java.math.BigInteger;

            public equals(param0: java.lang.Object): boolean;

            public divideAndRemainder(param0: java.math.BigInteger): native.Array<java.math.BigInteger>;

            public testBit(param0: number): boolean;

            public divide(param0: java.math.BigInteger): java.math.BigInteger;

            public constructor(param0: string, param1: number);
            public constructor(param0: string);

            public pow(param0: number): java.math.BigInteger;

            public toByteArray(): native.Array<number>;

            public nextProbablePrime(): java.math.BigInteger;

            public bitCount(): number;

            public constructor(param0: number, param1: java.util.Random);

            public andNot(param0: java.math.BigInteger): java.math.BigInteger;

            public constructor();
            public constructor(param0: native.Array<number>);

            public add(param0: java.math.BigInteger): java.math.BigInteger;

            public floatValue(): number;

            public intValue(): number;

            public xor(param0: java.math.BigInteger): java.math.BigInteger;

            public toString(param0: number): string;

            public shiftLeft(param0: number): java.math.BigInteger;

            public flipBit(param0: number): java.math.BigInteger;

            public constructor(param0: number, param1: number, param2: java.util.Random);

            public longValue(): number;

            public mod(param0: java.math.BigInteger): java.math.BigInteger;

            public setBit(param0: number): java.math.BigInteger;

            public abs(): java.math.BigInteger;

            public clearBit(param0: number): java.math.BigInteger;

            public getLowestSetBit(): number;

            public doubleValue(): number;

            public gcd(param0: java.math.BigInteger): java.math.BigInteger;

            public modInverse(param0: java.math.BigInteger): java.math.BigInteger;

            public compareTo(param0: java.math.BigInteger): number;

            public bitLength(): number;

            public min(param0: java.math.BigInteger): java.math.BigInteger;

            public signum(): number;

            public not(): java.math.BigInteger;

            public static valueOf(param0: number): java.math.BigInteger;

            public max(param0: java.math.BigInteger): java.math.BigInteger;

            public negate(): java.math.BigInteger;

            public toString(): string;

            public or(param0: java.math.BigInteger): java.math.BigInteger;

            public shiftRight(param0: number): java.math.BigInteger;

            public subtract(param0: java.math.BigInteger): java.math.BigInteger;

            public and(param0: java.math.BigInteger): java.math.BigInteger;

            public static probablePrime(param0: number, param1: java.util.Random): java.math.BigInteger;

            public hashCode(): number;

            public modPow(param0: java.math.BigInteger, param1: java.math.BigInteger): java.math.BigInteger;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.RoundingMode.d.ts" />
declare module java {
    export module math {
        export class MathContext extends java.lang.Object implements java.io.Serializable {
            public static DECIMAL128: java.math.MathContext;
            public static DECIMAL32: java.math.MathContext;
            public static DECIMAL64: java.math.MathContext;
            public static UNLIMITED: java.math.MathContext;

            public toString(): string;

            public getPrecision(): number;

            public constructor(param0: number);
            public constructor(param0: number, param1: java.math.RoundingMode);

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: string);

            public getRoundingMode(): java.math.RoundingMode;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module math {
        export class RoundingMode extends java.lang.Enum {
            public static CEILING: java.math.RoundingMode;
            public static DOWN: java.math.RoundingMode;
            public static FLOOR: java.math.RoundingMode;
            public static HALF_DOWN: java.math.RoundingMode;
            public static HALF_EVEN: java.math.RoundingMode;
            public static HALF_UP: java.math.RoundingMode;
            public static UNNECESSARY: java.math.RoundingMode;
            public static UP: java.math.RoundingMode;

            public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            public static valueOf(param0: number): java.math.RoundingMode;

            public static values(): native.Array<java.math.RoundingMode>;

            public static valueOf(param0: string): java.math.RoundingMode;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.PasswordAuthentication.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
declare module java {
    export module net {
        export abstract class Authenticator extends java.lang.Object {
            public static requestPasswordAuthentication(param0: java.net.InetAddress, param1: number, param2: string, param3: string, param4: string): java.net.PasswordAuthentication;

            public getRequestingPrompt(): string;

            public getRequestingURL(): java.net.URL;

            public constructor();

            public static requestPasswordAuthentication(param0: string, param1: java.net.InetAddress, param2: number, param3: string, param4: string, param5: string, param6: java.net.URL, param7: java.net.Authenticator.RequestorType): java.net.PasswordAuthentication;

            public getRequestingHost(): string;

            public static setDefault(param0: java.net.Authenticator): void;

            public getPasswordAuthentication(): java.net.PasswordAuthentication;

            public getRequestingPort(): number;

            public getRequestingSite(): java.net.InetAddress;

            public getRequestingScheme(): string;

            public getRequestingProtocol(): string;

            public static requestPasswordAuthentication(param0: string, param1: java.net.InetAddress, param2: number, param3: string, param4: string, param5: string): java.net.PasswordAuthentication;

            public getRequestorType(): java.net.Authenticator.RequestorType;
        }
        export module Authenticator {
            export class RequestorType extends java.lang.Enum {
                public static PROXY: java.net.Authenticator.RequestorType;
                public static SERVER: java.net.Authenticator.RequestorType;

                public static valueOf(param0: string): java.net.Authenticator.RequestorType;

                public static values(): native.Array<java.net.Authenticator.RequestorType>;

                public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class BindException extends java.net.SocketException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
declare module java {
    export module net {
        export abstract class CacheRequest extends java.lang.Object {
            public abort(): void;

            public constructor();

            public getBody(): java.io.OutputStream;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module net {
        export abstract class CacheResponse extends java.lang.Object {
            public getBody(): java.io.InputStream;

            public getHeaders(): java.util.Map;

            public constructor();
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class ConnectException extends java.net.SocketException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.net.URLConnection.d.ts" />
declare module java {
    export module net {
        export abstract class ContentHandler extends java.lang.Object {
            public getContent(param0: java.net.URLConnection): java.lang.Object;
            public getContent(param0: java.net.URLConnection, param1: native.Array<java.lang.Class>): java.lang.Object;

            public constructor();
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.ContentHandler.d.ts" />
declare module java {
    export module net {
        export class ContentHandlerFactory extends java.lang.Object {
            /**
             * Constructs a new instance of the java.net.ContentHandlerFactory interface with the provided implementation.
             */
            public constructor(implementation: {
                createContentHandler(param0: string): java.net.ContentHandler;
            });

            public createContentHandler(param0: string): java.net.ContentHandler;
        }
    }
}

/// <reference path="./java.net.URI.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module net {
        export abstract class CookieHandler extends java.lang.Object {
            public put(param0: java.net.URI, param1: java.util.Map): void;

            public get(param0: java.net.URI, param1: java.util.Map): java.util.Map;

            public static setDefault(param0: java.net.CookieHandler): void;

            public constructor();

            public static getDefault(): java.net.CookieHandler;
        }
    }
}

/// <reference path="./java.net.CookiePolicy.d.ts" />
/// <reference path="./java.net.CookieStore.d.ts" />
/// <reference path="./java.net.URI.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module net {
        export class CookieManager extends java.net.CookieHandler {
            public put(param0: java.net.URI, param1: java.util.Map): void;

            public constructor(param0: java.net.CookieStore, param1: java.net.CookiePolicy);

            public get(param0: java.net.URI, param1: java.util.Map): java.util.Map;

            public getCookieStore(): java.net.CookieStore;

            public constructor();

            public setCookiePolicy(param0: java.net.CookiePolicy): void;
        }
    }
}

/// <reference path="./java.net.HttpCookie.d.ts" />
/// <reference path="./java.net.URI.d.ts" />
declare module java {
    export module net {
        export class CookiePolicy extends java.lang.Object {
            /**
             * Constructs a new instance of the java.net.CookiePolicy interface with the provided implementation.
             */
            public constructor(implementation: {
                shouldAccept(param0: java.net.URI, param1: java.net.HttpCookie): boolean;
                <clinit>(): void;
            });

            public static ACCEPT_NONE: java.net.CookiePolicy;
            public static ACCEPT_ALL: java.net.CookiePolicy;
            public static ACCEPT_ORIGINAL_SERVER: java.net.CookiePolicy;

            public shouldAccept(param0: java.net.URI, param1: java.net.HttpCookie): boolean;
        }
    }
}

/// <reference path="./java.net.HttpCookie.d.ts" />
/// <reference path="./java.net.URI.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module net {
        export class CookieStore extends java.lang.Object {
            /**
             * Constructs a new instance of the java.net.CookieStore interface with the provided implementation.
             */
            public constructor(implementation: {
                add(param0: java.net.URI, param1: java.net.HttpCookie): void;
                get(param0: java.net.URI): java.util.List;
                getCookies(): java.util.List;
                getURIs(): java.util.List;
                remove(param0: java.net.URI, param1: java.net.HttpCookie): boolean;
                removeAll(): boolean;
            });

            public get(param0: java.net.URI): java.util.List;

            public removeAll(): boolean;

            public getCookies(): java.util.List;

            public remove(param0: java.net.URI, param1: java.net.HttpCookie): boolean;

            public add(param0: java.net.URI, param1: java.net.HttpCookie): void;

            public getURIs(): java.util.List;
        }
    }
}

/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
declare module java {
    export module net {
        export class DatagramPacket extends java.lang.Object {
            public setLength(param0: number): void;

            public setData(param0: native.Array<number>, param1: number, param2: number): void;

            public getLength(): number;

            public setAddress(param0: java.net.InetAddress): void;

            public constructor(param0: native.Array<number>, param1: number, param2: java.net.InetAddress, param3: number);

            public getSocketAddress(): java.net.SocketAddress;

            public getOffset(): number;

            public constructor(param0: native.Array<number>, param1: number, param2: number, param3: java.net.InetAddress, param4: number);
            public constructor(param0: native.Array<number>, param1: number, param2: number, param3: java.net.SocketAddress);
            public constructor(param0: native.Array<number>, param1: number);

            public getAddress(): java.net.InetAddress;

            public constructor(param0: native.Array<number>, param1: number, param2: java.net.SocketAddress);

            public getData(): native.Array<number>;

            public getPort(): number;

            public constructor(param0: native.Array<number>, param1: number, param2: number);

            public setSocketAddress(param0: java.net.SocketAddress): void;

            public setData(param0: native.Array<number>): void;

            public setPort(param0: number): void;
        }
    }
}

/// <reference path="./java.net.DatagramPacket.d.ts" />
/// <reference path="./java.net.DatagramSocketImpl.d.ts" />
/// <reference path="./java.net.DatagramSocketImplFactory.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
/// <reference path="./java.nio.channels.DatagramChannel.d.ts" />
declare module java {
    export module net {
        export class DatagramSocket extends java.lang.Object implements java.io.Closeable {
            public getReuseAddress(): boolean;

            public isClosed(): boolean;

            public setSendBufferSize(param0: number): void;

            public connect(param0: java.net.InetAddress, param1: number): void;

            public constructor(param0: java.net.SocketAddress);

            public bind(param0: java.net.SocketAddress): void;

            public setReceiveBufferSize(param0: number): void;

            public setBroadcast(param0: boolean): void;

            public getBroadcast(): boolean;

            public receive(param0: java.net.DatagramPacket): void;

            public getInetAddress(): java.net.InetAddress;

            public setSoTimeout(param0: number): void;

            public setTrafficClass(param0: number): void;

            public constructor(param0: java.net.DatagramSocketImpl);

            public getLocalPort(): number;

            public getTrafficClass(): number;

            public isConnected(): boolean;

            public close(): void;

            public getLocalAddress(): java.net.InetAddress;

            public setReuseAddress(param0: boolean): void;

            public constructor(param0: number, param1: java.net.InetAddress);

            public getSendBufferSize(): number;

            public getSoTimeout(): number;

            public isBound(): boolean;

            public constructor(param0: number);

            public getReceiveBufferSize(): number;

            public constructor();

            public send(param0: java.net.DatagramPacket): void;

            public connect(param0: java.net.SocketAddress): void;

            public getChannel(): java.nio.channels.DatagramChannel;

            public getLocalSocketAddress(): java.net.SocketAddress;

            public getRemoteSocketAddress(): java.net.SocketAddress;

            public static setDatagramSocketImplFactory(param0: java.net.DatagramSocketImplFactory): void;

            public getPort(): number;

            public disconnect(): void;
        }
    }
}

/// <reference path="./java.io.FileDescriptor.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.net.DatagramPacket.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.NetworkInterface.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
declare module java {
    export module net {
        export abstract class DatagramSocketImpl extends java.lang.Object implements java.net.SocketOptions {
            public fd: java.io.FileDescriptor;
            public localPort: number;

            public join(param0: java.net.InetAddress): void;

            public create(): void;

            public connect(param0: java.net.InetAddress, param1: number): void;

            public joinGroup(param0: java.net.SocketAddress, param1: java.net.NetworkInterface): void;

            public setOption(param0: number, param1: java.lang.Object): void;

            public constructor();

            public setTTL(param0: number): void;

            public peekData(param0: java.net.DatagramPacket): number;

            public getOption(param0: number): java.lang.Object;

            public send(param0: java.net.DatagramPacket): void;

            public receive(param0: java.net.DatagramPacket): void;

            public setTimeToLive(param0: number): void;

            public getLocalPort(): number;

            public getTTL(): number;

            public leave(param0: java.net.InetAddress): void;

            public getFileDescriptor(): java.io.FileDescriptor;

            public leaveGroup(param0: java.net.SocketAddress, param1: java.net.NetworkInterface): void;

            public bind(param0: number, param1: java.net.InetAddress): void;

            public close(): void;

            public getTimeToLive(): number;

            public peek(param0: java.net.InetAddress): number;

            public disconnect(): void;
        }
    }
}

/// <reference path="./java.net.DatagramSocketImpl.d.ts" />
declare module java {
    export module net {
        export class DatagramSocketImplFactory extends java.lang.Object {
            /**
             * Constructs a new instance of the java.net.DatagramSocketImplFactory interface with the provided implementation.
             */
            public constructor(implementation: {
                createDatagramSocketImpl(): java.net.DatagramSocketImpl;
            });

            public createDatagramSocketImpl(): java.net.DatagramSocketImpl;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module net {
        export class FileNameMap extends java.lang.Object {
            /**
             * Constructs a new instance of the java.net.FileNameMap interface with the provided implementation.
             */
            public constructor(implementation: {
                getContentTypeFor(param0: string): string;
            });

            public getContentTypeFor(param0: string): string;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module net {
        export class HttpCookie extends java.lang.Object implements java.lang.Cloneable {
            public getPortlist(): string;

            public getComment(): string;

            public setCommentURL(param0: string): void;

            public setValue(param0: string): void;

            public equals(param0: java.lang.Object): boolean;

            public getMaxAge(): number;

            public hasExpired(): boolean;

            public getVersion(): number;

            public setDiscard(param0: boolean): void;

            public constructor(param0: string, param1: string);

            public static parse(param0: string): java.util.List;

            public setMaxAge(param0: number): void;

            public getCommentURL(): string;

            public setPath(param0: string): void;

            public setPortlist(param0: string): void;

            public setDomain(param0: string): void;

            public static domainMatches(param0: string, param1: string): boolean;

            public setVersion(param0: number): void;

            public getPath(): string;

            public toString(): string;

            public getName(): string;

            public setComment(param0: string): void;

            public getSecure(): boolean;

            public getDiscard(): boolean;

            public getDomain(): string;

            public setSecure(param0: boolean): void;

            public getValue(): string;

            public clone(): java.lang.Object;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class HttpRetryException extends java.io.IOException {
            public constructor(param0: string, param1: number, param2: string);

            public getReason(): string;

            public responseCode(): number;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: number);

            public getLocation(): string;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module net {
        export abstract class HttpURLConnection extends java.net.URLConnection {
            public static HTTP_ACCEPTED: number;
            public static HTTP_BAD_GATEWAY: number;
            public static HTTP_BAD_METHOD: number;
            public static HTTP_BAD_REQUEST: number;
            public static HTTP_CLIENT_TIMEOUT: number;
            public static HTTP_CONFLICT: number;
            public static HTTP_CREATED: number;
            public static HTTP_ENTITY_TOO_LARGE: number;
            public static HTTP_FORBIDDEN: number;
            public static HTTP_GATEWAY_TIMEOUT: number;
            public static HTTP_GONE: number;
            public static HTTP_INTERNAL_ERROR: number;
            public static HTTP_LENGTH_REQUIRED: number;
            public static HTTP_MOVED_PERM: number;
            public static HTTP_MOVED_TEMP: number;
            public static HTTP_MULT_CHOICE: number;
            public static HTTP_NOT_ACCEPTABLE: number;
            public static HTTP_NOT_AUTHORITATIVE: number;
            public static HTTP_NOT_FOUND: number;
            public static HTTP_NOT_IMPLEMENTED: number;
            public static HTTP_NOT_MODIFIED: number;
            public static HTTP_NO_CONTENT: number;
            public static HTTP_OK: number;
            public static HTTP_PARTIAL: number;
            public static HTTP_PAYMENT_REQUIRED: number;
            public static HTTP_PRECON_FAILED: number;
            public static HTTP_PROXY_AUTH: number;
            public static HTTP_REQ_TOO_LONG: number;
            public static HTTP_RESET: number;
            public static HTTP_SEE_OTHER: number;
            public static HTTP_SERVER_ERROR: number;
            public static HTTP_UNAUTHORIZED: number;
            public static HTTP_UNAVAILABLE: number;
            public static HTTP_UNSUPPORTED_TYPE: number;
            public static HTTP_USE_PROXY: number;
            public static HTTP_VERSION: number;
            public chunkLength: number;
            public fixedContentLength: number;
            public fixedContentLengthLong: number;
            public instanceFollowRedirects: boolean;
            public method: string;
            public responseCode: number;
            public responseMessage: string;

            public setFixedLengthStreamingMode(param0: number): void;

            public getRequestMethod(): string;

            public static getFollowRedirects(): boolean;

            public getContentEncoding(): string;

            public setInstanceFollowRedirects(param0: boolean): void;

            public getHeaderFieldDate(param0: string, param1: number): number;

            public getPermission(): java.security.Permission;

            public usingProxy(): boolean;

            public getErrorStream(): java.io.InputStream;

            public constructor(param0: java.net.URL);

            public getResponseCode(): number;

            public static setFollowRedirects(param0: boolean): void;

            public getResponseMessage(): string;

            public setRequestMethod(param0: string): void;

            public setChunkedStreamingMode(param0: number): void;

            public getInstanceFollowRedirects(): boolean;

            public disconnect(): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module net {
        export class IDN extends java.lang.Object {
            public static ALLOW_UNASSIGNED: number;
            public static USE_STD3_ASCII_RULES: number;

            public static toUnicode(param0: string, param1: number): string;
            public static toUnicode(param0: string): string;

            public static toASCII(param0: string, param1: number): string;
            public static toASCII(param0: string): string;
        }
    }
}

declare module java {
    export module net {
        export class Inet4Address extends java.net.InetAddress {
            public isMCOrgLocal(): boolean;

            public isMulticastAddress(): boolean;

            public isAnyLocalAddress(): boolean;

            public isLinkLocalAddress(): boolean;

            public isLoopbackAddress(): boolean;

            public isMCSiteLocal(): boolean;

            public isMCGlobal(): boolean;

            public isMCNodeLocal(): boolean;

            public isMCLinkLocal(): boolean;

            public isSiteLocalAddress(): boolean;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.NetworkInterface.d.ts" />
declare module java {
    export module net {
        export class Inet6Address extends java.net.InetAddress {
            public static getByAddress(param0: string, param1: native.Array<number>, param2: java.net.NetworkInterface): java.net.Inet6Address;

            public isMCOrgLocal(): boolean;

            public isMulticastAddress(): boolean;

            public isLinkLocalAddress(): boolean;

            public isLoopbackAddress(): boolean;

            public getScopedInterface(): java.net.NetworkInterface;

            public isMCGlobal(): boolean;

            public getScopeId(): number;

            public static getByAddress(param0: string, param1: native.Array<number>): java.net.InetAddress;

            public isAnyLocalAddress(): boolean;

            public toString(): string;

            public static getByAddress(param0: string, param1: native.Array<number>, param2: number): java.net.Inet6Address;

            public isMCSiteLocal(): boolean;

            public static getByAddress(param0: native.Array<number>): java.net.InetAddress;

            public isMCNodeLocal(): boolean;

            public isMCLinkLocal(): boolean;

            public isIPv4CompatibleAddress(): boolean;

            public isSiteLocalAddress(): boolean;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.NetworkInterface.d.ts" />
declare module java {
    export module net {
        export class InetAddress extends java.lang.Object implements java.io.Serializable {
            public isMulticastAddress(): boolean;

            public isLinkLocalAddress(): boolean;

            public getHostAddress(): string;

            public equals(param0: java.lang.Object): boolean;

            public static getLoopbackAddress(): java.net.InetAddress;

            public static getByAddress(param0: string, param1: native.Array<number>): java.net.InetAddress;

            public getCanonicalHostName(): string;

            public getAddress(): native.Array<number>;

            public isMCLinkLocal(): boolean;

            public isSiteLocalAddress(): boolean;

            public isMCOrgLocal(): boolean;

            public isLoopbackAddress(): boolean;

            public static getAllByName(param0: string): native.Array<java.net.InetAddress>;

            public isMCGlobal(): boolean;

            public static getByName(param0: string): java.net.InetAddress;

            public isReachable(param0: java.net.NetworkInterface, param1: number, param2: number): boolean;

            public static getLocalHost(): java.net.InetAddress;

            public toString(): string;

            public isAnyLocalAddress(): boolean;

            public isMCSiteLocal(): boolean;

            public isReachable(param0: number): boolean;

            public isMCNodeLocal(): boolean;

            public static getByAddress(param0: native.Array<number>): java.net.InetAddress;

            public getHostName(): string;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
declare module java {
    export module net {
        export class InetSocketAddress extends java.net.SocketAddress {
            public constructor(param0: number);
            public constructor();

            public isUnresolved(): boolean;

            public getAddress(): java.net.InetAddress;

            public equals(param0: java.lang.Object): boolean;

            public toString(): string;

            public static createUnresolved(param0: string, param1: number): java.net.InetSocketAddress;

            public constructor(param0: string, param1: number);

            public getHostName(): string;

            public getPort(): number;

            public getHostString(): string;

            public constructor(param0: java.net.InetAddress, param1: number);

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
declare module java {
    export module net {
        export class InterfaceAddress extends java.lang.Object {
            public getNetworkPrefixLength(): number;

            public toString(): string;

            public getBroadcast(): java.net.InetAddress;

            public equals(param0: java.lang.Object): boolean;

            public getAddress(): java.net.InetAddress;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.net.URLConnection.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
/// <reference path="./java.util.jar.Attributes.d.ts" />
/// <reference path="./java.util.jar.JarEntry.d.ts" />
/// <reference path="./java.util.jar.JarFile.d.ts" />
/// <reference path="./java.util.jar.Manifest.d.ts" />
declare module java {
    export module net {
        export abstract class JarURLConnection extends java.net.URLConnection {
            public jarFileURLConnection: java.net.URLConnection;

            public getEntryName(): string;

            public constructor(param0: java.net.URL);

            public getJarEntry(): java.util.jar.JarEntry;

            public getCertificates(): native.Array<java.security.cert.Certificate>;

            public getManifest(): java.util.jar.Manifest;

            public getMainAttributes(): java.util.jar.Attributes;

            public getAttributes(): java.util.jar.Attributes;

            public getJarFile(): java.util.jar.JarFile;

            public getJarFileURL(): java.net.URL;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class MalformedURLException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.net.DatagramPacket.d.ts" />
/// <reference path="./java.net.DatagramSocketImpl.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.NetworkInterface.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
declare module java {
    export module net {
        export class MulticastSocket extends java.net.DatagramSocket {
            public leaveGroup(param0: java.net.InetAddress): void;

            public constructor(param0: number, param1: java.net.InetAddress);

            public setLoopbackMode(param0: boolean): void;

            public getNetworkInterface(): java.net.NetworkInterface;

            public constructor(param0: number);

            public joinGroup(param0: java.net.SocketAddress, param1: java.net.NetworkInterface): void;

            public constructor(param0: java.net.SocketAddress);
            public constructor();

            public setTTL(param0: number): void;

            public send(param0: java.net.DatagramPacket): void;
            public send(param0: java.net.DatagramPacket, param1: number): void;

            public setNetworkInterface(param0: java.net.NetworkInterface): void;

            public getInterface(): java.net.InetAddress;

            public setTimeToLive(param0: number): void;

            public constructor(param0: java.net.DatagramSocketImpl);

            public getTTL(): number;

            public leaveGroup(param0: java.net.SocketAddress, param1: java.net.NetworkInterface): void;

            public getLoopbackMode(): boolean;

            public joinGroup(param0: java.net.InetAddress): void;

            public close(): void;

            public getTimeToLive(): number;

            public setInterface(param0: java.net.InetAddress): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module net {
        export class NetPermission extends java.security.BasicPermission {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module net {
        export class NetworkInterface extends java.lang.Object {
            public getParent(): java.net.NetworkInterface;

            public getIndex(): number;

            public getHardwareAddress(): native.Array<number>;

            public isVirtual(): boolean;

            public isLoopback(): boolean;

            public getSubInterfaces(): java.util.Enumeration;

            public getMTU(): number;

            public getInterfaceAddresses(): java.util.List;

            public static getByIndex(param0: number): java.net.NetworkInterface;

            public equals(param0: java.lang.Object): boolean;

            public static getByInetAddress(param0: java.net.InetAddress): java.net.NetworkInterface;

            public toString(): string;

            public getName(): string;

            public static getByName(param0: string): java.net.NetworkInterface;

            public isPointToPoint(): boolean;

            public static getNetworkInterfaces(): java.util.Enumeration;

            public isUp(): boolean;

            public getInetAddresses(): java.util.Enumeration;

            public supportsMulticast(): boolean;

            public getDisplayName(): string;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class NoRouteToHostException extends java.net.SocketException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module net {
        export class PasswordAuthentication extends java.lang.Object {
            public getUserName(): string;

            public getPassword(): native.Array<string>;

            public constructor(param0: string, param1: native.Array<string>);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class PortUnreachableException extends java.net.SocketException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class ProtocolException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
declare module java {
    export module net {
        export class Proxy extends java.lang.Object {
            public static NO_PROXY: java.net.Proxy;

            public toString(): string;

            public type(): java.net.Proxy.Type;

            public address(): java.net.SocketAddress;

            public constructor(param0: java.net.Proxy.Type, param1: java.net.SocketAddress);

            public equals(param0: java.lang.Object): boolean;

            public hashCode(): number;
        }
        export module Proxy {
            export class Type extends java.lang.Enum {
                public static DIRECT: java.net.Proxy.Type;
                public static HTTP: java.net.Proxy.Type;
                public static SOCKS: java.net.Proxy.Type;

                public static values(): native.Array<java.net.Proxy.Type>;

                public static valueOf(param0: string): java.net.Proxy.Type;
                public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            }
        }
    }
}

/// <reference path="./java.io.IOException.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
/// <reference path="./java.net.URI.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module net {
        export abstract class ProxySelector extends java.lang.Object {
            public connectFailed(param0: java.net.URI, param1: java.net.SocketAddress, param2: java.io.IOException): void;

            public static getDefault(): java.net.ProxySelector;

            public static setDefault(param0: java.net.ProxySelector): void;

            public select(param0: java.net.URI): java.util.List;

            public constructor();
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.CacheRequest.d.ts" />
/// <reference path="./java.net.CacheResponse.d.ts" />
/// <reference path="./java.net.URI.d.ts" />
/// <reference path="./java.net.URLConnection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module net {
        export abstract class ResponseCache extends java.lang.Object {
            public get(param0: java.net.URI, param1: string, param2: java.util.Map): java.net.CacheResponse;

            public put(param0: java.net.URI, param1: java.net.URLConnection): java.net.CacheRequest;

            public static setDefault(param0: java.net.ResponseCache): void;

            public constructor();

            public static getDefault(): java.net.ResponseCache;
        }
    }
}

/// <reference path="./java.security.Principal.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module net {
        export abstract class SecureCacheResponse extends java.net.CacheResponse {
            public getServerCertificateChain(): java.util.List;

            public getLocalCertificateChain(): java.util.List;

            public getLocalPrincipal(): java.security.Principal;

            public getCipherSuite(): string;

            public constructor();

            public getPeerPrincipal(): java.security.Principal;
        }
    }
}

/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.Socket.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
/// <reference path="./java.net.SocketImplFactory.d.ts" />
/// <reference path="./java.nio.channels.ServerSocketChannel.d.ts" />
declare module java {
    export module net {
        export class ServerSocket extends java.lang.Object implements java.io.Closeable {
            public isClosed(): boolean;

            public getReuseAddress(): boolean;

            public bind(param0: java.net.SocketAddress, param1: number): void;

            public getSoTimeout(): number;

            public static setSocketFactory(param0: java.net.SocketImplFactory): void;

            public isBound(): boolean;

            public constructor(param0: number);

            public getReceiveBufferSize(): number;

            public bind(param0: java.net.SocketAddress): void;

            public constructor();
            public constructor(param0: number, param1: number, param2: java.net.InetAddress);

            public getChannel(): java.nio.channels.ServerSocketChannel;

            public setReceiveBufferSize(param0: number): void;

            public toString(): string;

            public getInetAddress(): java.net.InetAddress;

            public setSoTimeout(param0: number): void;

            public implAccept(param0: java.net.Socket): void;

            public setPerformancePreferences(param0: number, param1: number, param2: number): void;

            public getLocalPort(): number;

            public getLocalSocketAddress(): java.net.SocketAddress;

            public close(): void;

            public constructor(param0: number, param1: number);

            public accept(): java.net.Socket;

            public setReuseAddress(param0: boolean): void;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.Proxy.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
/// <reference path="./java.net.SocketImpl.d.ts" />
/// <reference path="./java.net.SocketImplFactory.d.ts" />
/// <reference path="./java.nio.channels.SocketChannel.d.ts" />
declare module java {
    export module net {
        export class Socket extends java.lang.Object implements java.io.Closeable {
            public constructor(param0: java.net.InetAddress, param1: number, param2: boolean);
            public constructor(param0: java.net.Proxy);

            public isInputShutdown(): boolean;

            public getInetAddress(): java.net.InetAddress;

            public setTrafficClass(param0: number): void;

            public constructor(param0: string, param1: number);

            public isConnected(): boolean;

            public getOutputStream(): java.io.OutputStream;

            public constructor(param0: java.net.InetAddress, param1: number);
            public constructor(param0: java.net.SocketImpl);

            public isOutputShutdown(): boolean;

            public sendUrgentData(param0: number): void;

            public getKeepAlive(): boolean;

            public isBound(): boolean;

            public constructor();

            public getOOBInline(): boolean;

            public constructor(param0: java.net.InetAddress, param1: number, param2: java.net.InetAddress, param3: number);

            public getLocalSocketAddress(): java.net.SocketAddress;

            public getRemoteSocketAddress(): java.net.SocketAddress;

            public constructor(param0: string, param1: number, param2: boolean);

            public getPort(): number;

            public shutdownOutput(): void;

            public isClosed(): boolean;

            public getReuseAddress(): boolean;

            public getTcpNoDelay(): boolean;

            public setSendBufferSize(param0: number): void;

            public constructor(param0: string, param1: number, param2: java.net.InetAddress, param3: number);

            public setKeepAlive(param0: boolean): void;

            public setSoLinger(param0: boolean, param1: number): void;

            public bind(param0: java.net.SocketAddress): void;

            public connect(param0: java.net.SocketAddress, param1: number): void;

            public getChannel(): java.nio.channels.SocketChannel;

            public setReceiveBufferSize(param0: number): void;

            public setSoTimeout(param0: number): void;

            public getLocalPort(): number;

            public getTrafficClass(): number;

            public close(): void;

            public getLocalAddress(): java.net.InetAddress;

            public getSoLinger(): number;

            public setReuseAddress(param0: boolean): void;

            public getSendBufferSize(): number;

            public getSoTimeout(): number;

            public getReceiveBufferSize(): number;

            public setOOBInline(param0: boolean): void;

            public static setSocketImplFactory(param0: java.net.SocketImplFactory): void;

            public shutdownInput(): void;

            public toString(): string;

            public getInputStream(): java.io.InputStream;

            public connect(param0: java.net.SocketAddress): void;

            public setPerformancePreferences(param0: number, param1: number, param2: number): void;

            public setTcpNoDelay(param0: boolean): void;
        }
    }
}

declare module java {
    export module net {
        export abstract class SocketAddress extends java.lang.Object implements java.io.Serializable {
            public constructor();
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class SocketException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.FileDescriptor.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
declare module java {
    export module net {
        export abstract class SocketImpl extends java.lang.Object implements java.net.SocketOptions {
            public address: java.net.InetAddress;
            public fd: java.io.FileDescriptor;
            public localport: number;
            public port: number;

            public shutdownOutput(): void;

            public bind(param0: java.net.InetAddress, param1: number): void;

            public supportsUrgentData(): boolean;

            public sendUrgentData(param0: number): void;

            public connect(param0: java.net.InetAddress, param1: number): void;

            public create(param0: boolean): void;

            public setOption(param0: number, param1: java.lang.Object): void;

            public constructor();

            public connect(param0: java.net.SocketAddress, param1: number): void;

            public available(): number;

            public getOption(param0: number): java.lang.Object;

            public listen(param0: number): void;

            public shutdownInput(): void;

            public toString(): string;

            public getInputStream(): java.io.InputStream;

            public getInetAddress(): java.net.InetAddress;

            public connect(param0: string, param1: number): void;

            public setPerformancePreferences(param0: number, param1: number, param2: number): void;

            public accept(param0: java.net.SocketImpl): void;

            public getLocalPort(): number;

            public getFileDescriptor(): java.io.FileDescriptor;

            public getOutputStream(): java.io.OutputStream;

            public close(): void;

            public getPort(): number;
        }
    }
}

/// <reference path="./java.net.SocketImpl.d.ts" />
declare module java {
    export module net {
        export class SocketImplFactory extends java.lang.Object {
            /**
             * Constructs a new instance of the java.net.SocketImplFactory interface with the provided implementation.
             */
            public constructor(implementation: {
                createSocketImpl(): java.net.SocketImpl;
            });

            public createSocketImpl(): java.net.SocketImpl;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module net {
        export class SocketOptions extends java.lang.Object {
            /**
             * Constructs a new instance of the java.net.SocketOptions interface with the provided implementation.
             */
            public constructor(implementation: {
                getOption(param0: number): java.lang.Object;
                setOption(param0: number, param1: java.lang.Object): void;
            });

            public static SO_REUSEADDR: number;
            public static TCP_NODELAY: number;
            public static IP_TOS: number;
            public static IP_MULTICAST_IF: number;
            public static SO_SNDBUF: number;
            public static IP_MULTICAST_IF2: number;
            public static SO_TIMEOUT: number;
            public static SO_BROADCAST: number;
            public static SO_OOBINLINE: number;
            public static IP_MULTICAST_LOOP: number;
            public static SO_BINDADDR: number;
            public static SO_LINGER: number;
            public static SO_RCVBUF: number;
            public static SO_KEEPALIVE: number;

            public getOption(param0: number): java.lang.Object;

            public setOption(param0: number, param1: java.lang.Object): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module net {
        export class SocketPermission extends java.security.Permission implements java.io.Serializable {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class SocketTimeoutException extends java.io.InterruptedIOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
declare module java {
    export module net {
        export class URI extends java.lang.Object implements java.io.Serializable {
            public constructor(param0: string, param1: string, param2: string, param3: string, param4: string);

            public resolve(param0: string): java.net.URI;

            public toASCIIString(): string;

            public getRawSchemeSpecificPart(): string;

            public getRawAuthority(): string;

            public getFragment(): string;

            public resolve(param0: java.net.URI): java.net.URI;

            public constructor(param0: string, param1: string, param2: string);

            public getUserInfo(): string;

            public getHost(): string;

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: string, param1: string, param2: string, param3: string);

            public getSchemeSpecificPart(): string;

            public getAuthority(): string;

            public getScheme(): string;

            public getRawPath(): string;

            public getRawQuery(): string;

            public parseServerAuthority(): java.net.URI;

            public getQuery(): string;

            public static create(param0: string): java.net.URI;

            public constructor(param0: string);

            public isOpaque(): boolean;

            public relativize(param0: java.net.URI): java.net.URI;

            public getRawFragment(): string;

            public toURL(): java.net.URL;

            public constructor(param0: string, param1: string, param2: string, param3: number, param4: string, param5: string, param6: string);

            public getPath(): string;

            public toString(): string;

            public isAbsolute(): boolean;

            public compareTo(param0: java.net.URI): number;

            public getPort(): number;

            public normalize(): java.net.URI;

            public getRawUserInfo(): string;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class URISyntaxException extends java.lang.Exception {
            public constructor(param0: string, param1: string);

            public getMessage(): string;

            public getIndex(): number;

            public getInput(): string;

            public getReason(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.Proxy.d.ts" />
/// <reference path="./java.net.URI.d.ts" />
/// <reference path="./java.net.URLConnection.d.ts" />
/// <reference path="./java.net.URLStreamHandler.d.ts" />
/// <reference path="./java.net.URLStreamHandlerFactory.d.ts" />
declare module java {
    export module net {
        export class URL extends java.lang.Object implements java.io.Serializable {
            public sameFile(param0: java.net.URL): boolean;

            public constructor(param0: string, param1: string, param2: number, param3: string);
            public constructor(param0: string, param1: string, param2: string);

            public openStream(): java.io.InputStream;

            public getUserInfo(): string;

            public getHost(): string;

            public getFile(): string;

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: java.net.URL, param1: string, param2: java.net.URLStreamHandler);

            public getContent(): java.lang.Object;

            public getAuthority(): string;

            public set(param0: string, param1: string, param2: number, param3: string, param4: string, param5: string, param6: string, param7: string): void;

            public constructor(param0: java.net.URL, param1: string);

            public toExternalForm(): string;

            public getProtocol(): string;

            public getQuery(): string;

            public static setURLStreamHandlerFactory(param0: java.net.URLStreamHandlerFactory): void;

            public constructor(param0: string);

            public toURI(): java.net.URI;

            public constructor(param0: string, param1: string, param2: number, param3: string, param4: java.net.URLStreamHandler);

            public openConnection(): java.net.URLConnection;

            public set(param0: string, param1: string, param2: number, param3: string, param4: string): void;

            public getDefaultPort(): number;

            public getRef(): string;

            public toString(): string;

            public getPath(): string;

            public openConnection(param0: java.net.Proxy): java.net.URLConnection;

            public getContent(param0: native.Array<java.lang.Class>): java.lang.Object;

            public getPort(): number;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.ClassLoader.d.ts" />
/// <reference path="./java.lang.Package.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.net.URLStreamHandlerFactory.d.ts" />
/// <reference path="./java.security.CodeSource.d.ts" />
/// <reference path="./java.security.PermissionCollection.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.jar.Manifest.d.ts" />
declare module java {
    export module net {
        export class URLClassLoader extends java.security.SecureClassLoader {
            public definePackage(param0: string, param1: java.util.jar.Manifest, param2: java.net.URL): java.lang.Package;

            public constructor(param0: native.Array<java.net.URL>, param1: java.lang.ClassLoader);

            public getPermissions(param0: java.security.CodeSource): java.security.PermissionCollection;

            public findResource(param0: string): java.net.URL;

            public constructor(param0: java.lang.ClassLoader);
            public constructor();

            public addURL(param0: java.net.URL): void;

            public definePackage(param0: string, param1: string, param2: string, param3: string, param4: string, param5: string, param6: string, param7: java.net.URL): java.lang.Package;

            public constructor(param0: native.Array<java.net.URL>);
            public constructor(param0: native.Array<java.net.URL>, param1: java.lang.ClassLoader, param2: java.net.URLStreamHandlerFactory);

            public findClass(param0: string): java.lang.Class;

            public static newInstance(param0: native.Array<java.net.URL>, param1: java.lang.ClassLoader): java.net.URLClassLoader;

            public getURLs(): native.Array<java.net.URL>;

            public static newInstance(param0: native.Array<java.net.URL>): java.net.URLClassLoader;

            public findResources(param0: string): java.util.Enumeration;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.ContentHandlerFactory.d.ts" />
/// <reference path="./java.net.FileNameMap.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module net {
        export abstract class URLConnection extends java.lang.Object {
            public allowUserInteraction: boolean;
            public connected: boolean;
            public doInput: boolean;
            public doOutput: boolean;
            public ifModifiedSince: number;
            public url: java.net.URL;
            public useCaches: boolean;

            public static guessContentTypeFromStream(param0: java.io.InputStream): string;

            public getExpiration(): number;

            public getHeaderFieldDate(param0: string, param1: number): number;

            public getDoOutput(): boolean;

            public getHeaderFieldKey(param0: number): string;

            public getPermission(): java.security.Permission;

            public setConnectTimeout(param0: number): void;

            public getURL(): java.net.URL;

            public static guessContentTypeFromName(param0: string): string;

            public getOutputStream(): java.io.OutputStream;

            public setReadTimeout(param0: number): void;

            public setDefaultUseCaches(param0: boolean): void;

            public static getFileNameMap(): java.net.FileNameMap;

            public getAllowUserInteraction(): boolean;

            public getDefaultUseCaches(): boolean;

            public setAllowUserInteraction(param0: boolean): void;

            public getRequestProperties(): java.util.Map;

            public getHeaderFields(): java.util.Map;

            public getRequestProperty(param0: string): string;

            public getContentEncoding(): string;

            public getDate(): number;

            public static getDefaultRequestProperty(param0: string): string;

            public getLastModified(): number;

            public static setDefaultRequestProperty(param0: string, param1: string): void;

            public getHeaderField(param0: number): string;

            public static setFileNameMap(param0: java.net.FileNameMap): void;

            public getContent(): java.lang.Object;

            public getDoInput(): boolean;

            public setUseCaches(param0: boolean): void;

            public constructor(param0: java.net.URL);

            public addRequestProperty(param0: string, param1: string): void;

            public static getDefaultAllowUserInteraction(): boolean;

            public static setContentHandlerFactory(param0: java.net.ContentHandlerFactory): void;

            public getContentLength(): number;

            public getHeaderFieldInt(param0: string, param1: number): number;

            public setDoInput(param0: boolean): void;

            public getContentType(): string;

            public getConnectTimeout(): number;

            public getUseCaches(): boolean;

            public toString(): string;

            public getHeaderField(param0: string): string;

            public getInputStream(): java.io.InputStream;

            public getIfModifiedSince(): number;

            public setRequestProperty(param0: string, param1: string): void;

            public getReadTimeout(): number;

            public setDoOutput(param0: boolean): void;

            public connect(): void;

            public static setDefaultAllowUserInteraction(param0: boolean): void;

            public getContent(param0: native.Array<java.lang.Class>): java.lang.Object;

            public setIfModifiedSince(param0: number): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module net {
        export class URLDecoder extends java.lang.Object {
            public static decode(param0: string): string;

            public constructor();

            public static decode(param0: string, param1: string): string;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module net {
        export class URLEncoder extends java.lang.Object {
            public static encode(param0: string, param1: string): string;
            public static encode(param0: string): string;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.InetAddress.d.ts" />
/// <reference path="./java.net.Proxy.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.net.URLConnection.d.ts" />
declare module java {
    export module net {
        export abstract class URLStreamHandler extends java.lang.Object {
            public hostsEqual(param0: java.net.URL, param1: java.net.URL): boolean;

            public setURL(param0: java.net.URL, param1: string, param2: string, param3: number, param4: string, param5: string, param6: string, param7: string, param8: string): void;

            public openConnection(param0: java.net.URL): java.net.URLConnection;

            public getDefaultPort(): number;

            public constructor();

            public getHostAddress(param0: java.net.URL): java.net.InetAddress;

            public equals(param0: java.lang.Object): boolean;

            public parseURL(param0: java.net.URL, param1: string, param2: number, param3: number): void;

            public setURL(param0: java.net.URL, param1: string, param2: string, param3: number, param4: string, param5: string): void;

            public sameFile(param0: java.net.URL, param1: java.net.URL): boolean;

            public openConnection(param0: java.net.URL, param1: java.net.Proxy): java.net.URLConnection;

            public equals(param0: java.net.URL, param1: java.net.URL): boolean;

            public hashCode(param0: java.net.URL): number;

            public toExternalForm(param0: java.net.URL): string;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.net.URLStreamHandler.d.ts" />
declare module java {
    export module net {
        export class URLStreamHandlerFactory extends java.lang.Object {
            /**
             * Constructs a new instance of the java.net.URLStreamHandlerFactory interface with the provided implementation.
             */
            public constructor(implementation: {
                createURLStreamHandler(param0: string): java.net.URLStreamHandler;
            });

            public createURLStreamHandler(param0: string): java.net.URLStreamHandler;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class UnknownHostException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module net {
        export class UnknownServiceException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module nio {
        export abstract class Buffer extends java.lang.Object {
            public isReadOnly(): boolean;

            public isDirect(): boolean;

            public array(): java.lang.Object;

            public hasRemaining(): boolean;

            public limit(param0: number): java.nio.Buffer;

            public position(param0: number): java.nio.Buffer;

            public clear(): java.nio.Buffer;

            public flip(): java.nio.Buffer;

            public mark(): java.nio.Buffer;

            public hasArray(): boolean;

            public limit(): number;

            public toString(): string;

            public capacity(): number;

            public position(): number;

            public remaining(): number;

            public reset(): java.nio.Buffer;

            public arrayOffset(): number;

            public rewind(): java.nio.Buffer;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export class BufferOverflowException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export class BufferUnderflowException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.ByteOrder.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
/// <reference path="./java.nio.DoubleBuffer.d.ts" />
/// <reference path="./java.nio.FloatBuffer.d.ts" />
/// <reference path="./java.nio.IntBuffer.d.ts" />
/// <reference path="./java.nio.LongBuffer.d.ts" />
/// <reference path="./java.nio.ShortBuffer.d.ts" />
declare module java {
    export module nio {
        export abstract class ByteBuffer extends java.nio.Buffer {
            public putShort(param0: number, param1: number): java.nio.ByteBuffer;

            public asIntBuffer(): java.nio.IntBuffer;

            public getChar(param0: number): string;

            public putLong(param0: number): java.nio.ByteBuffer;

            public isDirect(): boolean;

            public putFloat(param0: number, param1: number): java.nio.ByteBuffer;

            public compareTo(param0: java.nio.ByteBuffer): number;

            public array(): java.lang.Object;

            public getFloat(param0: number): number;

            public compact(): java.nio.ByteBuffer;

            public putFloat(param0: number): java.nio.ByteBuffer;

            public put(param0: java.nio.ByteBuffer): java.nio.ByteBuffer;

            public order(): java.nio.ByteOrder;

            public equals(param0: java.lang.Object): boolean;

            public asShortBuffer(): java.nio.ShortBuffer;

            public put(param0: number): java.nio.ByteBuffer;

            public putLong(param0: number, param1: number): java.nio.ByteBuffer;

            public getShort(param0: number): number;

            public arrayOffset(): number;

            public asLongBuffer(): java.nio.LongBuffer;

            public putDouble(param0: number, param1: number): java.nio.ByteBuffer;

            public slice(): java.nio.ByteBuffer;

            public getDouble(param0: number): number;

            public putChar(param0: string): java.nio.ByteBuffer;

            public put(param0: native.Array<number>): java.nio.ByteBuffer;

            public static allocate(param0: number): java.nio.ByteBuffer;

            public static wrap(param0: native.Array<number>): java.nio.ByteBuffer;

            public duplicate(): java.nio.ByteBuffer;

            public asCharBuffer(): java.nio.CharBuffer;

            public hasArray(): boolean;

            public asReadOnlyBuffer(): java.nio.ByteBuffer;

            public order(param0: java.nio.ByteOrder): java.nio.ByteBuffer;

            public put(param0: number, param1: number): java.nio.ByteBuffer;

            public getInt(param0: number): number;

            public putChar(param0: number, param1: string): java.nio.ByteBuffer;

            public getChar(): string;

            public static wrap(param0: native.Array<number>, param1: number, param2: number): java.nio.ByteBuffer;

            public get(param0: number): number;
            public get(param0: native.Array<number>): java.nio.ByteBuffer;

            public getShort(): number;

            public get(param0: native.Array<number>, param1: number, param2: number): java.nio.ByteBuffer;

            public static allocateDirect(param0: number): java.nio.ByteBuffer;

            public getInt(): number;

            public array(): native.Array<number>;

            public getLong(): number;

            public asFloatBuffer(): java.nio.FloatBuffer;

            public getDouble(): number;

            public putInt(param0: number): java.nio.ByteBuffer;

            public putShort(param0: number): java.nio.ByteBuffer;

            public getLong(param0: number): number;

            public asDoubleBuffer(): java.nio.DoubleBuffer;

            public get(): number;

            public put(param0: native.Array<number>, param1: number, param2: number): java.nio.ByteBuffer;

            public putDouble(param0: number): java.nio.ByteBuffer;

            public getFloat(): number;

            public hashCode(): number;

            public putInt(param0: number, param1: number): java.nio.ByteBuffer;
        }
    }
}

declare module java {
    export module nio {
        export class ByteOrder extends java.lang.Object {
            public static BIG_ENDIAN: java.nio.ByteOrder;
            public static LITTLE_ENDIAN: java.nio.ByteOrder;

            public toString(): string;

            public static nativeOrder(): java.nio.ByteOrder;
        }
    }
}

/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.ByteOrder.d.ts" />
declare module java {
    export module nio {
        export abstract class CharBuffer extends java.nio.Buffer implements java.lang.CharSequence, java.lang.Appendable, java.lang.Readable {
            public get(param0: native.Array<string>): java.nio.CharBuffer;

            public isDirect(): boolean;

            public static wrap(param0: string): java.nio.CharBuffer;

            public array(): java.lang.Object;

            public put(param0: native.Array<string>): java.nio.CharBuffer;

            public order(): java.nio.ByteOrder;

            public equals(param0: java.lang.Object): boolean;

            public array(): native.Array<string>;

            public asReadOnlyBuffer(): java.nio.CharBuffer;

            public subSequence(param0: number, param1: number): java.nio.CharBuffer;

            public get(param0: native.Array<string>, param1: number, param2: number): java.nio.CharBuffer;

            public compareTo(param0: java.nio.CharBuffer): number;

            public append(param0: string): java.nio.CharBuffer;

            public slice(): java.nio.CharBuffer;

            public subSequence(param0: number, param1: number): string;

            public duplicate(): java.nio.CharBuffer;

            public read(param0: java.nio.CharBuffer): number;

            public put(param0: java.nio.CharBuffer): java.nio.CharBuffer;

            public static wrap(param0: string, param1: number, param2: number): java.nio.CharBuffer;

            public put(param0: native.Array<string>, param1: number, param2: number): java.nio.CharBuffer;

            public static wrap(param0: native.Array<string>): java.nio.CharBuffer;

            public arrayOffset(): number;

            public compact(): java.nio.CharBuffer;

            public append(param0: string, param1: number, param2: number): java.nio.CharBuffer;

            public length(): number;

            public get(): string;

            public put(param0: number, param1: string): java.nio.CharBuffer;

            public append(param0: string, param1: number, param2: number): java.lang.Appendable;

            public put(param0: string, param1: number, param2: number): java.nio.CharBuffer;

            public get(param0: number): string;

            public hasArray(): boolean;

            public charAt(param0: number): string;

            public toString(): string;

            public put(param0: string): java.nio.CharBuffer;

            public static wrap(param0: native.Array<string>, param1: number, param2: number): java.nio.CharBuffer;

            public static allocate(param0: number): java.nio.CharBuffer;

            public append(param0: string): java.lang.Appendable;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.ByteOrder.d.ts" />
declare module java {
    export module nio {
        export abstract class DoubleBuffer extends java.nio.Buffer {
            public asReadOnlyBuffer(): java.nio.DoubleBuffer;

            public put(param0: number, param1: number): java.nio.DoubleBuffer;

            public isDirect(): boolean;

            public array(): java.lang.Object;

            public order(): java.nio.ByteOrder;

            public equals(param0: java.lang.Object): boolean;

            public get(param0: native.Array<number>, param1: number, param2: number): java.nio.DoubleBuffer;

            public compareTo(param0: java.nio.DoubleBuffer): number;

            public get(param0: number): number;

            public put(param0: number): java.nio.DoubleBuffer;
            public put(param0: native.Array<number>): java.nio.DoubleBuffer;
            public put(param0: java.nio.DoubleBuffer): java.nio.DoubleBuffer;

            public arrayOffset(): number;

            public slice(): java.nio.DoubleBuffer;

            public compact(): java.nio.DoubleBuffer;

            public array(): native.Array<number>;

            public duplicate(): java.nio.DoubleBuffer;

            public static wrap(param0: native.Array<number>, param1: number, param2: number): java.nio.DoubleBuffer;

            public hasArray(): boolean;

            public put(param0: native.Array<number>, param1: number, param2: number): java.nio.DoubleBuffer;

            public get(param0: native.Array<number>): java.nio.DoubleBuffer;
            public get(): number;

            public static wrap(param0: native.Array<number>): java.nio.DoubleBuffer;

            public static allocate(param0: number): java.nio.DoubleBuffer;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.ByteOrder.d.ts" />
declare module java {
    export module nio {
        export abstract class FloatBuffer extends java.nio.Buffer {
            public static wrap(param0: native.Array<number>): java.nio.FloatBuffer;

            public isDirect(): boolean;

            public static allocate(param0: number): java.nio.FloatBuffer;

            public array(): java.lang.Object;

            public order(): java.nio.ByteOrder;

            public equals(param0: java.lang.Object): boolean;

            public static wrap(param0: native.Array<number>, param1: number, param2: number): java.nio.FloatBuffer;

            public get(param0: native.Array<number>): java.nio.FloatBuffer;

            public put(param0: java.nio.FloatBuffer): java.nio.FloatBuffer;

            public compareTo(param0: java.nio.FloatBuffer): number;

            public get(param0: number): number;

            public arrayOffset(): number;

            public put(param0: number, param1: number): java.nio.FloatBuffer;

            public array(): native.Array<number>;

            public duplicate(): java.nio.FloatBuffer;

            public compact(): java.nio.FloatBuffer;

            public get(param0: native.Array<number>, param1: number, param2: number): java.nio.FloatBuffer;

            public asReadOnlyBuffer(): java.nio.FloatBuffer;

            public slice(): java.nio.FloatBuffer;

            public hasArray(): boolean;

            public put(param0: native.Array<number>, param1: number, param2: number): java.nio.FloatBuffer;
            public put(param0: number): java.nio.FloatBuffer;
            public put(param0: native.Array<number>): java.nio.FloatBuffer;

            public get(): number;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.ByteOrder.d.ts" />
declare module java {
    export module nio {
        export abstract class IntBuffer extends java.nio.Buffer {
            public asReadOnlyBuffer(): java.nio.IntBuffer;

            public isDirect(): boolean;

            public static allocate(param0: number): java.nio.IntBuffer;

            public static wrap(param0: native.Array<number>): java.nio.IntBuffer;

            public array(): java.lang.Object;

            public get(param0: native.Array<number>, param1: number, param2: number): java.nio.IntBuffer;

            public slice(): java.nio.IntBuffer;

            public order(): java.nio.ByteOrder;

            public equals(param0: java.lang.Object): boolean;

            public put(param0: native.Array<number>): java.nio.IntBuffer;

            public duplicate(): java.nio.IntBuffer;

            public put(param0: java.nio.IntBuffer): java.nio.IntBuffer;

            public compact(): java.nio.IntBuffer;

            public get(param0: number): number;

            public compareTo(param0: java.nio.IntBuffer): number;

            public arrayOffset(): number;

            public put(param0: number): java.nio.IntBuffer;

            public array(): native.Array<number>;

            public put(param0: native.Array<number>, param1: number, param2: number): java.nio.IntBuffer;

            public hasArray(): boolean;

            public get(param0: native.Array<number>): java.nio.IntBuffer;

            public static wrap(param0: native.Array<number>, param1: number, param2: number): java.nio.IntBuffer;

            public get(): number;

            public put(param0: number, param1: number): java.nio.IntBuffer;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export class InvalidMarkException extends java.lang.IllegalStateException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.ByteOrder.d.ts" />
declare module java {
    export module nio {
        export abstract class LongBuffer extends java.nio.Buffer {
            public asReadOnlyBuffer(): java.nio.LongBuffer;

            public put(param0: number): java.nio.LongBuffer;

            public static wrap(param0: native.Array<number>): java.nio.LongBuffer;

            public isDirect(): boolean;

            public array(): java.lang.Object;

            public put(param0: java.nio.LongBuffer): java.nio.LongBuffer;

            public static wrap(param0: native.Array<number>, param1: number, param2: number): java.nio.LongBuffer;

            public order(): java.nio.ByteOrder;

            public equals(param0: java.lang.Object): boolean;

            public slice(): java.nio.LongBuffer;

            public get(param0: native.Array<number>): java.nio.LongBuffer;
            public get(param0: number): number;

            public arrayOffset(): number;

            public compareTo(param0: java.nio.LongBuffer): number;

            public array(): native.Array<number>;

            public static allocate(param0: number): java.nio.LongBuffer;

            public compact(): java.nio.LongBuffer;

            public duplicate(): java.nio.LongBuffer;

            public hasArray(): boolean;

            public put(param0: native.Array<number>): java.nio.LongBuffer;

            public get(param0: native.Array<number>, param1: number, param2: number): java.nio.LongBuffer;

            public put(param0: number, param1: number): java.nio.LongBuffer;
            public put(param0: native.Array<number>, param1: number, param2: number): java.nio.LongBuffer;

            public get(): number;

            public hashCode(): number;
        }
    }
}

declare module java {
    export module nio {
        export abstract class MappedByteBuffer extends java.nio.ByteBuffer {
            public load(): java.nio.MappedByteBuffer;

            public force(): java.nio.MappedByteBuffer;

            public isLoaded(): boolean;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export class ReadOnlyBufferException extends java.lang.UnsupportedOperationException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.ByteOrder.d.ts" />
declare module java {
    export module nio {
        export abstract class ShortBuffer extends java.nio.Buffer {
            public isDirect(): boolean;

            public duplicate(): java.nio.ShortBuffer;

            public array(): java.lang.Object;

            public asReadOnlyBuffer(): java.nio.ShortBuffer;

            public order(): java.nio.ByteOrder;

            public equals(param0: java.lang.Object): boolean;

            public put(param0: native.Array<number>, param1: number, param2: number): java.nio.ShortBuffer;

            public slice(): java.nio.ShortBuffer;

            public compareTo(param0: java.nio.ShortBuffer): number;

            public put(param0: native.Array<number>): java.nio.ShortBuffer;
            public put(param0: number): java.nio.ShortBuffer;

            public get(param0: number): number;

            public arrayOffset(): number;

            public static wrap(param0: native.Array<number>): java.nio.ShortBuffer;

            public array(): native.Array<number>;

            public put(param0: java.nio.ShortBuffer): java.nio.ShortBuffer;

            public static allocate(param0: number): java.nio.ShortBuffer;

            public static wrap(param0: native.Array<number>, param1: number, param2: number): java.nio.ShortBuffer;

            public hasArray(): boolean;

            public put(param0: number, param1: number): java.nio.ShortBuffer;

            public get(param0: native.Array<number>): java.nio.ShortBuffer;

            public compact(): java.nio.ShortBuffer;

            public get(param0: native.Array<number>, param1: number, param2: number): java.nio.ShortBuffer;
            public get(): number;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class AlreadyConnectedException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class AsynchronousCloseException extends java.nio.channels.ClosedChannelException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.nio.ByteBuffer.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class ByteChannel extends java.lang.Object implements java.nio.channels.ReadableByteChannel, java.nio.channels.WritableByteChannel {
                /**
                 * Constructs a new instance of the java.nio.channels.ByteChannel interface with the provided implementation.
                 */
                public constructor(implementation: {
                    read(param0: java.nio.ByteBuffer): number;
                    write(param0: java.nio.ByteBuffer): number;
                    isOpen(): boolean;
                    close(): void;
                    isOpen(): boolean;
                    close(): void;
                    close(): void;
                    close(): void;
                    close(): void;
                    close(): void;
                });

                public close(): void;

                public write(param0: java.nio.ByteBuffer): number;

                public read(param0: java.nio.ByteBuffer): number;

                public isOpen(): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class CancelledKeyException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

declare module java {
    export module nio {
        export module channels {
            export class Channel extends java.lang.Object implements java.io.Closeable {
                /**
                 * Constructs a new instance of the java.nio.channels.Channel interface with the provided implementation.
                 */
                public constructor(implementation: {
                    isOpen(): boolean;
                    close(): void;
                    close(): void;
                    close(): void;
                });

                public close(): void;

                public isOpen(): boolean;
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.channels.ReadableByteChannel.d.ts" />
/// <reference path="./java.nio.channels.WritableByteChannel.d.ts" />
/// <reference path="./java.nio.charset.CharsetDecoder.d.ts" />
/// <reference path="./java.nio.charset.CharsetEncoder.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class Channels extends java.lang.Object {
                public static newChannel(param0: java.io.InputStream): java.nio.channels.ReadableByteChannel;

                public static newOutputStream(param0: java.nio.channels.WritableByteChannel): java.io.OutputStream;

                public static newChannel(param0: java.io.OutputStream): java.nio.channels.WritableByteChannel;

                public static newInputStream(param0: java.nio.channels.ReadableByteChannel): java.io.InputStream;

                public static newWriter(param0: java.nio.channels.WritableByteChannel, param1: java.nio.charset.CharsetEncoder, param2: number): java.io.Writer;
                public static newWriter(param0: java.nio.channels.WritableByteChannel, param1: string): java.io.Writer;

                public static newReader(param0: java.nio.channels.ReadableByteChannel, param1: java.nio.charset.CharsetDecoder, param2: number): java.io.Reader;
                public static newReader(param0: java.nio.channels.ReadableByteChannel, param1: string): java.io.Reader;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class ClosedByInterruptException extends java.nio.channels.AsynchronousCloseException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class ClosedChannelException extends java.io.IOException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class ClosedSelectorException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class ConnectionPendingException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.net.DatagramSocket.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.nio.channels.spi.SelectorProvider.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export abstract class DatagramChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ByteChannel, java.nio.channels.ScatteringByteChannel, java.nio.channels.GatheringByteChannel {
                public socket(): java.net.DatagramSocket;

                public read(param0: native.Array<java.nio.ByteBuffer>): number;

                public close(): void;

                public write(param0: java.nio.ByteBuffer): number;

                public validOps(): number;

                public disconnect(): java.nio.channels.DatagramChannel;

                public constructor(param0: java.nio.channels.spi.SelectorProvider);

                public receive(param0: java.nio.ByteBuffer): java.net.SocketAddress;

                public connect(param0: java.net.SocketAddress): java.nio.channels.DatagramChannel;

                public constructor();

                public isConnected(): boolean;

                public static open(): java.nio.channels.DatagramChannel;

                public read(param0: java.nio.ByteBuffer): number;
                public read(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;

                public write(param0: native.Array<java.nio.ByteBuffer>): number;

                public isOpen(): boolean;

                public write(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;

                public send(param0: java.nio.ByteBuffer, param1: java.net.SocketAddress): number;
            }
        }
    }
}

/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.nio.MappedByteBuffer.d.ts" />
/// <reference path="./java.nio.channels.FileLock.d.ts" />
/// <reference path="./java.nio.channels.ReadableByteChannel.d.ts" />
/// <reference path="./java.nio.channels.WritableByteChannel.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export abstract class FileChannel extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.ByteChannel, java.nio.channels.GatheringByteChannel, java.nio.channels.ScatteringByteChannel {
                public read(param0: native.Array<java.nio.ByteBuffer>): number;

                public write(param0: java.nio.ByteBuffer, param1: number): number;

                public close(): void;

                public write(param0: java.nio.ByteBuffer): number;

                public map(param0: java.nio.channels.FileChannel.MapMode, param1: number, param2: number): java.nio.MappedByteBuffer;

                public transferTo(param0: number, param1: number, param2: java.nio.channels.WritableByteChannel): number;

                public force(param0: boolean): void;

                public lock(param0: number, param1: number, param2: boolean): java.nio.channels.FileLock;

                public constructor();

                public size(): number;

                public position(): number;
                public position(param0: number): java.nio.channels.FileChannel;

                public lock(): java.nio.channels.FileLock;

                public tryLock(): java.nio.channels.FileLock;

                public read(param0: java.nio.ByteBuffer): number;
                public read(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;

                public transferFrom(param0: java.nio.channels.ReadableByteChannel, param1: number, param2: number): number;

                public read(param0: java.nio.ByteBuffer, param1: number): number;

                public write(param0: native.Array<java.nio.ByteBuffer>): number;

                public isOpen(): boolean;

                public truncate(param0: number): java.nio.channels.FileChannel;

                public tryLock(param0: number, param1: number, param2: boolean): java.nio.channels.FileLock;

                public write(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;
            }
            export module FileChannel {
                export class MapMode extends java.lang.Object {
                    public static PRIVATE: java.nio.channels.FileChannel.MapMode;
                    public static READ_ONLY: java.nio.channels.FileChannel.MapMode;
                    public static READ_WRITE: java.nio.channels.FileChannel.MapMode;

                    public toString(): string;
                }
            }
        }
    }
}

/// <reference path="./java.nio.channels.FileChannel.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export abstract class FileLock extends java.lang.Object implements java.lang.AutoCloseable {
                public position(): number;

                public isShared(): boolean;

                public close(): void;

                public release(): void;

                public overlaps(param0: number, param1: number): boolean;

                public constructor(param0: java.nio.channels.FileChannel, param1: number, param2: number, param3: boolean);

                public channel(): java.nio.channels.FileChannel;

                public isValid(): boolean;

                public toString(): string;

                public size(): number;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class FileLockInterruptionException extends java.io.IOException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.nio.ByteBuffer.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class GatheringByteChannel extends java.lang.Object implements java.nio.channels.WritableByteChannel {
                /**
                 * Constructs a new instance of the java.nio.channels.GatheringByteChannel interface with the provided implementation.
                 */
                public constructor(implementation: {
                    write(param0: native.Array<java.nio.ByteBuffer>): number;
                    write(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;
                    write(param0: java.nio.ByteBuffer): number;
                    isOpen(): boolean;
                    close(): void;
                    close(): void;
                    close(): void;
                });

                public close(): void;

                public write(param0: java.nio.ByteBuffer): number;
                public write(param0: native.Array<java.nio.ByteBuffer>): number;

                public isOpen(): boolean;

                public write(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class IllegalBlockingModeException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class IllegalSelectorException extends java.lang.IllegalArgumentException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

declare module java {
    export module nio {
        export module channels {
            export class InterruptibleChannel extends java.lang.Object implements java.nio.channels.Channel {
                /**
                 * Constructs a new instance of the java.nio.channels.InterruptibleChannel interface with the provided implementation.
                 */
                public constructor(implementation: {
                    close(): void;
                    isOpen(): boolean;
                    close(): void;
                    close(): void;
                    close(): void;
                });

                public close(): void;

                public isOpen(): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class NoConnectionPendingException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class NonReadableChannelException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class NonWritableChannelException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class NotYetBoundException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class NotYetConnectedException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class OverlappingFileLockException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.nio.channels.spi.SelectorProvider.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export abstract class Pipe extends java.lang.Object {
                public static open(): java.nio.channels.Pipe;

                public sink(): java.nio.channels.Pipe.SinkChannel;

                public source(): java.nio.channels.Pipe.SourceChannel;

                public constructor();
            }
            export module Pipe {
                export abstract class SinkChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.WritableByteChannel, java.nio.channels.GatheringByteChannel {
                    public constructor(param0: java.nio.channels.spi.SelectorProvider);

                    public validOps(): number;

                    public write(param0: java.nio.ByteBuffer): number;

                    public isOpen(): boolean;

                    public constructor();

                    public write(param0: native.Array<java.nio.ByteBuffer>): number;

                    public close(): void;

                    public write(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;
                }
                export abstract class SourceChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ReadableByteChannel, java.nio.channels.ScatteringByteChannel {
                    public constructor(param0: java.nio.channels.spi.SelectorProvider);

                    public validOps(): number;

                    public isOpen(): boolean;

                    public constructor();

                    public read(param0: java.nio.ByteBuffer): number;
                    public read(param0: native.Array<java.nio.ByteBuffer>): number;

                    public close(): void;

                    public read(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;
                }
            }
        }
    }
}

/// <reference path="./java.nio.ByteBuffer.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class ReadableByteChannel extends java.lang.Object implements java.nio.channels.Channel {
                /**
                 * Constructs a new instance of the java.nio.channels.ReadableByteChannel interface with the provided implementation.
                 */
                public constructor(implementation: {
                    read(param0: java.nio.ByteBuffer): number;
                    isOpen(): boolean;
                    close(): void;
                    close(): void;
                    close(): void;
                });

                public close(): void;

                public read(param0: java.nio.ByteBuffer): number;

                public isOpen(): boolean;
            }
        }
    }
}

/// <reference path="./java.nio.ByteBuffer.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class ScatteringByteChannel extends java.lang.Object implements java.nio.channels.ReadableByteChannel {
                /**
                 * Constructs a new instance of the java.nio.channels.ScatteringByteChannel interface with the provided implementation.
                 */
                public constructor(implementation: {
                    read(param0: native.Array<java.nio.ByteBuffer>): number;
                    read(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;
                    read(param0: java.nio.ByteBuffer): number;
                    isOpen(): boolean;
                    close(): void;
                    close(): void;
                    close(): void;
                });

                public read(param0: native.Array<java.nio.ByteBuffer>): number;

                public close(): void;

                public read(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;
                public read(param0: java.nio.ByteBuffer): number;

                public isOpen(): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.channels.SelectionKey.d.ts" />
/// <reference path="./java.nio.channels.Selector.d.ts" />
/// <reference path="./java.nio.channels.spi.SelectorProvider.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export abstract class SelectableChannel extends java.nio.channels.spi.AbstractInterruptibleChannel implements java.nio.channels.Channel {
                public keyFor(param0: java.nio.channels.Selector): java.nio.channels.SelectionKey;

                public provider(): java.nio.channels.spi.SelectorProvider;

                public close(): void;

                public blockingLock(): java.lang.Object;

                public isBlocking(): boolean;

                public validOps(): number;

                public configureBlocking(param0: boolean): java.nio.channels.SelectableChannel;

                public isOpen(): boolean;

                public register(param0: java.nio.channels.Selector, param1: number, param2: java.lang.Object): java.nio.channels.SelectionKey;

                public isRegistered(): boolean;

                public constructor();

                public register(param0: java.nio.channels.Selector, param1: number): java.nio.channels.SelectionKey;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.channels.SelectableChannel.d.ts" />
/// <reference path="./java.nio.channels.Selector.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export abstract class SelectionKey extends java.lang.Object {
                public static OP_ACCEPT: number;
                public static OP_CONNECT: number;
                public static OP_READ: number;
                public static OP_WRITE: number;

                public isConnectable(): boolean;

                public attachment(): java.lang.Object;

                public isValid(): boolean;

                public isReadable(): boolean;

                public constructor();

                public isAcceptable(): boolean;

                public interestOps(param0: number): java.nio.channels.SelectionKey;

                public readyOps(): number;

                public attach(param0: java.lang.Object): java.lang.Object;

                public interestOps(): number;

                public isWritable(): boolean;

                public cancel(): void;

                public selector(): java.nio.channels.Selector;

                public channel(): java.nio.channels.SelectableChannel;
            }
        }
    }
}

/// <reference path="./java.nio.channels.spi.SelectorProvider.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export abstract class Selector extends java.lang.Object implements java.io.Closeable {
                public provider(): java.nio.channels.spi.SelectorProvider;

                public close(): void;

                public keys(): java.util.Set;

                public select(): number;

                public selectedKeys(): java.util.Set;

                public wakeup(): java.nio.channels.Selector;

                public static open(): java.nio.channels.Selector;

                public isOpen(): boolean;

                public select(param0: number): number;

                public constructor();

                public selectNow(): number;
            }
        }
    }
}

/// <reference path="./java.net.ServerSocket.d.ts" />
/// <reference path="./java.nio.channels.SocketChannel.d.ts" />
/// <reference path="./java.nio.channels.spi.SelectorProvider.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export abstract class ServerSocketChannel extends java.nio.channels.spi.AbstractSelectableChannel {
                public close(): void;

                public validOps(): number;

                public static open(): java.nio.channels.ServerSocketChannel;

                public isOpen(): boolean;

                public accept(): java.nio.channels.SocketChannel;

                public constructor(param0: java.nio.channels.spi.SelectorProvider);

                public socket(): java.net.ServerSocket;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.net.Socket.d.ts" />
/// <reference path="./java.net.SocketAddress.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.nio.channels.spi.SelectorProvider.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export abstract class SocketChannel extends java.nio.channels.spi.AbstractSelectableChannel implements java.nio.channels.ByteChannel, java.nio.channels.ScatteringByteChannel, java.nio.channels.GatheringByteChannel {
                public isConnectionPending(): boolean;

                public read(param0: native.Array<java.nio.ByteBuffer>): number;

                public close(): void;

                public write(param0: java.nio.ByteBuffer): number;

                public validOps(): number;

                public connect(param0: java.net.SocketAddress): boolean;

                public constructor(param0: java.nio.channels.spi.SelectorProvider);

                public finishConnect(): boolean;

                public socket(): java.net.Socket;

                public constructor();

                public isConnected(): boolean;

                public static open(): java.nio.channels.SocketChannel;
                public static open(param0: java.net.SocketAddress): java.nio.channels.SocketChannel;

                public read(param0: java.nio.ByteBuffer): number;
                public read(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;

                public write(param0: native.Array<java.nio.ByteBuffer>): number;

                public isOpen(): boolean;

                public write(param0: native.Array<java.nio.ByteBuffer>, param1: number, param2: number): number;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class UnresolvedAddressException extends java.lang.IllegalArgumentException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class UnsupportedAddressTypeException extends java.lang.IllegalArgumentException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.nio.ByteBuffer.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export class WritableByteChannel extends java.lang.Object implements java.nio.channels.Channel {
                /**
                 * Constructs a new instance of the java.nio.channels.WritableByteChannel interface with the provided implementation.
                 */
                public constructor(implementation: {
                    write(param0: java.nio.ByteBuffer): number;
                    isOpen(): boolean;
                    close(): void;
                    close(): void;
                    close(): void;
                });

                public close(): void;

                public write(param0: java.nio.ByteBuffer): number;

                public isOpen(): boolean;
            }
        }
    }
}

declare module java {
    export module nio {
        export module channels {
            export module spi {
                export abstract class AbstractInterruptibleChannel extends java.lang.Object implements java.nio.channels.Channel, java.nio.channels.InterruptibleChannel {
                    public begin(): void;

                    public isOpen(): boolean;

                    public constructor();

                    public close(): void;

                    public implCloseChannel(): void;

                    public end(param0: boolean): void;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.channels.SelectableChannel.d.ts" />
/// <reference path="./java.nio.channels.SelectionKey.d.ts" />
/// <reference path="./java.nio.channels.Selector.d.ts" />
/// <reference path="./java.nio.channels.spi.SelectorProvider.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export module spi {
                export abstract class AbstractSelectableChannel extends java.nio.channels.SelectableChannel {
                    public constructor(param0: java.nio.channels.spi.SelectorProvider);

                    public provider(): java.nio.channels.spi.SelectorProvider;

                    public blockingLock(): java.lang.Object;

                    public register(param0: java.nio.channels.Selector, param1: number, param2: java.lang.Object): java.nio.channels.SelectionKey;

                    public configureBlocking(param0: boolean): java.nio.channels.SelectableChannel;

                    public register(param0: java.nio.channels.Selector, param1: number): java.nio.channels.SelectionKey;

                    public implCloseSelectableChannel(): void;

                    public isBlocking(): boolean;

                    public isOpen(): boolean;

                    public constructor();

                    public close(): void;

                    public keyFor(param0: java.nio.channels.Selector): java.nio.channels.SelectionKey;

                    public implCloseChannel(): void;

                    public implConfigureBlocking(param0: boolean): void;

                    public isRegistered(): boolean;
                }
            }
        }
    }
}

declare module java {
    export module nio {
        export module channels {
            export module spi {
                export abstract class AbstractSelectionKey extends java.nio.channels.SelectionKey {
                    public constructor();

                    public isValid(): boolean;

                    public cancel(): void;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.channels.SelectionKey.d.ts" />
/// <reference path="./java.nio.channels.spi.AbstractSelectableChannel.d.ts" />
/// <reference path="./java.nio.channels.spi.AbstractSelectionKey.d.ts" />
/// <reference path="./java.nio.channels.spi.SelectorProvider.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export module spi {
                export abstract class AbstractSelector extends java.nio.channels.Selector {
                    public constructor(param0: java.nio.channels.spi.SelectorProvider);

                    public deregister(param0: java.nio.channels.spi.AbstractSelectionKey): void;

                    public begin(): void;

                    public end(): void;

                    public isOpen(): boolean;

                    public constructor();

                    public provider(): java.nio.channels.spi.SelectorProvider;

                    public implCloseSelector(): void;

                    public close(): void;

                    public register(param0: java.nio.channels.spi.AbstractSelectableChannel, param1: number, param2: java.lang.Object): java.nio.channels.SelectionKey;

                    public cancelledKeys(): java.util.Set;
                }
            }
        }
    }
}

/// <reference path="./java.nio.channels.Channel.d.ts" />
/// <reference path="./java.nio.channels.DatagramChannel.d.ts" />
/// <reference path="./java.nio.channels.Pipe.d.ts" />
/// <reference path="./java.nio.channels.ServerSocketChannel.d.ts" />
/// <reference path="./java.nio.channels.SocketChannel.d.ts" />
/// <reference path="./java.nio.channels.spi.AbstractSelector.d.ts" />
declare module java {
    export module nio {
        export module channels {
            export module spi {
                export abstract class SelectorProvider extends java.lang.Object {
                    public constructor();

                    public inheritedChannel(): java.nio.channels.Channel;

                    public static provider(): java.nio.channels.spi.SelectorProvider;

                    public openDatagramChannel(): java.nio.channels.DatagramChannel;

                    public openSelector(): java.nio.channels.spi.AbstractSelector;

                    public openPipe(): java.nio.channels.Pipe;

                    public openSocketChannel(): java.nio.channels.SocketChannel;

                    public openServerSocketChannel(): java.nio.channels.ServerSocketChannel;
                }
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export class CharacterCodingException extends java.io.IOException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
/// <reference path="./java.nio.charset.CharsetDecoder.d.ts" />
/// <reference path="./java.nio.charset.CharsetEncoder.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./java.util.SortedMap.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export abstract class Charset extends java.lang.Object {
                public displayName(): string;

                public encode(param0: java.nio.CharBuffer): java.nio.ByteBuffer;

                public equals(param0: java.lang.Object): boolean;

                public static forName(param0: string): java.nio.charset.Charset;

                public newDecoder(): java.nio.charset.CharsetDecoder;

                public encode(param0: string): java.nio.ByteBuffer;

                public static availableCharsets(): java.util.SortedMap;

                public displayName(param0: java.util.Locale): string;

                public decode(param0: java.nio.ByteBuffer): java.nio.CharBuffer;

                public canEncode(): boolean;

                public isRegistered(): boolean;

                public toString(): string;

                public static defaultCharset(): java.nio.charset.Charset;

                public static isSupported(param0: string): boolean;

                public compareTo(param0: java.nio.charset.Charset): number;

                public constructor(param0: string, param1: native.Array<string>);

                public name(): string;

                public aliases(): java.util.Set;

                public hashCode(): number;

                public contains(param0: java.nio.charset.Charset): boolean;

                public newEncoder(): java.nio.charset.CharsetEncoder;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
/// <reference path="./java.nio.charset.Charset.d.ts" />
/// <reference path="./java.nio.charset.CoderResult.d.ts" />
/// <reference path="./java.nio.charset.CodingErrorAction.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export abstract class CharsetDecoder extends java.lang.Object {
                public isAutoDetecting(): boolean;

                public decode(param0: java.nio.ByteBuffer, param1: java.nio.CharBuffer, param2: boolean): java.nio.charset.CoderResult;

                public detectedCharset(): java.nio.charset.Charset;

                public implReplaceWith(param0: string): void;

                public reset(): java.nio.charset.CharsetDecoder;

                public averageCharsPerByte(): number;

                public decode(param0: java.nio.ByteBuffer): java.nio.CharBuffer;

                public implFlush(param0: java.nio.CharBuffer): java.nio.charset.CoderResult;

                public implOnUnmappableCharacter(param0: java.nio.charset.CodingErrorAction): void;

                public replacement(): string;

                public decodeLoop(param0: java.nio.ByteBuffer, param1: java.nio.CharBuffer): java.nio.charset.CoderResult;

                public charset(): java.nio.charset.Charset;

                public replaceWith(param0: string): java.nio.charset.CharsetDecoder;

                public flush(param0: java.nio.CharBuffer): java.nio.charset.CoderResult;

                public implOnMalformedInput(param0: java.nio.charset.CodingErrorAction): void;

                public malformedInputAction(): java.nio.charset.CodingErrorAction;

                public isCharsetDetected(): boolean;

                public maxCharsPerByte(): number;

                public onMalformedInput(param0: java.nio.charset.CodingErrorAction): java.nio.charset.CharsetDecoder;

                public implReset(): void;

                public unmappableCharacterAction(): java.nio.charset.CodingErrorAction;

                public constructor(param0: java.nio.charset.Charset, param1: number, param2: number);

                public onUnmappableCharacter(param0: java.nio.charset.CodingErrorAction): java.nio.charset.CharsetDecoder;
            }
        }
    }
}

/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.nio.CharBuffer.d.ts" />
/// <reference path="./java.nio.charset.Charset.d.ts" />
/// <reference path="./java.nio.charset.CoderResult.d.ts" />
/// <reference path="./java.nio.charset.CodingErrorAction.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export abstract class CharsetEncoder extends java.lang.Object {
                public encode(param0: java.nio.CharBuffer): java.nio.ByteBuffer;

                public maxBytesPerChar(): number;

                public averageBytesPerChar(): number;

                public implFlush(param0: java.nio.ByteBuffer): java.nio.charset.CoderResult;

                public implOnUnmappableCharacter(param0: java.nio.charset.CodingErrorAction): void;

                public canEncode(param0: string): boolean;

                public encodeLoop(param0: java.nio.CharBuffer, param1: java.nio.ByteBuffer): java.nio.charset.CoderResult;

                public charset(): java.nio.charset.Charset;

                public reset(): java.nio.charset.CharsetEncoder;

                public flush(param0: java.nio.ByteBuffer): java.nio.charset.CoderResult;

                public implOnMalformedInput(param0: java.nio.charset.CodingErrorAction): void;

                public malformedInputAction(): java.nio.charset.CodingErrorAction;

                public replaceWith(param0: native.Array<number>): java.nio.charset.CharsetEncoder;

                public constructor(param0: java.nio.charset.Charset, param1: number, param2: number, param3: native.Array<number>);

                public isLegalReplacement(param0: native.Array<number>): boolean;

                public onMalformedInput(param0: java.nio.charset.CodingErrorAction): java.nio.charset.CharsetEncoder;

                public implReplaceWith(param0: native.Array<number>): void;

                public implReset(): void;

                public unmappableCharacterAction(): java.nio.charset.CodingErrorAction;

                public constructor(param0: java.nio.charset.Charset, param1: number, param2: number);

                public encode(param0: java.nio.CharBuffer, param1: java.nio.ByteBuffer, param2: boolean): java.nio.charset.CoderResult;

                public onUnmappableCharacter(param0: java.nio.charset.CodingErrorAction): java.nio.charset.CharsetEncoder;

                public replacement(): native.Array<number>;
            }
        }
    }
}

/// <reference path="./java.lang.Exception.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export class CoderMalfunctionError extends java.lang.Error {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Exception);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

declare module java {
    export module nio {
        export module charset {
            export class CoderResult extends java.lang.Object {
                public static OVERFLOW: java.nio.charset.CoderResult;
                public static UNDERFLOW: java.nio.charset.CoderResult;

                public isUnmappable(): boolean;

                public isError(): boolean;

                public isOverflow(): boolean;

                public static unmappableForLength(param0: number): java.nio.charset.CoderResult;

                public length(): number;

                public throwException(): void;

                public isUnderflow(): boolean;

                public toString(): string;

                public static malformedForLength(param0: number): java.nio.charset.CoderResult;

                public isMalformed(): boolean;
            }
        }
    }
}

declare module java {
    export module nio {
        export module charset {
            export class CodingErrorAction extends java.lang.Object {
                public static IGNORE: java.nio.charset.CodingErrorAction;
                public static REPLACE: java.nio.charset.CodingErrorAction;
                public static REPORT: java.nio.charset.CodingErrorAction;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export class IllegalCharsetNameException extends java.lang.IllegalArgumentException {
                public getCharsetName(): string;

                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export class MalformedInputException extends java.nio.charset.CharacterCodingException {
                public constructor(param0: number);
                public constructor(param0: string, param1: java.lang.Throwable);

                public getInputLength(): number;

                public getMessage(): string;

                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.nio.charset.Charset.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export class StandardCharsets extends java.lang.Object {
                public static ISO_8859_1: java.nio.charset.Charset;
                public static US_ASCII: java.nio.charset.Charset;
                public static UTF_16: java.nio.charset.Charset;
                public static UTF_16BE: java.nio.charset.Charset;
                public static UTF_16LE: java.nio.charset.Charset;
                public static UTF_8: java.nio.charset.Charset;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export class UnmappableCharacterException extends java.nio.charset.CharacterCodingException {
                public constructor(param0: number);
                public constructor(param0: string, param1: java.lang.Throwable);

                public getInputLength(): number;

                public getMessage(): string;

                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export class UnsupportedCharsetException extends java.lang.IllegalArgumentException {
                public getCharsetName(): string;

                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.charset.Charset.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module nio {
        export module charset {
            export module spi {
                export abstract class CharsetProvider extends java.lang.Object {
                    public constructor();

                    public charsetForName(param0: string): java.nio.charset.Charset;

                    public charsets(): java.util.Iterator;
                }
            }
        }
    }
}

/// <reference path="./java.security.DomainCombiner.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
/// <reference path="./java.security.ProtectionDomain.d.ts" />
declare module java {
    export module security {
        export class AccessControlContext extends java.lang.Object {
            public constructor(param0: native.Array<java.security.ProtectionDomain>);

            public getDomainCombiner(): java.security.DomainCombiner;

            public checkPermission(param0: java.security.Permission): void;

            public constructor(param0: java.security.AccessControlContext, param1: java.security.DomainCombiner);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module security {
        export class AccessControlException extends java.lang.SecurityException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor(param0: string, param1: java.security.Permission);

            public getPermission(): java.security.Permission;

            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.AccessControlContext.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
/// <reference path="./java.security.PrivilegedAction.d.ts" />
/// <reference path="./java.security.PrivilegedExceptionAction.d.ts" />
declare module java {
    export module security {
        export class AccessController extends java.lang.Object {
            public static doPrivilegedWithCombiner(param0: java.security.PrivilegedExceptionAction): java.lang.Object;

            public static doPrivileged(param0: java.security.PrivilegedExceptionAction): java.lang.Object;

            public static doPrivilegedWithCombiner(param0: java.security.PrivilegedAction): java.lang.Object;

            public static getContext(): java.security.AccessControlContext;

            public static doPrivileged(param0: java.security.PrivilegedAction): java.lang.Object;

            public static checkPermission(param0: java.security.Permission): void;

            public static doPrivileged(param0: java.security.PrivilegedAction, param1: java.security.AccessControlContext): java.lang.Object;
            public static doPrivileged(param0: java.security.PrivilegedExceptionAction, param1: java.security.AccessControlContext): java.lang.Object;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.AlgorithmParameterGeneratorSpi.d.ts" />
/// <reference path="./java.security.AlgorithmParameters.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.SecureRandom.d.ts" />
/// <reference path="./java.security.spec.AlgorithmParameterSpec.d.ts" />
declare module java {
    export module security {
        export class AlgorithmParameterGenerator extends java.lang.Object {
            public static getInstance(param0: string, param1: string): java.security.AlgorithmParameterGenerator;

            public init(param0: number, param1: java.security.SecureRandom): void;

            public static getInstance(param0: string): java.security.AlgorithmParameterGenerator;

            public constructor(param0: java.security.AlgorithmParameterGeneratorSpi, param1: java.security.Provider, param2: string);

            public init(param0: java.security.spec.AlgorithmParameterSpec): void;

            public getAlgorithm(): string;

            public static getInstance(param0: string, param1: java.security.Provider): java.security.AlgorithmParameterGenerator;

            public init(param0: java.security.spec.AlgorithmParameterSpec, param1: java.security.SecureRandom): void;
            public init(param0: number): void;

            public getProvider(): java.security.Provider;

            public generateParameters(): java.security.AlgorithmParameters;
        }
    }
}

/// <reference path="./java.security.AlgorithmParameters.d.ts" />
/// <reference path="./java.security.SecureRandom.d.ts" />
/// <reference path="./java.security.spec.AlgorithmParameterSpec.d.ts" />
declare module java {
    export module security {
        export abstract class AlgorithmParameterGeneratorSpi extends java.lang.Object {
            public engineGenerateParameters(): java.security.AlgorithmParameters;

            public engineInit(param0: java.security.spec.AlgorithmParameterSpec, param1: java.security.SecureRandom): void;
            public engineInit(param0: number, param1: java.security.SecureRandom): void;

            public constructor();
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.AlgorithmParametersSpi.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.spec.AlgorithmParameterSpec.d.ts" />
declare module java {
    export module security {
        export class AlgorithmParameters extends java.lang.Object {
            public static getInstance(param0: string, param1: java.security.Provider): java.security.AlgorithmParameters;

            public init(param0: native.Array<number>): void;

            public getEncoded(param0: string): native.Array<number>;

            public constructor(param0: java.security.AlgorithmParametersSpi, param1: java.security.Provider, param2: string);

            public init(param0: java.security.spec.AlgorithmParameterSpec): void;

            public static getInstance(param0: string, param1: string): java.security.AlgorithmParameters;

            public init(param0: native.Array<number>, param1: string): void;

            public getProvider(): java.security.Provider;

            public getEncoded(): native.Array<number>;

            public toString(): string;

            public getAlgorithm(): string;

            public static getInstance(param0: string): java.security.AlgorithmParameters;

            public getParameterSpec(param0: java.lang.Class): java.security.spec.AlgorithmParameterSpec;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.spec.AlgorithmParameterSpec.d.ts" />
declare module java {
    export module security {
        export abstract class AlgorithmParametersSpi extends java.lang.Object {
            public engineInit(param0: native.Array<number>, param1: string): void;

            public engineGetEncoded(): native.Array<number>;

            public engineInit(param0: java.security.spec.AlgorithmParameterSpec): void;

            public engineGetEncoded(param0: string): native.Array<number>;

            public engineToString(): string;

            public constructor();

            public engineInit(param0: native.Array<number>): void;

            public engineGetParameterSpec(param0: java.lang.Class): java.security.spec.AlgorithmParameterSpec;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module security {
        export class AllPermission extends java.security.Permission {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public constructor();

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

import javaxsecurityauthSubject = javax.security.auth.Subject;
import javaxsecurityauthcallbackCallbackHandler = javax.security.auth.callback.CallbackHandler;
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Properties.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./javax.security.auth.Subject.d.ts" />
/// <reference path="./javax.security.auth.callback.CallbackHandler.d.ts" />
declare module java {
    export module security {
        export abstract class AuthProvider extends java.security.Provider {
            public constructor(param0: java.util.Map);

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public constructor(param0: java.util.Properties);

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public constructor(param0: number);

            public logout(): void;

            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public constructor(param0: string, param1: number, param2: string);

            public setCallbackHandler(param0: javaxsecurityauthcallbackCallbackHandler): void;

            public login(param0: javaxsecurityauthSubject, param1: javaxsecurityauthcallbackCallbackHandler): void;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public constructor(param0: number, param1: number);

            public containsKey(param0: java.lang.Object): boolean;

            public hashCode(): number;

            public putAll(param0: java.util.Map): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module security {
        export abstract class BasicPermission extends java.security.Permission implements java.io.Serializable {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.security.Principal.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
declare module java {
    export module security {
        export class Certificate extends java.lang.Object {
            /**
             * Constructs a new instance of the java.security.Certificate interface with the provided implementation.
             */
            public constructor(implementation: {
                decode(param0: java.io.InputStream): void;
                encode(param0: java.io.OutputStream): void;
                getFormat(): string;
                getGuarantor(): java.security.Principal;
                getPrincipal(): java.security.Principal;
                getPublicKey(): java.security.PublicKey;
                toString(param0: boolean): string;
            });

            public decode(param0: java.io.InputStream): void;

            public toString(param0: boolean): string;

            public getPublicKey(): java.security.PublicKey;

            public encode(param0: java.io.OutputStream): void;

            public getGuarantor(): java.security.Principal;

            public toString(): string;

            public getPrincipal(): java.security.Principal;

            public getFormat(): string;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.Timestamp.d.ts" />
/// <reference path="./java.security.cert.CertPath.d.ts" />
declare module java {
    export module security {
        export class CodeSigner extends java.lang.Object implements java.io.Serializable {
            public getTimestamp(): java.security.Timestamp;

            public toString(): string;

            public getSignerCertPath(): java.security.cert.CertPath;

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: java.security.cert.CertPath, param1: java.security.Timestamp);

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.security.CodeSigner.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
declare module java {
    export module security {
        export class CodeSource extends java.lang.Object implements java.io.Serializable {
            public getLocation(): java.net.URL;

            public getCertificates(): native.Array<java.security.cert.Certificate>;

            public constructor(param0: java.net.URL, param1: native.Array<java.security.CodeSigner>);

            public getCodeSigners(): native.Array<java.security.CodeSigner>;

            public constructor(param0: java.net.URL, param1: native.Array<java.security.cert.Certificate>);

            public implies(param0: java.security.CodeSource): boolean;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class DigestException extends java.security.GeneralSecurityException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.security.MessageDigest.d.ts" />
declare module java {
    export module security {
        export class DigestInputStream extends java.io.FilterInputStream {
            public digest: java.security.MessageDigest;

            public toString(): string;

            public setMessageDigest(param0: java.security.MessageDigest): void;

            public read(param0: native.Array<number>): number;

            public getMessageDigest(): java.security.MessageDigest;

            public constructor(param0: java.io.InputStream, param1: java.security.MessageDigest);

            public on(param0: boolean): void;

            public constructor(param0: java.io.InputStream);

            public read(param0: native.Array<number>, param1: number, param2: number): number;

            public constructor();

            public close(): void;

            public read(): number;
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.security.MessageDigest.d.ts" />
declare module java {
    export module security {
        export class DigestOutputStream extends java.io.FilterOutputStream {
            public digest: java.security.MessageDigest;

            public constructor(param0: java.io.OutputStream, param1: java.security.MessageDigest);

            public flush(): void;

            public toString(): string;

            public setMessageDigest(param0: java.security.MessageDigest): void;

            public write(param0: number): void;

            public getMessageDigest(): java.security.MessageDigest;

            public on(param0: boolean): void;

            public constructor(param0: java.io.OutputStream);

            public write(param0: native.Array<number>, param1: number, param2: number): void;

            public constructor();

            public write(param0: native.Array<number>): void;

            public close(): void;
        }
    }
}

/// <reference path="./java.security.ProtectionDomain.d.ts" />
declare module java {
    export module security {
        export class DomainCombiner extends java.lang.Object {
            /**
             * Constructs a new instance of the java.security.DomainCombiner interface with the provided implementation.
             */
            public constructor(implementation: {
                combine(param0: native.Array<java.security.ProtectionDomain>, param1: native.Array<java.security.ProtectionDomain>): native.Array<java.security.ProtectionDomain>;
            });

            public combine(param0: native.Array<java.security.ProtectionDomain>, param1: native.Array<java.security.ProtectionDomain>): native.Array<java.security.ProtectionDomain>;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class GeneralSecurityException extends java.lang.Exception {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module security {
        export class Guard extends java.lang.Object {
            /**
             * Constructs a new instance of the java.security.Guard interface with the provided implementation.
             */
            public constructor(implementation: {
                checkGuard(param0: java.lang.Object): void;
            });

            public checkGuard(param0: java.lang.Object): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.Guard.d.ts" />
declare module java {
    export module security {
        export class GuardedObject extends java.lang.Object implements java.io.Serializable {
            public getObject(): java.lang.Object;

            public constructor(param0: java.lang.Object, param1: java.security.Guard);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Certificate.d.ts" />
/// <reference path="./java.security.IdentityScope.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
declare module java {
    export module security {
        export abstract class Identity extends java.lang.Object implements java.security.Principal, java.io.Serializable {
            public toString(param0: boolean): string;

            public setPublicKey(param0: java.security.PublicKey): void;

            public getPublicKey(): java.security.PublicKey;

            public identityEquals(param0: java.security.Identity): boolean;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public setInfo(param0: string): void;

            public constructor(param0: string, param1: java.security.IdentityScope);

            public getScope(): java.security.IdentityScope;

            public certificates(): native.Array<java.security.Certificate>;

            public toString(): string;

            public getInfo(): string;

            public getName(): string;

            public removeCertificate(param0: java.security.Certificate): void;

            public constructor(param0: string);

            public addCertificate(param0: java.security.Certificate): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Identity.d.ts" />
/// <reference path="./java.security.Principal.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module security {
        export abstract class IdentityScope extends java.security.Identity {
            public toString(param0: boolean): string;

            public static getSystemScope(): java.security.IdentityScope;

            public size(): number;

            public getIdentity(param0: java.security.PublicKey): java.security.Identity;

            public removeIdentity(param0: java.security.Identity): void;

            public addIdentity(param0: java.security.Identity): void;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: string, param1: java.security.IdentityScope);

            public getIdentity(param0: string): java.security.Identity;

            public toString(): string;

            public getIdentity(param0: java.security.Principal): java.security.Identity;

            public getName(): string;

            public static setSystemScope(param0: java.security.IdentityScope): void;

            public identities(): java.util.Enumeration;

            public constructor(param0: string);

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class InvalidAlgorithmParameterException extends java.security.GeneralSecurityException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class InvalidKeyException extends java.security.KeyException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class InvalidParameterException extends java.lang.IllegalArgumentException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

declare module java {
    export module security {
        export class Key extends java.lang.Object implements java.io.Serializable {
            /**
             * Constructs a new instance of the java.security.Key interface with the provided implementation.
             */
            public constructor(implementation: {
                getAlgorithm(): string;
                getFormat(): string;
                getEncoded(): native.Array<number>;
            });

            public static serialVersionUID: number;

            public getAlgorithm(): string;

            public getFormat(): string;

            public getEncoded(): native.Array<number>;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class KeyException extends java.security.GeneralSecurityException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Key.d.ts" />
/// <reference path="./java.security.KeyFactorySpi.d.ts" />
/// <reference path="./java.security.PrivateKey.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.spec.KeySpec.d.ts" />
declare module java {
    export module security {
        export class KeyFactory extends java.lang.Object {
            public constructor(param0: java.security.KeyFactorySpi, param1: java.security.Provider, param2: string);

            public generatePrivate(param0: java.security.spec.KeySpec): java.security.PrivateKey;

            public static getInstance(param0: string, param1: java.security.Provider): java.security.KeyFactory;

            public translateKey(param0: java.security.Key): java.security.Key;

            public static getInstance(param0: string, param1: string): java.security.KeyFactory;

            public getAlgorithm(): string;

            public generatePublic(param0: java.security.spec.KeySpec): java.security.PublicKey;

            public static getInstance(param0: string): java.security.KeyFactory;

            public getKeySpec(param0: java.security.Key, param1: java.lang.Class): java.security.spec.KeySpec;

            public getProvider(): java.security.Provider;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.security.Key.d.ts" />
/// <reference path="./java.security.PrivateKey.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.spec.KeySpec.d.ts" />
declare module java {
    export module security {
        export abstract class KeyFactorySpi extends java.lang.Object {
            public engineGetKeySpec(param0: java.security.Key, param1: java.lang.Class): java.security.spec.KeySpec;

            public engineGeneratePrivate(param0: java.security.spec.KeySpec): java.security.PrivateKey;

            public engineGeneratePublic(param0: java.security.spec.KeySpec): java.security.PublicKey;

            public engineTranslateKey(param0: java.security.Key): java.security.Key;

            public constructor();
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class KeyManagementException extends java.security.KeyException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.security.PrivateKey.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
declare module java {
    export module security {
        export class KeyPair extends java.lang.Object implements java.io.Serializable {
            public constructor(param0: java.security.PublicKey, param1: java.security.PrivateKey);

            public getPublic(): java.security.PublicKey;

            public getPrivate(): java.security.PrivateKey;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.KeyPair.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.SecureRandom.d.ts" />
/// <reference path="./java.security.spec.AlgorithmParameterSpec.d.ts" />
declare module java {
    export module security {
        export abstract class KeyPairGenerator extends java.security.KeyPairGeneratorSpi {
            public static getInstance(param0: string, param1: string): java.security.KeyPairGenerator;

            public initialize(param0: java.security.spec.AlgorithmParameterSpec): void;
            public initialize(param0: java.security.spec.AlgorithmParameterSpec, param1: java.security.SecureRandom): void;

            public static getInstance(param0: string): java.security.KeyPairGenerator;

            public constructor();

            public static getInstance(param0: string, param1: java.security.Provider): java.security.KeyPairGenerator;

            public generateKeyPair(): java.security.KeyPair;

            public getProvider(): java.security.Provider;

            public initialize(param0: number, param1: java.security.SecureRandom): void;

            public getAlgorithm(): string;

            public initialize(param0: number): void;

            public genKeyPair(): java.security.KeyPair;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.security.KeyPair.d.ts" />
/// <reference path="./java.security.SecureRandom.d.ts" />
/// <reference path="./java.security.spec.AlgorithmParameterSpec.d.ts" />
declare module java {
    export module security {
        export abstract class KeyPairGeneratorSpi extends java.lang.Object {
            public initialize(param0: number, param1: java.security.SecureRandom): void;
            public initialize(param0: java.security.spec.AlgorithmParameterSpec, param1: java.security.SecureRandom): void;

            public constructor();

            public generateKeyPair(): java.security.KeyPair;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module security {
        export class KeyRep extends java.lang.Object implements java.io.Serializable {
            public readResolve(): java.lang.Object;

            public constructor(param0: java.security.KeyRep.Type, param1: string, param2: string, param3: native.Array<number>);
        }
        export module KeyRep {
            export class Type extends java.lang.Enum {
                public static PRIVATE: java.security.KeyRep.Type;
                public static PUBLIC: java.security.KeyRep.Type;
                public static SECRET: java.security.KeyRep.Type;

                public static values(): native.Array<java.security.KeyRep.Type>;

                public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
                public static valueOf(param0: string): java.security.KeyRep.Type;
            }
        }
    }
}

import javaxsecurityauthDestroyable = javax.security.auth.Destroyable;
/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Key.d.ts" />
/// <reference path="./java.security.KeyStore.d.ts" />
/// <reference path="./java.security.KeyStoreSpi.d.ts" />
/// <reference path="./java.security.PrivateKey.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./javax.crypto.SecretKey.d.ts" />
/// <reference path="./javax.security.auth.callback.CallbackHandler.d.ts" />
declare module java {
    export module security {
        export class KeyStore extends java.lang.Object {
            public static getDefaultType(): string;

            public setKeyEntry(param0: string, param1: native.Array<number>, param2: native.Array<java.security.cert.Certificate>): void;

            public constructor(param0: java.security.KeyStoreSpi, param1: java.security.Provider, param2: string);

            public store(param0: java.io.OutputStream, param1: native.Array<string>): void;

            public getKey(param0: string, param1: native.Array<string>): java.security.Key;

            public getCreationDate(param0: string): java.util.Date;

            public containsAlias(param0: string): boolean;

            public load(param0: java.io.InputStream, param1: native.Array<string>): void;

            public getCertificateChain(param0: string): native.Array<java.security.cert.Certificate>;

            public setEntry(param0: string, param1: java.security.KeyStore.Entry, param2: java.security.KeyStore.ProtectionParameter): void;

            public getType(): string;

            public static getInstance(param0: string, param1: java.security.Provider): java.security.KeyStore;

            public getCertificateAlias(param0: java.security.cert.Certificate): string;

            public setKeyEntry(param0: string, param1: java.security.Key, param2: native.Array<string>, param3: native.Array<java.security.cert.Certificate>): void;

            public size(): number;

            public static getInstance(param0: string, param1: string): java.security.KeyStore;

            public aliases(): java.util.Enumeration;

            public getEntry(param0: string, param1: java.security.KeyStore.ProtectionParameter): java.security.KeyStore.Entry;

            public entryInstanceOf(param0: string, param1: java.lang.Class): boolean;

            public store(param0: java.security.KeyStore.LoadStoreParameter): void;

            public setCertificateEntry(param0: string, param1: java.security.cert.Certificate): void;

            public getProvider(): java.security.Provider;

            public getCertificate(param0: string): java.security.cert.Certificate;

            public deleteEntry(param0: string): void;

            public isKeyEntry(param0: string): boolean;

            public static getInstance(param0: string): java.security.KeyStore;

            public load(param0: java.security.KeyStore.LoadStoreParameter): void;

            public isCertificateEntry(param0: string): boolean;
        }
        export module KeyStore {
            export abstract class Builder extends java.lang.Object {
                public static newInstance(param0: string, param1: java.security.Provider, param2: java.io.File, param3: java.security.KeyStore.ProtectionParameter): java.security.KeyStore.Builder;
                public static newInstance(param0: string, param1: java.security.Provider, param2: java.security.KeyStore.ProtectionParameter): java.security.KeyStore.Builder;

                public getProtectionParameter(param0: string): java.security.KeyStore.ProtectionParameter;

                public getKeyStore(): java.security.KeyStore;

                public static newInstance(param0: java.security.KeyStore, param1: java.security.KeyStore.ProtectionParameter): java.security.KeyStore.Builder;

                public constructor();
            }
            export class CallbackHandlerProtection extends java.lang.Object implements java.security.KeyStore.ProtectionParameter {
                public getCallbackHandler(): javaxsecurityauthcallbackCallbackHandler;

                public constructor(param0: javaxsecurityauthcallbackCallbackHandler);
            }
            export class Entry extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.KeyStore$Entry interface with the provided implementation.
                 */
                public constructor(implementation: {});
            }
            export class LoadStoreParameter extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.KeyStore$LoadStoreParameter interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getProtectionParameter(): java.security.KeyStore.ProtectionParameter;
                });

                public getProtectionParameter(): java.security.KeyStore.ProtectionParameter;
            }
            export class PasswordProtection extends java.lang.Object implements java.security.KeyStore.ProtectionParameter, javaxsecurityauthDestroyable {
                public destroy(): void;

                public getPassword(): native.Array<string>;

                public isDestroyed(): boolean;

                public constructor(param0: native.Array<string>);
            }
            export class PrivateKeyEntry extends java.lang.Object implements java.security.KeyStore.Entry {
                public getCertificateChain(): native.Array<java.security.cert.Certificate>;

                public getCertificate(): java.security.cert.Certificate;

                public getPrivateKey(): java.security.PrivateKey;

                public constructor(param0: java.security.PrivateKey, param1: native.Array<java.security.cert.Certificate>);

                public toString(): string;
            }
            export class ProtectionParameter extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.KeyStore$ProtectionParameter interface with the provided implementation.
                 */
                public constructor(implementation: {});
            }
            export class SecretKeyEntry extends java.lang.Object implements java.security.KeyStore.Entry {
                public getSecretKey(): javaxcryptoSecretKey;

                public constructor(param0: javaxcryptoSecretKey);

                public toString(): string;
            }
            export class TrustedCertificateEntry extends java.lang.Object implements java.security.KeyStore.Entry {
                public getTrustedCertificate(): java.security.cert.Certificate;

                public constructor(param0: java.security.cert.Certificate);

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class KeyStoreException extends java.security.GeneralSecurityException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Key.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module security {
        export abstract class KeyStoreSpi extends java.lang.Object {
            public engineGetCreationDate(param0: string): java.util.Date;

            public engineEntryInstanceOf(param0: string, param1: java.lang.Class): boolean;

            public engineGetCertificateChain(param0: string): native.Array<java.security.cert.Certificate>;

            public engineContainsAlias(param0: string): boolean;

            public constructor();

            public engineSetCertificateEntry(param0: string, param1: java.security.cert.Certificate): void;

            public engineLoad(param0: java.io.InputStream, param1: native.Array<string>): void;

            public engineGetEntry(param0: string, param1: java.security.KeyStore.ProtectionParameter): java.security.KeyStore.Entry;

            public engineStore(param0: java.io.OutputStream, param1: native.Array<string>): void;

            public engineAliases(): java.util.Enumeration;

            public engineSetKeyEntry(param0: string, param1: java.security.Key, param2: native.Array<string>, param3: native.Array<java.security.cert.Certificate>): void;

            public engineSetEntry(param0: string, param1: java.security.KeyStore.Entry, param2: java.security.KeyStore.ProtectionParameter): void;

            public engineSetKeyEntry(param0: string, param1: native.Array<number>, param2: native.Array<java.security.cert.Certificate>): void;

            public engineGetCertificateAlias(param0: java.security.cert.Certificate): string;

            public engineGetKey(param0: string, param1: native.Array<string>): java.security.Key;

            public engineDeleteEntry(param0: string): void;

            public engineSize(): number;

            public engineIsCertificateEntry(param0: string): boolean;

            public engineStore(param0: java.security.KeyStore.LoadStoreParameter): void;

            public engineLoad(param0: java.security.KeyStore.LoadStoreParameter): void;

            public engineGetCertificate(param0: string): java.security.cert.Certificate;

            public engineIsKeyEntry(param0: string): boolean;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
declare module java {
    export module security {
        export abstract class MessageDigest extends java.security.MessageDigestSpi {
            public update(param0: number): void;

            public digest(param0: native.Array<number>): native.Array<number>;

            public static isEqual(param0: native.Array<number>, param1: native.Array<number>): boolean;

            public update(param0: java.nio.ByteBuffer): void;

            public digest(param0: native.Array<number>, param1: number, param2: number): number;

            public static getInstance(param0: string, param1: java.security.Provider): java.security.MessageDigest;

            public constructor();

            public digest(): native.Array<number>;

            public getProvider(): java.security.Provider;

            public update(param0: native.Array<number>): void;

            public toString(): string;

            public getDigestLength(): number;

            public static getInstance(param0: string): java.security.MessageDigest;

            public reset(): void;

            public getAlgorithm(): string;

            public update(param0: native.Array<number>, param1: number, param2: number): void;

            public static getInstance(param0: string, param1: string): java.security.MessageDigest;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
declare module java {
    export module security {
        export abstract class MessageDigestSpi extends java.lang.Object {
            public engineUpdate(param0: java.nio.ByteBuffer): void;

            public engineGetDigestLength(): number;

            public engineUpdate(param0: native.Array<number>, param1: number, param2: number): void;

            public engineDigest(): native.Array<number>;
            public engineDigest(param0: native.Array<number>, param1: number, param2: number): number;

            public engineUpdate(param0: number): void;

            public engineReset(): void;

            public constructor();

            public clone(): java.lang.Object;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class NoSuchAlgorithmException extends java.security.GeneralSecurityException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class NoSuchProviderException extends java.security.GeneralSecurityException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.PermissionCollection.d.ts" />
declare module java {
    export module security {
        export abstract class Permission extends java.lang.Object implements java.security.Guard, java.io.Serializable {
            public getName(): string;

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);

            public newPermissionCollection(): java.security.PermissionCollection;
        }
    }
}

/// <reference path="./java.security.Permission.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module security {
        export abstract class PermissionCollection extends java.lang.Object implements java.io.Serializable {
            public isReadOnly(): boolean;

            public setReadOnly(): void;

            public elements(): java.util.Enumeration;

            public implies(param0: java.security.Permission): boolean;

            public constructor();

            public add(param0: java.security.Permission): void;
        }
    }
}

/// <reference path="./java.security.Permission.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module security {
        export class Permissions extends java.security.PermissionCollection implements java.io.Serializable {
            public elements(): java.util.Enumeration;

            public implies(param0: java.security.Permission): boolean;

            public constructor();

            public add(param0: java.security.Permission): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.CodeSource.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
/// <reference path="./java.security.PermissionCollection.d.ts" />
/// <reference path="./java.security.ProtectionDomain.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
declare module java {
    export module security {
        export abstract class Policy extends java.lang.Object {
            public static UNSUPPORTED_EMPTY_COLLECTION: java.security.PermissionCollection;

            public refresh(): void;

            public implies(param0: java.security.ProtectionDomain, param1: java.security.Permission): boolean;

            public static getPolicy(): java.security.Policy;

            public getPermissions(param0: java.security.CodeSource): java.security.PermissionCollection;

            public static getInstance(param0: string, param1: java.security.Policy.Parameters, param2: string): java.security.Policy;

            public getParameters(): java.security.Policy.Parameters;

            public constructor();

            public static getInstance(param0: string, param1: java.security.Policy.Parameters): java.security.Policy;

            public getProvider(): java.security.Provider;

            public getPermissions(param0: java.security.ProtectionDomain): java.security.PermissionCollection;

            public static setPolicy(param0: java.security.Policy): void;

            public static getInstance(param0: string, param1: java.security.Policy.Parameters, param2: java.security.Provider): java.security.Policy;

            public getType(): string;
        }
        export module Policy {
            export class Parameters extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.Policy$Parameters interface with the provided implementation.
                 */
                public constructor(implementation: {});
            }
        }
    }
}

/// <reference path="./java.security.CodeSource.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
/// <reference path="./java.security.PermissionCollection.d.ts" />
/// <reference path="./java.security.ProtectionDomain.d.ts" />
declare module java {
    export module security {
        export abstract class PolicySpi extends java.lang.Object {
            public engineImplies(param0: java.security.ProtectionDomain, param1: java.security.Permission): boolean;

            public engineRefresh(): void;

            public engineGetPermissions(param0: java.security.CodeSource): java.security.PermissionCollection;

            public constructor();

            public engineGetPermissions(param0: java.security.ProtectionDomain): java.security.PermissionCollection;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module security {
        export class Principal extends java.lang.Object {
            /**
             * Constructs a new instance of the java.security.Principal interface with the provided implementation.
             */
            public constructor(implementation: {
                equals(param0: java.lang.Object): boolean;
                getName(): string;
                hashCode(): number;
                toString(): string;
            });

            public toString(): string;

            public getName(): string;

            public equals(param0: java.lang.Object): boolean;

            public hashCode(): number;
        }
    }
}

declare module java {
    export module security {
        export class PrivateKey extends java.lang.Object implements java.security.Key {
            /**
             * Constructs a new instance of the java.security.PrivateKey interface with the provided implementation.
             */
            public constructor(implementation: {
                getAlgorithm(): string;
                getFormat(): string;
                getEncoded(): native.Array<number>;
            });

            public static serialVersionUID: number;

            public getAlgorithm(): string;

            public getFormat(): string;

            public getEncoded(): native.Array<number>;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module security {
        export class PrivilegedAction extends java.lang.Object {
            /**
             * Constructs a new instance of the java.security.PrivilegedAction interface with the provided implementation.
             */
            public constructor(implementation: {
                run(): java.lang.Object;
            });

            public run(): java.lang.Object;
        }
    }
}

/// <reference path="./java.lang.Exception.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class PrivilegedActionException extends java.lang.Exception {
            public getException(): java.lang.Exception;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: java.lang.Exception);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module security {
        export class PrivilegedExceptionAction extends java.lang.Object {
            /**
             * Constructs a new instance of the java.security.PrivilegedExceptionAction interface with the provided implementation.
             */
            public constructor(implementation: {
                run(): java.lang.Object;
            });

            public run(): java.lang.Object;
        }
    }
}

/// <reference path="./java.lang.ClassLoader.d.ts" />
/// <reference path="./java.security.CodeSource.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
/// <reference path="./java.security.PermissionCollection.d.ts" />
/// <reference path="./java.security.Principal.d.ts" />
declare module java {
    export module security {
        export class ProtectionDomain extends java.lang.Object {
            public getClassLoader(): java.lang.ClassLoader;

            public constructor(param0: java.security.CodeSource, param1: java.security.PermissionCollection);
            public constructor(param0: java.security.CodeSource, param1: java.security.PermissionCollection, param2: java.lang.ClassLoader, param3: native.Array<java.security.Principal>);

            public implies(param0: java.security.Permission): boolean;

            public getPermissions(): java.security.PermissionCollection;

            public getCodeSource(): java.security.CodeSource;

            public getPrincipals(): native.Array<java.security.Principal>;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Properties.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module security {
        export abstract class Provider extends java.util.Properties {
            public constructor(param0: java.util.Map);
            public constructor(param0: java.util.Properties);

            public equals(param0: java.lang.Object): boolean;

            public values(): java.util.Collection;

            public getVersion(): number;

            public putService(param0: java.security.Provider.Service): void;

            public load(param0: java.io.Reader): void;

            public constructor(param0: number, param1: number);

            public getServices(): java.util.Set;

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public constructor(param0: number);
            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public constructor(param0: string, param1: number, param2: string);

            public removeService(param0: java.security.Provider.Service): void;

            public toString(): string;

            public getName(): string;

            public getInfo(): string;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public getService(param0: string, param1: string): java.security.Provider.Service;

            public load(param0: java.io.InputStream): void;

            public containsKey(param0: java.lang.Object): boolean;

            public putAll(param0: java.util.Map): void;

            public hashCode(): number;
        }
        export module Provider {
            export class Service extends java.lang.Object {
                public getAlgorithm(): string;

                public getAttribute(param0: string): string;

                public constructor(param0: java.security.Provider, param1: string, param2: string, param3: string, param4: java.util.List, param5: java.util.Map);

                public getType(): string;

                public getClassName(): string;

                public newInstance(param0: java.lang.Object): java.lang.Object;

                public supportsParameter(param0: java.lang.Object): boolean;

                public getProvider(): java.security.Provider;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class ProviderException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

declare module java {
    export module security {
        export class PublicKey extends java.lang.Object implements java.security.Key {
            /**
             * Constructs a new instance of the java.security.PublicKey interface with the provided implementation.
             */
            public constructor(implementation: {
                getAlgorithm(): string;
                getFormat(): string;
                getEncoded(): native.Array<number>;
            });

            public static serialVersionUID: number;

            public getAlgorithm(): string;

            public getFormat(): string;

            public getEncoded(): native.Array<number>;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.ClassLoader.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.security.CodeSource.d.ts" />
/// <reference path="./java.security.PermissionCollection.d.ts" />
/// <reference path="./java.security.ProtectionDomain.d.ts" />
declare module java {
    export module security {
        export class SecureClassLoader extends java.lang.ClassLoader {
            public defineClass(param0: string, param1: native.Array<number>, param2: number, param3: number, param4: java.security.ProtectionDomain): java.lang.Class;

            public getPermissions(param0: java.security.CodeSource): java.security.PermissionCollection;

            public constructor(param0: java.lang.ClassLoader);
            public constructor();

            public defineClass(param0: string, param1: native.Array<number>, param2: number, param3: number): java.lang.Class;
            public defineClass(param0: string, param1: native.Array<number>, param2: number, param3: number, param4: java.security.CodeSource): java.lang.Class;
            public defineClass(param0: string, param1: java.nio.ByteBuffer, param2: java.security.ProtectionDomain): java.lang.Class;
            public defineClass(param0: native.Array<number>, param1: number, param2: number): java.lang.Class;
            public defineClass(param0: string, param1: java.nio.ByteBuffer, param2: java.security.CodeSource): java.lang.Class;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.SecureRandomSpi.d.ts" />
declare module java {
    export module security {
        export class SecureRandom extends java.util.Random {
            public setSeed(param0: native.Array<number>): void;

            public static getInstance(param0: string, param1: java.security.Provider): java.security.SecureRandom;

            public setSeed(param0: number): void;

            public nextBytes(param0: native.Array<number>): void;

            public static getInstance(param0: string, param1: string): java.security.SecureRandom;

            public constructor(param0: number);

            public generateSeed(param0: number): native.Array<number>;

            public constructor();
            public constructor(param0: native.Array<number>);

            public next(param0: number): number;

            public getProvider(): java.security.Provider;

            public constructor(param0: java.security.SecureRandomSpi, param1: java.security.Provider);

            public static getSeed(param0: number): native.Array<number>;

            public getAlgorithm(): string;

            public static getInstance(param0: string): java.security.SecureRandom;
        }
    }
}

declare module java {
    export module security {
        export abstract class SecureRandomSpi extends java.lang.Object implements java.io.Serializable {
            public engineGenerateSeed(param0: number): native.Array<number>;

            public engineNextBytes(param0: native.Array<number>): void;

            public engineSetSeed(param0: native.Array<number>): void;

            public constructor();
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module security {
        export class Security extends java.lang.Object {
            public static insertProviderAt(param0: java.security.Provider, param1: number): number;

            public static getAlgorithms(param0: string): java.util.Set;

            public static setProperty(param0: string, param1: string): void;

            public static getProvider(param0: string): java.security.Provider;

            public static getAlgorithmProperty(param0: string, param1: string): string;

            public static getProperty(param0: string): string;

            public static getProviders(param0: string): native.Array<java.security.Provider>;
            public static getProviders(param0: java.util.Map): native.Array<java.security.Provider>;

            public static addProvider(param0: java.security.Provider): number;

            public static getProviders(): native.Array<java.security.Provider>;

            public static removeProvider(param0: string): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module security {
        export class SecurityPermission extends java.security.BasicPermission {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.security.AlgorithmParameters.d.ts" />
/// <reference path="./java.security.PrivateKey.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.SecureRandom.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
/// <reference path="./java.security.spec.AlgorithmParameterSpec.d.ts" />
declare module java {
    export module security {
        export abstract class Signature extends java.security.SignatureSpi {
            public static SIGN: number;
            public static UNINITIALIZED: number;
            public static VERIFY: number;
            public state: number;

            public update(param0: number): void;

            public getParameters(): java.security.AlgorithmParameters;

            public static getInstance(param0: string): java.security.Signature;

            public update(param0: java.nio.ByteBuffer): void;

            public sign(param0: native.Array<number>, param1: number, param2: number): number;

            public verify(param0: native.Array<number>): boolean;

            public getParameter(param0: string): java.lang.Object;

            public constructor();

            public initSign(param0: java.security.PrivateKey, param1: java.security.SecureRandom): void;

            public getProvider(): java.security.Provider;

            public setParameter(param0: java.security.spec.AlgorithmParameterSpec): void;

            public update(param0: native.Array<number>): void;

            public initVerify(param0: java.security.cert.Certificate): void;

            public toString(): string;

            public static getInstance(param0: string, param1: java.security.Provider): java.security.Signature;

            public setParameter(param0: string, param1: java.lang.Object): void;

            public getAlgorithm(): string;

            public sign(): native.Array<number>;

            public static getInstance(param0: string, param1: string): java.security.Signature;

            public update(param0: native.Array<number>, param1: number, param2: number): void;

            public initVerify(param0: java.security.PublicKey): void;

            public verify(param0: native.Array<number>, param1: number, param2: number): boolean;

            public constructor(param0: string);

            public initSign(param0: java.security.PrivateKey): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class SignatureException extends java.security.GeneralSecurityException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.security.AlgorithmParameters.d.ts" />
/// <reference path="./java.security.PrivateKey.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.SecureRandom.d.ts" />
/// <reference path="./java.security.spec.AlgorithmParameterSpec.d.ts" />
declare module java {
    export module security {
        export abstract class SignatureSpi extends java.lang.Object {
            public appRandom: java.security.SecureRandom;

            public engineSign(): native.Array<number>;

            public engineSetParameter(param0: string, param1: java.lang.Object): void;

            public engineUpdate(param0: native.Array<number>, param1: number, param2: number): void;
            public engineUpdate(param0: number): void;

            public constructor();

            public engineVerify(param0: native.Array<number>): boolean;

            public engineInitSign(param0: java.security.PrivateKey, param1: java.security.SecureRandom): void;

            public engineVerify(param0: native.Array<number>, param1: number, param2: number): boolean;

            public engineGetParameter(param0: string): java.lang.Object;

            public engineUpdate(param0: java.nio.ByteBuffer): void;

            public engineSetParameter(param0: java.security.spec.AlgorithmParameterSpec): void;

            public engineInitVerify(param0: java.security.PublicKey): void;

            public engineInitSign(param0: java.security.PrivateKey): void;

            public engineSign(param0: native.Array<number>, param1: number, param2: number): number;

            public engineGetParameters(): java.security.AlgorithmParameters;

            public clone(): java.lang.Object;
        }
    }
}

/// <reference path="./java.io.Serializable.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.PrivateKey.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.Signature.d.ts" />
declare module java {
    export module security {
        export class SignedObject extends java.lang.Object implements java.io.Serializable {
            public getObject(): java.lang.Object;

            public getAlgorithm(): string;

            public verify(param0: java.security.PublicKey, param1: java.security.Signature): boolean;

            public constructor(param0: java.io.Serializable, param1: java.security.PrivateKey, param2: java.security.Signature);

            public getSignature(): native.Array<number>;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.IdentityScope.d.ts" />
/// <reference path="./java.security.KeyPair.d.ts" />
/// <reference path="./java.security.PrivateKey.d.ts" />
declare module java {
    export module security {
        export abstract class Signer extends java.security.Identity {
            public getPrivateKey(): java.security.PrivateKey;

            public toString(param0: boolean): string;
            public toString(): string;

            public getName(): string;

            public setKeyPair(param0: java.security.KeyPair): void;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: string);
            public constructor(param0: string, param1: java.security.IdentityScope);

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.cert.CertPath.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
declare module java {
    export module security {
        export class Timestamp extends java.lang.Object implements java.io.Serializable {
            public toString(): string;

            public getSignerCertPath(): java.security.cert.CertPath;

            public getTimestamp(): java.util.Date;

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: java.util.Date, param1: java.security.cert.CertPath);

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class UnrecoverableEntryException extends java.security.GeneralSecurityException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export class UnrecoverableKeyException extends java.security.UnrecoverableEntryException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
declare module java {
    export module security {
        export class UnresolvedPermission extends java.security.Permission implements java.io.Serializable {
            public getUnresolvedCerts(): native.Array<java.security.cert.Certificate>;

            public getUnresolvedName(): string;

            public getUnresolvedType(): string;

            public constructor(param0: string, param1: string, param2: string, param3: native.Array<java.security.cert.Certificate>);

            public getUnresolvedActions(): string;

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Principal.d.ts" />
/// <reference path="./java.security.acl.AclEntry.d.ts" />
/// <reference path="./java.security.acl.Permission.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module security {
        export module acl {
            export class Acl extends java.lang.Object implements java.security.acl.Owner {
                /**
                 * Constructs a new instance of the java.security.acl.Acl interface with the provided implementation.
                 */
                public constructor(implementation: {
                    setName(param0: java.security.Principal, param1: string): void;
                    getName(): string;
                    addEntry(param0: java.security.Principal, param1: java.security.acl.AclEntry): boolean;
                    removeEntry(param0: java.security.Principal, param1: java.security.acl.AclEntry): boolean;
                    getPermissions(param0: java.security.Principal): java.util.Enumeration;
                    entries(): java.util.Enumeration;
                    checkPermission(param0: java.security.Principal, param1: java.security.acl.Permission): boolean;
                    toString(): string;
                    addOwner(param0: java.security.Principal, param1: java.security.Principal): boolean;
                    deleteOwner(param0: java.security.Principal, param1: java.security.Principal): boolean;
                    isOwner(param0: java.security.Principal): boolean;
                });

                public entries(): java.util.Enumeration;

                public deleteOwner(param0: java.security.Principal, param1: java.security.Principal): boolean;

                public isOwner(param0: java.security.Principal): boolean;

                public addOwner(param0: java.security.Principal, param1: java.security.Principal): boolean;

                public addEntry(param0: java.security.Principal, param1: java.security.acl.AclEntry): boolean;

                public removeEntry(param0: java.security.Principal, param1: java.security.acl.AclEntry): boolean;

                public checkPermission(param0: java.security.Principal, param1: java.security.acl.Permission): boolean;

                public setName(param0: java.security.Principal, param1: string): void;

                public getName(): string;

                public toString(): string;

                public getPermissions(param0: java.security.Principal): java.util.Enumeration;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.Principal.d.ts" />
/// <reference path="./java.security.acl.Permission.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module security {
        export module acl {
            export class AclEntry extends java.lang.Object implements java.lang.Cloneable {
                /**
                 * Constructs a new instance of the java.security.acl.AclEntry interface with the provided implementation.
                 */
                public constructor(implementation: {
                    setPrincipal(param0: java.security.Principal): boolean;
                    getPrincipal(): java.security.Principal;
                    setNegativePermissions(): void;
                    isNegative(): boolean;
                    addPermission(param0: java.security.acl.Permission): boolean;
                    removePermission(param0: java.security.acl.Permission): boolean;
                    checkPermission(param0: java.security.acl.Permission): boolean;
                    permissions(): java.util.Enumeration;
                    toString(): string;
                    clone(): java.lang.Object;
                });

                public addPermission(param0: java.security.acl.Permission): boolean;

                public checkPermission(param0: java.security.acl.Permission): boolean;

                public setNegativePermissions(): void;

                public setPrincipal(param0: java.security.Principal): boolean;

                public isNegative(): boolean;

                public removePermission(param0: java.security.acl.Permission): boolean;

                public toString(): string;

                public getPrincipal(): java.security.Principal;

                public clone(): java.lang.Object;

                public permissions(): java.util.Enumeration;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module acl {
            export class AclNotFoundException extends java.lang.Exception {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.Principal.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module security {
        export module acl {
            export class Group extends java.lang.Object implements java.security.Principal {
                /**
                 * Constructs a new instance of the java.security.acl.Group interface with the provided implementation.
                 */
                public constructor(implementation: {
                    addMember(param0: java.security.Principal): boolean;
                    removeMember(param0: java.security.Principal): boolean;
                    isMember(param0: java.security.Principal): boolean;
                    members(): java.util.Enumeration;
                    equals(param0: java.lang.Object): boolean;
                    getName(): string;
                    hashCode(): number;
                    toString(): string;
                });

                public equals(param0: java.lang.Object): boolean;

                public addMember(param0: java.security.Principal): boolean;

                public removeMember(param0: java.security.Principal): boolean;

                public hashCode(): number;

                public getName(): string;

                public isMember(param0: java.security.Principal): boolean;

                public members(): java.util.Enumeration;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module acl {
            export class LastOwnerException extends java.lang.Exception {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module acl {
            export class NotOwnerException extends java.lang.Exception {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.security.Principal.d.ts" />
declare module java {
    export module security {
        export module acl {
            export class Owner extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.acl.Owner interface with the provided implementation.
                 */
                public constructor(implementation: {
                    addOwner(param0: java.security.Principal, param1: java.security.Principal): boolean;
                    deleteOwner(param0: java.security.Principal, param1: java.security.Principal): boolean;
                    isOwner(param0: java.security.Principal): boolean;
                });

                public deleteOwner(param0: java.security.Principal, param1: java.security.Principal): boolean;

                public isOwner(param0: java.security.Principal): boolean;

                public addOwner(param0: java.security.Principal, param1: java.security.Principal): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module security {
        export module acl {
            export class Permission extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.acl.Permission interface with the provided implementation.
                 */
                public constructor(implementation: {
                    equals(param0: java.lang.Object): boolean;
                    toString(): string;
                });

                public equals(param0: java.lang.Object): boolean;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class CRL extends java.lang.Object {
                public getType(): string;

                public isRevoked(param0: java.security.cert.Certificate): boolean;

                public toString(): string;

                public constructor(param0: string);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CRLException extends java.security.GeneralSecurityException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.cert.CRL.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CRLSelector extends java.lang.Object implements java.lang.Cloneable {
                /**
                 * Constructs a new instance of the java.security.cert.CRLSelector interface with the provided implementation.
                 */
                public constructor(implementation: {
                    clone(): java.lang.Object;
                    match(param0: java.security.cert.CRL): boolean;
                });

                public match(param0: java.security.cert.CRL): boolean;

                public clone(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class CertPath extends java.lang.Object implements java.io.Serializable {
                public getType(): string;

                public getCertificates(): java.util.List;

                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public getEncoded(): native.Array<number>;
                public getEncoded(param0: string): native.Array<number>;

                public toString(): string;

                public writeReplace(): java.lang.Object;

                public getEncodings(): java.util.Iterator;

                public constructor(param0: string);
            }
            export module CertPath {
                export class CertPathRep extends java.lang.Object implements java.io.Serializable {
                    public constructor(param0: string, param1: native.Array<number>);

                    public readResolve(): java.lang.Object;
                }
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.cert.CertPathBuilderResult.d.ts" />
/// <reference path="./java.security.cert.CertPathBuilderSpi.d.ts" />
/// <reference path="./java.security.cert.CertPathParameters.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertPathBuilder extends java.lang.Object {
                public getAlgorithm(): string;

                public static getInstance(param0: string): java.security.cert.CertPathBuilder;
                public static getInstance(param0: string, param1: java.security.Provider): java.security.cert.CertPathBuilder;

                public build(param0: java.security.cert.CertPathParameters): java.security.cert.CertPathBuilderResult;

                public constructor(param0: java.security.cert.CertPathBuilderSpi, param1: java.security.Provider, param2: string);

                public static getInstance(param0: string, param1: string): java.security.cert.CertPathBuilder;

                public static getDefaultType(): string;

                public getProvider(): java.security.Provider;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertPathBuilderException extends java.security.GeneralSecurityException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.cert.CertPath.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertPathBuilderResult extends java.lang.Object implements java.lang.Cloneable {
                /**
                 * Constructs a new instance of the java.security.cert.CertPathBuilderResult interface with the provided implementation.
                 */
                public constructor(implementation: {
                    clone(): java.lang.Object;
                    getCertPath(): java.security.cert.CertPath;
                });

                public getCertPath(): java.security.cert.CertPath;

                public clone(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.security.cert.CertPathBuilderResult.d.ts" />
/// <reference path="./java.security.cert.CertPathParameters.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class CertPathBuilderSpi extends java.lang.Object {
                public engineBuild(param0: java.security.cert.CertPathParameters): java.security.cert.CertPathBuilderResult;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertPathParameters extends java.lang.Object implements java.lang.Cloneable {
                /**
                 * Constructs a new instance of the java.security.cert.CertPathParameters interface with the provided implementation.
                 */
                public constructor(implementation: {
                    clone(): java.lang.Object;
                });

                public clone(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.cert.CertPath.d.ts" />
/// <reference path="./java.security.cert.CertPathParameters.d.ts" />
/// <reference path="./java.security.cert.CertPathValidatorResult.d.ts" />
/// <reference path="./java.security.cert.CertPathValidatorSpi.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertPathValidator extends java.lang.Object {
                public getAlgorithm(): string;

                public constructor(param0: java.security.cert.CertPathValidatorSpi, param1: java.security.Provider, param2: string);

                public static getInstance(param0: string, param1: string): java.security.cert.CertPathValidator;

                public static getDefaultType(): string;

                public getProvider(): java.security.Provider;

                public static getInstance(param0: string): java.security.cert.CertPathValidator;
                public static getInstance(param0: string, param1: java.security.Provider): java.security.cert.CertPathValidator;

                public validate(param0: java.security.cert.CertPath, param1: java.security.cert.CertPathParameters): java.security.cert.CertPathValidatorResult;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.security.cert.CertPath.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertPathValidatorException extends java.security.GeneralSecurityException {
                public getCertPath(): java.security.cert.CertPath;

                public constructor(param0: string, param1: java.lang.Throwable, param2: java.security.cert.CertPath, param3: number);
                public constructor(param0: string, param1: java.lang.Throwable);

                public getIndex(): number;

                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertPathValidatorResult extends java.lang.Object implements java.lang.Cloneable {
                /**
                 * Constructs a new instance of the java.security.cert.CertPathValidatorResult interface with the provided implementation.
                 */
                public constructor(implementation: {
                    clone(): java.lang.Object;
                });

                public clone(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.security.cert.CertPath.d.ts" />
/// <reference path="./java.security.cert.CertPathParameters.d.ts" />
/// <reference path="./java.security.cert.CertPathValidatorResult.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class CertPathValidatorSpi extends java.lang.Object {
                public engineValidate(param0: java.security.cert.CertPath, param1: java.security.cert.CertPathParameters): java.security.cert.CertPathValidatorResult;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertSelector extends java.lang.Object implements java.lang.Cloneable {
                /**
                 * Constructs a new instance of the java.security.cert.CertSelector interface with the provided implementation.
                 */
                public constructor(implementation: {
                    clone(): java.lang.Object;
                    match(param0: java.security.cert.Certificate): boolean;
                });

                public clone(): java.lang.Object;

                public match(param0: java.security.cert.Certificate): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.cert.CRLSelector.d.ts" />
/// <reference path="./java.security.cert.CertSelector.d.ts" />
/// <reference path="./java.security.cert.CertStoreParameters.d.ts" />
/// <reference path="./java.security.cert.CertStoreSpi.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertStore extends java.lang.Object {
                public constructor(param0: java.security.cert.CertStoreSpi, param1: java.security.Provider, param2: string, param3: java.security.cert.CertStoreParameters);

                public getType(): string;

                public getCRLs(param0: java.security.cert.CRLSelector): java.util.Collection;

                public static getInstance(param0: string, param1: java.security.cert.CertStoreParameters, param2: java.security.Provider): java.security.cert.CertStore;
                public static getInstance(param0: string, param1: java.security.cert.CertStoreParameters): java.security.cert.CertStore;
                public static getInstance(param0: string, param1: java.security.cert.CertStoreParameters, param2: string): java.security.cert.CertStore;

                public getCertificates(param0: java.security.cert.CertSelector): java.util.Collection;

                public static getDefaultType(): string;

                public getProvider(): java.security.Provider;

                public getCertStoreParameters(): java.security.cert.CertStoreParameters;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertStoreException extends java.security.GeneralSecurityException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertStoreParameters extends java.lang.Object implements java.lang.Cloneable {
                /**
                 * Constructs a new instance of the java.security.cert.CertStoreParameters interface with the provided implementation.
                 */
                public constructor(implementation: {
                    clone(): java.lang.Object;
                });

                public clone(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.security.cert.CRLSelector.d.ts" />
/// <reference path="./java.security.cert.CertSelector.d.ts" />
/// <reference path="./java.security.cert.CertStoreParameters.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class CertStoreSpi extends java.lang.Object {
                public engineGetCertificates(param0: java.security.cert.CertSelector): java.util.Collection;

                public constructor(param0: java.security.cert.CertStoreParameters);

                public engineGetCRLs(param0: java.security.cert.CRLSelector): java.util.Collection;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class Certificate extends java.lang.Object implements java.io.Serializable {
                public getType(): string;

                public verify(param0: java.security.PublicKey, param1: string): void;

                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public verify(param0: java.security.PublicKey): void;

                public getPublicKey(): java.security.PublicKey;

                public getEncoded(): native.Array<number>;

                public toString(): string;

                public writeReplace(): java.lang.Object;

                public constructor(param0: string);
            }
            export module Certificate {
                export class CertificateRep extends java.lang.Object implements java.io.Serializable {
                    public constructor(param0: string, param1: native.Array<number>);

                    public readResolve(): java.lang.Object;
                }
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertificateEncodingException extends java.security.cert.CertificateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertificateException extends java.security.GeneralSecurityException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertificateExpiredException extends java.security.cert.CertificateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Provider.d.ts" />
/// <reference path="./java.security.cert.CRL.d.ts" />
/// <reference path="./java.security.cert.CertPath.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
/// <reference path="./java.security.cert.CertificateFactorySpi.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertificateFactory extends java.lang.Object {
                public getType(): string;

                public generateCertificates(param0: java.io.InputStream): java.util.Collection;

                public generateCRLs(param0: java.io.InputStream): java.util.Collection;

                public static getInstance(param0: string, param1: java.security.Provider): java.security.cert.CertificateFactory;

                public getCertPathEncodings(): java.util.Iterator;

                public generateCertPath(param0: java.io.InputStream, param1: string): java.security.cert.CertPath;
                public generateCertPath(param0: java.io.InputStream): java.security.cert.CertPath;

                public constructor(param0: java.security.cert.CertificateFactorySpi, param1: java.security.Provider, param2: string);

                public getProvider(): java.security.Provider;

                public generateCertPath(param0: java.util.List): java.security.cert.CertPath;

                public static getInstance(param0: string): java.security.cert.CertificateFactory;

                public generateCertificate(param0: java.io.InputStream): java.security.cert.Certificate;

                public generateCRL(param0: java.io.InputStream): java.security.cert.CRL;

                public static getInstance(param0: string, param1: string): java.security.cert.CertificateFactory;
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.cert.CRL.d.ts" />
/// <reference path="./java.security.cert.CertPath.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class CertificateFactorySpi extends java.lang.Object {
                public engineGenerateCertPath(param0: java.io.InputStream): java.security.cert.CertPath;
                public engineGenerateCertPath(param0: java.io.InputStream, param1: string): java.security.cert.CertPath;

                public engineGetCertPathEncodings(): java.util.Iterator;

                public engineGenerateCertificates(param0: java.io.InputStream): java.util.Collection;

                public engineGenerateCertPath(param0: java.util.List): java.security.cert.CertPath;

                public engineGenerateCertificate(param0: java.io.InputStream): java.security.cert.Certificate;

                public engineGenerateCRL(param0: java.io.InputStream): java.security.cert.CRL;

                public engineGenerateCRLs(param0: java.io.InputStream): java.util.Collection;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertificateNotYetValidException extends java.security.cert.CertificateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CertificateParsingException extends java.security.cert.CertificateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class CollectionCertStoreParameters extends java.lang.Object implements java.security.cert.CertStoreParameters {
                public constructor(param0: java.util.Collection);

                public getCollection(): java.util.Collection;

                public toString(): string;

                public clone(): java.lang.Object;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class LDAPCertStoreParameters extends java.lang.Object implements java.security.cert.CertStoreParameters {
                public getServerName(): string;

                public getPort(): number;

                public constructor(param0: string, param1: number);

                public toString(): string;

                public clone(): java.lang.Object;

                public constructor(param0: string);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.KeyStore.d.ts" />
/// <reference path="./java.security.cert.CertSelector.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class PKIXBuilderParameters extends java.security.cert.PKIXParameters {
                public constructor(param0: java.util.Set);
                public constructor(param0: java.security.KeyStore);
                public constructor(param0: java.security.KeyStore, param1: java.security.cert.CertSelector);

                public getMaxPathLength(): number;

                public setMaxPathLength(param0: number): void;

                public toString(): string;

                public clone(): java.lang.Object;

                public constructor(param0: java.util.Set, param1: java.security.cert.CertSelector);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.cert.CertPath.d.ts" />
/// <reference path="./java.security.cert.PolicyNode.d.ts" />
/// <reference path="./java.security.cert.TrustAnchor.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class PKIXCertPathBuilderResult extends java.security.cert.PKIXCertPathValidatorResult implements java.security.cert.CertPathBuilderResult {
                public getCertPath(): java.security.cert.CertPath;

                public constructor(param0: java.security.cert.TrustAnchor, param1: java.security.cert.PolicyNode, param2: java.security.PublicKey);

                public toString(): string;

                public constructor(param0: java.security.cert.CertPath, param1: java.security.cert.TrustAnchor, param2: java.security.cert.PolicyNode, param3: java.security.PublicKey);

                public clone(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class PKIXCertPathChecker extends java.lang.Object implements java.lang.Cloneable {
                public getSupportedExtensions(): java.util.Set;

                public init(param0: boolean): void;

                public isForwardCheckingSupported(): boolean;

                public clone(): java.lang.Object;

                public constructor();

                public check(param0: java.security.cert.Certificate, param1: java.util.Collection): void;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.cert.PolicyNode.d.ts" />
/// <reference path="./java.security.cert.TrustAnchor.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class PKIXCertPathValidatorResult extends java.lang.Object implements java.security.cert.CertPathValidatorResult {
                public getPublicKey(): java.security.PublicKey;

                public getTrustAnchor(): java.security.cert.TrustAnchor;

                public constructor(param0: java.security.cert.TrustAnchor, param1: java.security.cert.PolicyNode, param2: java.security.PublicKey);

                public getPolicyTree(): java.security.cert.PolicyNode;

                public toString(): string;

                public clone(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.KeyStore.d.ts" />
/// <reference path="./java.security.cert.CertSelector.d.ts" />
/// <reference path="./java.security.cert.CertStore.d.ts" />
/// <reference path="./java.security.cert.PKIXCertPathChecker.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class PKIXParameters extends java.lang.Object implements java.security.cert.CertPathParameters {
                public setCertStores(param0: java.util.List): void;

                public getCertStores(): java.util.List;

                public setAnyPolicyInhibited(param0: boolean): void;

                public isExplicitPolicyRequired(): boolean;

                public setPolicyQualifiersRejected(param0: boolean): void;

                public clone(): java.lang.Object;

                public setCertPathCheckers(param0: java.util.List): void;

                public setRevocationEnabled(param0: boolean): void;

                public constructor(param0: java.security.KeyStore);

                public getTrustAnchors(): java.util.Set;

                public isPolicyMappingInhibited(): boolean;

                public getPolicyQualifiersRejected(): boolean;

                public getTargetCertConstraints(): java.security.cert.CertSelector;

                public isRevocationEnabled(): boolean;

                public setPolicyMappingInhibited(param0: boolean): void;

                public setExplicitPolicyRequired(param0: boolean): void;

                public getInitialPolicies(): java.util.Set;

                public setTargetCertConstraints(param0: java.security.cert.CertSelector): void;

                public getDate(): java.util.Date;

                public getCertPathCheckers(): java.util.List;

                public isAnyPolicyInhibited(): boolean;

                public toString(): string;

                public constructor(param0: java.util.Set);

                public addCertStore(param0: java.security.cert.CertStore): void;

                public setDate(param0: java.util.Date): void;

                public addCertPathChecker(param0: java.security.cert.PKIXCertPathChecker): void;

                public getSigProvider(): string;

                public setSigProvider(param0: string): void;

                public setTrustAnchors(param0: java.util.Set): void;

                public setInitialPolicies(param0: java.util.Set): void;
            }
        }
    }
}

/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class PolicyNode extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.cert.PolicyNode interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getChildren(): java.util.Iterator;
                    getDepth(): number;
                    getExpectedPolicies(): java.util.Set;
                    getParent(): java.security.cert.PolicyNode;
                    getPolicyQualifiers(): java.util.Set;
                    getValidPolicy(): string;
                    isCritical(): boolean;
                });

                public getParent(): java.security.cert.PolicyNode;

                public getChildren(): java.util.Iterator;

                public getValidPolicy(): string;

                public getExpectedPolicies(): java.util.Set;

                public getPolicyQualifiers(): java.util.Set;

                public isCritical(): boolean;

                public getDepth(): number;
            }
        }
    }
}

declare module java {
    export module security {
        export module cert {
            export class PolicyQualifierInfo extends java.lang.Object {
                public constructor(param0: native.Array<number>);

                public getPolicyQualifier(): native.Array<number>;

                public getEncoded(): native.Array<number>;

                public getPolicyQualifierId(): string;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.cert.X509Certificate.d.ts" />
/// <reference path="./javax.security.auth.x500.X500Principal.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class TrustAnchor extends java.lang.Object {
                public getCAPublicKey(): java.security.PublicKey;

                public getNameConstraints(): native.Array<number>;

                public getTrustedCert(): java.security.cert.X509Certificate;

                public getCA(): javaxsecurityauthx500X500Principal;

                public constructor(param0: java.security.cert.X509Certificate, param1: native.Array<number>);
                public constructor(param0: javaxsecurityauthx500X500Principal, param1: java.security.PublicKey, param2: native.Array<number>);
                public constructor(param0: string, param1: java.security.PublicKey, param2: native.Array<number>);

                public toString(): string;

                public getCAName(): string;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.Principal.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.cert.X509CRLEntry.d.ts" />
/// <reference path="./java.security.cert.X509Certificate.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./javax.security.auth.x500.X500Principal.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class X509CRL extends java.security.cert.CRL implements java.security.cert.X509Extension {
                public getRevokedCertificate(param0: java.security.cert.X509Certificate): java.security.cert.X509CRLEntry;

                public getCriticalExtensionOIDs(): java.util.Set;

                public equals(param0: java.lang.Object): boolean;

                public getTBSCertList(): native.Array<number>;

                public getSignature(): native.Array<number>;

                public getSigAlgParams(): native.Array<number>;

                public constructor(param0: string);

                public getIssuerDN(): java.security.Principal;

                public constructor();

                public verify(param0: java.security.PublicKey, param1: string): void;

                public hasUnsupportedCriticalExtension(): boolean;

                public getVersion(): number;

                public getRevokedCertificate(param0: java.math.BigInteger): java.security.cert.X509CRLEntry;

                public getRevokedCertificates(): java.util.Set;

                public hashCode(): number;

                public getIssuerX500Principal(): javaxsecurityauthx500X500Principal;

                public getThisUpdate(): java.util.Date;

                public getNextUpdate(): java.util.Date;

                public getExtensionValue(param0: string): native.Array<number>;

                public verify(param0: java.security.PublicKey): void;

                public getEncoded(): native.Array<number>;

                public getSigAlgName(): string;

                public getSigAlgOID(): string;

                public getNonCriticalExtensionOIDs(): java.util.Set;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./javax.security.auth.x500.X500Principal.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class X509CRLEntry extends java.lang.Object implements java.security.cert.X509Extension {
                public getSerialNumber(): java.math.BigInteger;

                public getCriticalExtensionOIDs(): java.util.Set;

                public equals(param0: java.lang.Object): boolean;

                public getCertificateIssuer(): javaxsecurityauthx500X500Principal;

                public getRevocationDate(): java.util.Date;

                public toString(): string;

                public constructor();

                public hasUnsupportedCriticalExtension(): boolean;

                public hashCode(): number;

                public getExtensionValue(param0: string): native.Array<number>;

                public hasExtensions(): boolean;

                public getEncoded(): native.Array<number>;

                public getNonCriticalExtensionOIDs(): java.util.Set;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.cert.CRL.d.ts" />
/// <reference path="./java.security.cert.X509Certificate.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./javax.security.auth.x500.X500Principal.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class X509CRLSelector extends java.lang.Object implements java.security.cert.CRLSelector {
                public getDateAndTime(): java.util.Date;

                public getIssuerNames(): java.util.Collection;

                public setMaxCRLNumber(param0: java.math.BigInteger): void;

                public toString(): string;

                public clone(): java.lang.Object;

                public setMinCRLNumber(param0: java.math.BigInteger): void;

                public constructor();

                public addIssuer(param0: javaxsecurityauthx500X500Principal): void;

                public setCertificateChecking(param0: java.security.cert.X509Certificate): void;

                public getMinCRL(): java.math.BigInteger;

                public match(param0: java.security.cert.CRL): boolean;

                public setDateAndTime(param0: java.util.Date): void;

                public setIssuers(param0: java.util.Collection): void;

                public addIssuerName(param0: string): void;

                public getIssuers(): java.util.Collection;

                public getCertificateChecking(): java.security.cert.X509Certificate;

                public addIssuerName(param0: native.Array<number>): void;

                public getMaxCRL(): java.math.BigInteger;

                public setIssuerNames(param0: java.util.Collection): void;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.PublicKey.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
/// <reference path="./java.security.cert.X509Certificate.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./javax.security.auth.x500.X500Principal.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class X509CertSelector extends java.lang.Object implements java.security.cert.CertSelector {
                public getSerialNumber(): java.math.BigInteger;

                public getPathToNames(): java.util.Collection;

                public setSubjectPublicKey(param0: native.Array<number>): void;

                public setNameConstraints(param0: native.Array<number>): void;

                public setPathToNames(param0: java.util.Collection): void;

                public clone(): java.lang.Object;

                public constructor();

                public setIssuer(param0: string): void;

                public getSubjectAsBytes(): native.Array<number>;

                public getBasicConstraints(): number;

                public match(param0: java.security.cert.Certificate): boolean;

                public addSubjectAlternativeName(param0: number, param1: string): void;

                public getPrivateKeyValid(): java.util.Date;

                public setKeyUsage(param0: native.Array<boolean>): void;

                public setSubjectKeyIdentifier(param0: native.Array<number>): void;

                public getPolicy(): java.util.Set;

                public getMatchAllSubjectAltNames(): boolean;

                public setSubjectAlternativeNames(param0: java.util.Collection): void;

                public setAuthorityKeyIdentifier(param0: native.Array<number>): void;

                public toString(): string;

                public getKeyUsage(): native.Array<boolean>;

                public getIssuerAsBytes(): native.Array<number>;

                public setBasicConstraints(param0: number): void;

                public getSubject(): javaxsecurityauthx500X500Principal;

                public getNameConstraints(): native.Array<number>;

                public setSerialNumber(param0: java.math.BigInteger): void;

                public setPrivateKeyValid(param0: java.util.Date): void;

                public setIssuer(param0: javaxsecurityauthx500X500Principal): void;

                public getSubjectKeyIdentifier(): native.Array<number>;

                public setSubject(param0: string): void;

                public getCertificateValid(): java.util.Date;

                public setSubject(param0: native.Array<number>): void;

                public getIssuer(): javaxsecurityauthx500X500Principal;

                public addPathToName(param0: number, param1: native.Array<number>): void;

                public setSubjectPublicKey(param0: java.security.PublicKey): void;

                public setSubjectPublicKeyAlgID(param0: string): void;

                public getSubjectPublicKeyAlgID(): string;

                public setPolicy(param0: java.util.Set): void;

                public setIssuer(param0: native.Array<number>): void;

                public getAuthorityKeyIdentifier(): native.Array<number>;

                public getCertificate(): java.security.cert.X509Certificate;

                public getSubjectAsString(): string;

                public getSubjectAlternativeNames(): java.util.Collection;

                public getSubjectPublicKey(): java.security.PublicKey;

                public setMatchAllSubjectAltNames(param0: boolean): void;

                public getExtendedKeyUsage(): java.util.Set;

                public addSubjectAlternativeName(param0: number, param1: native.Array<number>): void;

                public addPathToName(param0: number, param1: string): void;

                public setSubject(param0: javaxsecurityauthx500X500Principal): void;

                public setCertificate(param0: java.security.cert.X509Certificate): void;

                public setExtendedKeyUsage(param0: java.util.Set): void;

                public getIssuerAsString(): string;

                public setCertificateValid(param0: java.util.Date): void;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.Principal.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./javax.security.auth.x500.X500Principal.d.ts" />
declare module java {
    export module security {
        export module cert {
            export abstract class X509Certificate extends java.security.cert.Certificate implements java.security.cert.X509Extension {
                public getSerialNumber(): java.math.BigInteger;

                public getCriticalExtensionOIDs(): java.util.Set;

                public getSignature(): native.Array<number>;

                public getSubjectUniqueID(): native.Array<boolean>;

                public constructor(param0: string);

                public getIssuerDN(): java.security.Principal;

                public constructor();

                public getSubjectX500Principal(): javaxsecurityauthx500X500Principal;

                public getBasicConstraints(): number;

                public getIssuerX500Principal(): javaxsecurityauthx500X500Principal;

                public getIssuerUniqueID(): native.Array<boolean>;

                public getNonCriticalExtensionOIDs(): java.util.Set;

                public checkValidity(param0: java.util.Date): void;

                public getNotBefore(): java.util.Date;

                public getNotAfter(): java.util.Date;

                public getSubjectAlternativeNames(): java.util.Collection;

                public getExtendedKeyUsage(): java.util.List;

                public getSubjectDN(): java.security.Principal;

                public getSigAlgParams(): native.Array<number>;

                public getKeyUsage(): native.Array<boolean>;

                public hasUnsupportedCriticalExtension(): boolean;

                public getVersion(): number;

                public getIssuerAlternativeNames(): java.util.Collection;

                public getExtensionValue(param0: string): native.Array<number>;

                public checkValidity(): void;

                public getTBSCertificate(): native.Array<number>;

                public getSigAlgName(): string;

                public getSigAlgOID(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module security {
        export module cert {
            export class X509Extension extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.cert.X509Extension interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getCriticalExtensionOIDs(): java.util.Set;
                    getExtensionValue(param0: string): native.Array<number>;
                    getNonCriticalExtensionOIDs(): java.util.Set;
                    hasUnsupportedCriticalExtension(): boolean;
                });

                public getCriticalExtensionOIDs(): java.util.Set;

                public hasUnsupportedCriticalExtension(): boolean;

                public getExtensionValue(param0: string): native.Array<number>;

                public getNonCriticalExtensionOIDs(): java.util.Set;
            }
        }
    }
}

/// <reference path="./java.security.interfaces.DSAParams.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class DSAKey extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.interfaces.DSAKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getParams(): java.security.interfaces.DSAParams;
                });

                public getParams(): java.security.interfaces.DSAParams;
            }
        }
    }
}

/// <reference path="./java.security.SecureRandom.d.ts" />
/// <reference path="./java.security.interfaces.DSAParams.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class DSAKeyPairGenerator extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.interfaces.DSAKeyPairGenerator interface with the provided implementation.
                 */
                public constructor(implementation: {
                    initialize(param0: java.security.interfaces.DSAParams, param1: java.security.SecureRandom): void;
                    initialize(param0: number, param1: boolean, param2: java.security.SecureRandom): void;
                });

                public initialize(param0: java.security.interfaces.DSAParams, param1: java.security.SecureRandom): void;
                public initialize(param0: number, param1: boolean, param2: java.security.SecureRandom): void;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class DSAParams extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.interfaces.DSAParams interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getG(): java.math.BigInteger;
                    getP(): java.math.BigInteger;
                    getQ(): java.math.BigInteger;
                });

                public getQ(): java.math.BigInteger;

                public getG(): java.math.BigInteger;

                public getP(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.interfaces.DSAParams.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class DSAPrivateKey extends java.lang.Object implements java.security.interfaces.DSAKey, java.security.PrivateKey {
                /**
                 * Constructs a new instance of the java.security.interfaces.DSAPrivateKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getX(): java.math.BigInteger;
                    getParams(): java.security.interfaces.DSAParams;
                    getAlgorithm(): string;
                    getFormat(): string;
                    getEncoded(): native.Array<number>;
                });

                public static serialVersionUID: number;

                public getAlgorithm(): string;

                public getFormat(): string;

                public getParams(): java.security.interfaces.DSAParams;

                public getEncoded(): native.Array<number>;

                public getX(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.interfaces.DSAParams.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class DSAPublicKey extends java.lang.Object implements java.security.interfaces.DSAKey, java.security.PublicKey {
                /**
                 * Constructs a new instance of the java.security.interfaces.DSAPublicKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getY(): java.math.BigInteger;
                    getParams(): java.security.interfaces.DSAParams;
                    getAlgorithm(): string;
                    getFormat(): string;
                    getEncoded(): native.Array<number>;
                });

                public static serialVersionUID: number;

                public getAlgorithm(): string;

                public getFormat(): string;

                public getParams(): java.security.interfaces.DSAParams;

                public getEncoded(): native.Array<number>;

                public getY(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.security.spec.ECParameterSpec.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class ECKey extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.interfaces.ECKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getParams(): java.security.spec.ECParameterSpec;
                });

                public getParams(): java.security.spec.ECParameterSpec;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.spec.ECParameterSpec.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class ECPrivateKey extends java.lang.Object implements java.security.PrivateKey, java.security.interfaces.ECKey {
                /**
                 * Constructs a new instance of the java.security.interfaces.ECPrivateKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getS(): java.math.BigInteger;
                    getParams(): java.security.spec.ECParameterSpec;
                    getAlgorithm(): string;
                    getFormat(): string;
                    getEncoded(): native.Array<number>;
                });

                public static serialVersionUID: number;

                public getAlgorithm(): string;

                public getFormat(): string;

                public getS(): java.math.BigInteger;

                public getParams(): java.security.spec.ECParameterSpec;

                public getEncoded(): native.Array<number>;
            }
        }
    }
}

/// <reference path="./java.security.spec.ECParameterSpec.d.ts" />
/// <reference path="./java.security.spec.ECPoint.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class ECPublicKey extends java.lang.Object implements java.security.PublicKey, java.security.interfaces.ECKey {
                /**
                 * Constructs a new instance of the java.security.interfaces.ECPublicKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getW(): java.security.spec.ECPoint;
                    getParams(): java.security.spec.ECParameterSpec;
                    getAlgorithm(): string;
                    getFormat(): string;
                    getEncoded(): native.Array<number>;
                });

                public static serialVersionUID: number;

                public getAlgorithm(): string;

                public getFormat(): string;

                public getParams(): java.security.spec.ECParameterSpec;

                public getEncoded(): native.Array<number>;

                public getW(): java.security.spec.ECPoint;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class RSAKey extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.interfaces.RSAKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getModulus(): java.math.BigInteger;
                });

                public getModulus(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.spec.RSAOtherPrimeInfo.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class RSAMultiPrimePrivateCrtKey extends java.lang.Object implements java.security.interfaces.RSAPrivateKey {
                /**
                 * Constructs a new instance of the java.security.interfaces.RSAMultiPrimePrivateCrtKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getCrtCoefficient(): java.math.BigInteger;
                    getOtherPrimeInfo(): native.Array<java.security.spec.RSAOtherPrimeInfo>;
                    getPrimeP(): java.math.BigInteger;
                    getPrimeQ(): java.math.BigInteger;
                    getPrimeExponentP(): java.math.BigInteger;
                    getPrimeExponentQ(): java.math.BigInteger;
                    getPublicExponent(): java.math.BigInteger;
                    getPrivateExponent(): java.math.BigInteger;
                    getModulus(): java.math.BigInteger;
                    getAlgorithm(): string;
                    getFormat(): string;
                    getEncoded(): native.Array<number>;
                });

                public static serialVersionUID: number;

                public getPrimeQ(): java.math.BigInteger;

                public getAlgorithm(): string;

                public getPrimeExponentP(): java.math.BigInteger;

                public getPrivateExponent(): java.math.BigInteger;

                public getFormat(): string;

                public getPublicExponent(): java.math.BigInteger;

                public getOtherPrimeInfo(): native.Array<java.security.spec.RSAOtherPrimeInfo>;

                public getCrtCoefficient(): java.math.BigInteger;

                public getEncoded(): native.Array<number>;

                public getPrimeExponentQ(): java.math.BigInteger;

                public getModulus(): java.math.BigInteger;

                public getPrimeP(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class RSAPrivateCrtKey extends java.lang.Object implements java.security.interfaces.RSAPrivateKey {
                /**
                 * Constructs a new instance of the java.security.interfaces.RSAPrivateCrtKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getCrtCoefficient(): java.math.BigInteger;
                    getPrimeP(): java.math.BigInteger;
                    getPrimeQ(): java.math.BigInteger;
                    getPrimeExponentP(): java.math.BigInteger;
                    getPrimeExponentQ(): java.math.BigInteger;
                    getPublicExponent(): java.math.BigInteger;
                    getPrivateExponent(): java.math.BigInteger;
                    getModulus(): java.math.BigInteger;
                    getAlgorithm(): string;
                    getFormat(): string;
                    getEncoded(): native.Array<number>;
                });

                public static serialVersionUID: number;

                public getPrimeQ(): java.math.BigInteger;

                public getAlgorithm(): string;

                public getPrimeExponentP(): java.math.BigInteger;

                public getPrivateExponent(): java.math.BigInteger;

                public getFormat(): string;

                public getPublicExponent(): java.math.BigInteger;

                public getCrtCoefficient(): java.math.BigInteger;

                public getEncoded(): native.Array<number>;

                public getPrimeExponentQ(): java.math.BigInteger;

                public getModulus(): java.math.BigInteger;

                public getPrimeP(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class RSAPrivateKey extends java.lang.Object implements java.security.PrivateKey, java.security.interfaces.RSAKey {
                /**
                 * Constructs a new instance of the java.security.interfaces.RSAPrivateKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getPrivateExponent(): java.math.BigInteger;
                    getModulus(): java.math.BigInteger;
                    getAlgorithm(): string;
                    getFormat(): string;
                    getEncoded(): native.Array<number>;
                });

                public static serialVersionUID: number;

                public getAlgorithm(): string;

                public getPrivateExponent(): java.math.BigInteger;

                public getFormat(): string;

                public getEncoded(): native.Array<number>;

                public getModulus(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module interfaces {
            export class RSAPublicKey extends java.lang.Object implements java.security.PublicKey, java.security.interfaces.RSAKey {
                /**
                 * Constructs a new instance of the java.security.interfaces.RSAPublicKey interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getPublicExponent(): java.math.BigInteger;
                    getModulus(): java.math.BigInteger;
                    getAlgorithm(): string;
                    getFormat(): string;
                    getEncoded(): native.Array<number>;
                });

                public static serialVersionUID: number;

                public getAlgorithm(): string;

                public getFormat(): string;

                public getPublicExponent(): java.math.BigInteger;

                public getEncoded(): native.Array<number>;

                public getModulus(): java.math.BigInteger;
            }
        }
    }
}

declare module java {
    export module security {
        export module spec {
            export class AlgorithmParameterSpec extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.spec.AlgorithmParameterSpec interface with the provided implementation.
                 */
                public constructor(implementation: {});
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class DSAParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec, java.security.interfaces.DSAParams {
                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger, param2: java.math.BigInteger);

                public getQ(): java.math.BigInteger;

                public getG(): java.math.BigInteger;

                public getP(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class DSAPrivateKeySpec extends java.lang.Object implements java.security.spec.KeySpec {
                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger, param2: java.math.BigInteger, param3: java.math.BigInteger);

                public getQ(): java.math.BigInteger;

                public getG(): java.math.BigInteger;

                public getX(): java.math.BigInteger;

                public getP(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class DSAPublicKeySpec extends java.lang.Object implements java.security.spec.KeySpec {
                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger, param2: java.math.BigInteger, param3: java.math.BigInteger);

                public getQ(): java.math.BigInteger;

                public getG(): java.math.BigInteger;

                public getY(): java.math.BigInteger;

                public getP(): java.math.BigInteger;
            }
        }
    }
}

declare module java {
    export module security {
        export module spec {
            export class ECField extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.spec.ECField interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getFieldSize(): number;
                });

                public getFieldSize(): number;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class ECFieldF2m extends java.lang.Object implements java.security.spec.ECField {
                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public getMidTermsOfReductionPolynomial(): native.Array<number>;

                public constructor(param0: number, param1: java.math.BigInteger);
                public constructor(param0: number);

                public getFieldSize(): number;

                public getReductionPolynomial(): java.math.BigInteger;

                public constructor(param0: number, param1: native.Array<number>);

                public getM(): number;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class ECFieldFp extends java.lang.Object implements java.security.spec.ECField {
                public equals(param0: java.lang.Object): boolean;

                public hashCode(): number;

                public getFieldSize(): number;

                public constructor(param0: java.math.BigInteger);

                public getP(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class ECGenParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec {
                public getName(): string;

                public constructor(param0: string);
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.spec.ECPoint.d.ts" />
/// <reference path="./java.security.spec.EllipticCurve.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class ECParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec {
                public getCurve(): java.security.spec.EllipticCurve;

                public getGenerator(): java.security.spec.ECPoint;

                public getOrder(): java.math.BigInteger;

                public constructor(param0: java.security.spec.EllipticCurve, param1: java.security.spec.ECPoint, param2: java.math.BigInteger, param3: number);

                public getCofactor(): number;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class ECPoint extends java.lang.Object {
                public static POINT_INFINITY: java.security.spec.ECPoint;

                public getAffineY(): java.math.BigInteger;

                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger);

                public equals(param0: java.lang.Object): boolean;

                public getAffineX(): java.math.BigInteger;

                public hashCode(): number;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.spec.ECParameterSpec.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class ECPrivateKeySpec extends java.lang.Object implements java.security.spec.KeySpec {
                public constructor(param0: java.math.BigInteger, param1: java.security.spec.ECParameterSpec);

                public getS(): java.math.BigInteger;

                public getParams(): java.security.spec.ECParameterSpec;
            }
        }
    }
}

/// <reference path="./java.security.spec.ECParameterSpec.d.ts" />
/// <reference path="./java.security.spec.ECPoint.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class ECPublicKeySpec extends java.lang.Object implements java.security.spec.KeySpec {
                public constructor(param0: java.security.spec.ECPoint, param1: java.security.spec.ECParameterSpec);

                public getParams(): java.security.spec.ECParameterSpec;

                public getW(): java.security.spec.ECPoint;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.spec.ECField.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class EllipticCurve extends java.lang.Object {
                public getA(): java.math.BigInteger;

                public equals(param0: java.lang.Object): boolean;

                public constructor(param0: java.security.spec.ECField, param1: java.math.BigInteger, param2: java.math.BigInteger, param3: native.Array<number>);
                public constructor(param0: java.security.spec.ECField, param1: java.math.BigInteger, param2: java.math.BigInteger);

                public getSeed(): native.Array<number>;

                public hashCode(): number;

                public getB(): java.math.BigInteger;

                public getField(): java.security.spec.ECField;
            }
        }
    }
}

declare module java {
    export module security {
        export module spec {
            export abstract class EncodedKeySpec extends java.lang.Object implements java.security.spec.KeySpec {
                public constructor(param0: native.Array<number>);

                public getFormat(): string;

                public getEncoded(): native.Array<number>;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class InvalidKeySpecException extends java.security.GeneralSecurityException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class InvalidParameterSpecException extends java.security.GeneralSecurityException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

declare module java {
    export module security {
        export module spec {
            export class KeySpec extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.security.spec.KeySpec interface with the provided implementation.
                 */
                public constructor(implementation: {});
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class MGF1ParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec {
                public static SHA1: java.security.spec.MGF1ParameterSpec;
                public static SHA256: java.security.spec.MGF1ParameterSpec;
                public static SHA384: java.security.spec.MGF1ParameterSpec;
                public static SHA512: java.security.spec.MGF1ParameterSpec;

                public getDigestAlgorithm(): string;

                public constructor(param0: string);
            }
        }
    }
}

declare module java {
    export module security {
        export module spec {
            export class PKCS8EncodedKeySpec extends java.security.spec.EncodedKeySpec {
                public constructor(param0: native.Array<number>);

                public getFormat(): string;

                public getEncoded(): native.Array<number>;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.spec.AlgorithmParameterSpec.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class PSSParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec {
                public static DEFAULT: java.security.spec.PSSParameterSpec;

                public getSaltLength(): number;

                public getDigestAlgorithm(): string;

                public getMGFAlgorithm(): string;

                public getTrailerField(): number;

                public constructor(param0: number);
                public constructor(param0: string, param1: string, param2: java.security.spec.AlgorithmParameterSpec, param3: number, param4: number);

                public getMGFParameters(): java.security.spec.AlgorithmParameterSpec;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class RSAKeyGenParameterSpec extends java.lang.Object implements java.security.spec.AlgorithmParameterSpec {
                public static F0: java.math.BigInteger;
                public static F4: java.math.BigInteger;

                public getPublicExponent(): java.math.BigInteger;

                public constructor(param0: number, param1: java.math.BigInteger);

                public getKeysize(): number;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.security.spec.RSAOtherPrimeInfo.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class RSAMultiPrimePrivateCrtKeySpec extends java.security.spec.RSAPrivateKeySpec {
                public getPrimeQ(): java.math.BigInteger;

                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger, param2: java.math.BigInteger, param3: java.math.BigInteger, param4: java.math.BigInteger, param5: java.math.BigInteger, param6: java.math.BigInteger, param7: java.math.BigInteger, param8: native.Array<java.security.spec.RSAOtherPrimeInfo>);
                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger);

                public getPrimeExponentP(): java.math.BigInteger;

                public getPublicExponent(): java.math.BigInteger;

                public getOtherPrimeInfo(): native.Array<java.security.spec.RSAOtherPrimeInfo>;

                public getCrtCoefficient(): java.math.BigInteger;

                public getPrimeExponentQ(): java.math.BigInteger;

                public getPrimeP(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class RSAOtherPrimeInfo extends java.lang.Object {
                public getExponent(): java.math.BigInteger;

                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger, param2: java.math.BigInteger);

                public getPrime(): java.math.BigInteger;

                public getCrtCoefficient(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class RSAPrivateCrtKeySpec extends java.security.spec.RSAPrivateKeySpec {
                public getPrimeQ(): java.math.BigInteger;

                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger);

                public getPrimeExponentP(): java.math.BigInteger;

                public getPublicExponent(): java.math.BigInteger;

                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger, param2: java.math.BigInteger, param3: java.math.BigInteger, param4: java.math.BigInteger, param5: java.math.BigInteger, param6: java.math.BigInteger, param7: java.math.BigInteger);

                public getCrtCoefficient(): java.math.BigInteger;

                public getPrimeExponentQ(): java.math.BigInteger;

                public getPrimeP(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class RSAPrivateKeySpec extends java.lang.Object implements java.security.spec.KeySpec {
                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger);

                public getPrivateExponent(): java.math.BigInteger;

                public getModulus(): java.math.BigInteger;
            }
        }
    }
}

/// <reference path="./java.math.BigInteger.d.ts" />
declare module java {
    export module security {
        export module spec {
            export class RSAPublicKeySpec extends java.lang.Object implements java.security.spec.KeySpec {
                public constructor(param0: java.math.BigInteger, param1: java.math.BigInteger);

                public getPublicExponent(): java.math.BigInteger;

                public getModulus(): java.math.BigInteger;
            }
        }
    }
}

declare module java {
    export module security {
        export module spec {
            export class X509EncodedKeySpec extends java.security.spec.EncodedKeySpec {
                public constructor(param0: native.Array<number>);

                public getFormat(): string;

                public getEncoded(): native.Array<number>;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.sql.ResultSet.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module sql {
        export class Array extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.Array interface with the provided implementation.
             */
            public constructor(implementation: {
                getArray(): java.lang.Object;
                getArray(param0: number, param1: number): java.lang.Object;
                getArray(param0: number, param1: number, param2: java.util.Map): java.lang.Object;
                getArray(param0: java.util.Map): java.lang.Object;
                getBaseType(): number;
                getBaseTypeName(): string;
                getResultSet(): java.sql.ResultSet;
                getResultSet(param0: number, param1: number): java.sql.ResultSet;
                getResultSet(param0: number, param1: number, param2: java.util.Map): java.sql.ResultSet;
                getResultSet(param0: java.util.Map): java.sql.ResultSet;
                free(): void;
            });

            public free(): void;

            public getResultSet(): java.sql.ResultSet;

            public getArray(): java.lang.Object;

            public getResultSet(param0: number, param1: number, param2: java.util.Map): java.sql.ResultSet;

            public getBaseType(): number;

            public getResultSet(param0: number, param1: number): java.sql.ResultSet;

            public getArray(param0: number, param1: number): java.lang.Object;
            public getArray(param0: java.util.Map): java.lang.Object;

            public getBaseTypeName(): string;

            public getResultSet(param0: java.util.Map): java.sql.ResultSet;

            public getArray(param0: number, param1: number, param2: java.util.Map): java.lang.Object;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class BatchUpdateException extends java.sql.SQLException implements java.io.Serializable {
            public constructor(param0: string, param1: string, param2: number, param3: native.Array<number>);
            public constructor(param0: string, param1: native.Array<number>, param2: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: native.Array<number>, param1: java.lang.Throwable);
            public constructor(param0: string, param1: string, param2: native.Array<number>);
            public constructor();
            public constructor(param0: native.Array<number>);
            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);

            public getUpdateCounts(): native.Array<number>;

            public constructor(param0: string, param1: native.Array<number>);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor(param0: string, param1: string, param2: native.Array<number>, param3: java.lang.Throwable);
            public constructor(param0: string, param1: string, param2: number, param3: native.Array<number>, param4: java.lang.Throwable);
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
declare module java {
    export module sql {
        export class Blob extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.Blob interface with the provided implementation.
             */
            public constructor(implementation: {
                getBinaryStream(): java.io.InputStream;
                getBinaryStream(param0: number, param1: number): java.io.InputStream;
                getBytes(param0: number, param1: number): native.Array<number>;
                length(): number;
                position(param0: java.sql.Blob, param1: number): number;
                position(param0: native.Array<number>, param1: number): number;
                setBinaryStream(param0: number): java.io.OutputStream;
                setBytes(param0: number, param1: native.Array<number>): number;
                setBytes(param0: number, param1: native.Array<number>, param2: number, param3: number): number;
                truncate(param0: number): void;
                free(): void;
            });

            public getBinaryStream(): java.io.InputStream;

            public free(): void;

            public getBinaryStream(param0: number, param1: number): java.io.InputStream;

            public getBytes(param0: number, param1: number): native.Array<number>;

            public truncate(param0: number): void;

            public length(): number;

            public setBinaryStream(param0: number): java.io.OutputStream;

            public position(param0: native.Array<number>, param1: number): number;

            public setBytes(param0: number, param1: native.Array<number>, param2: number, param3: number): number;

            public position(param0: java.sql.Blob, param1: number): number;

            public setBytes(param0: number, param1: native.Array<number>): number;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigDecimal.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.sql.Array.d.ts" />
/// <reference path="./java.sql.Blob.d.ts" />
/// <reference path="./java.sql.Clob.d.ts" />
/// <reference path="./java.sql.Connection.d.ts" />
/// <reference path="./java.sql.Date.d.ts" />
/// <reference path="./java.sql.NClob.d.ts" />
/// <reference path="./java.sql.ParameterMetaData.d.ts" />
/// <reference path="./java.sql.Ref.d.ts" />
/// <reference path="./java.sql.ResultSet.d.ts" />
/// <reference path="./java.sql.ResultSetMetaData.d.ts" />
/// <reference path="./java.sql.RowId.d.ts" />
/// <reference path="./java.sql.SQLWarning.d.ts" />
/// <reference path="./java.sql.SQLXML.d.ts" />
/// <reference path="./java.sql.Time.d.ts" />
/// <reference path="./java.sql.Timestamp.d.ts" />
/// <reference path="./java.util.Calendar.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module sql {
        export class CallableStatement extends java.lang.Object implements java.sql.PreparedStatement {
            /**
             * Constructs a new instance of the java.sql.CallableStatement interface with the provided implementation.
             */
            public constructor(implementation: {
                getArray(param0: number): java.sql.Array;
                getArray(param0: string): java.sql.Array;
                getBigDecimal(param0: number): java.math.BigDecimal;
                getBigDecimal(param0: number, param1: number): java.math.BigDecimal;
                getBigDecimal(param0: string): java.math.BigDecimal;
                getBlob(param0: number): java.sql.Blob;
                getBlob(param0: string): java.sql.Blob;
                getBoolean(param0: number): boolean;
                getBoolean(param0: string): boolean;
                getByte(param0: number): number;
                getByte(param0: string): number;
                getBytes(param0: number): native.Array<number>;
                getBytes(param0: string): native.Array<number>;
                getClob(param0: number): java.sql.Clob;
                getClob(param0: string): java.sql.Clob;
                getDate(param0: number): java.sql.Date;
                getDate(param0: number, param1: java.util.Calendar): java.sql.Date;
                getDate(param0: string): java.sql.Date;
                getDate(param0: string, param1: java.util.Calendar): java.sql.Date;
                getDouble(param0: number): number;
                getDouble(param0: string): number;
                getFloat(param0: number): number;
                getFloat(param0: string): number;
                getInt(param0: number): number;
                getInt(param0: string): number;
                getLong(param0: number): number;
                getLong(param0: string): number;
                getObject(param0: number): java.lang.Object;
                getObject(param0: number, param1: java.util.Map): java.lang.Object;
                getObject(param0: string): java.lang.Object;
                getObject(param0: string, param1: java.util.Map): java.lang.Object;
                getRef(param0: number): java.sql.Ref;
                getRef(param0: string): java.sql.Ref;
                getShort(param0: number): number;
                getShort(param0: string): number;
                getString(param0: number): string;
                getString(param0: string): string;
                getTime(param0: number): java.sql.Time;
                getTime(param0: number, param1: java.util.Calendar): java.sql.Time;
                getTime(param0: string): java.sql.Time;
                getTime(param0: string, param1: java.util.Calendar): java.sql.Time;
                getTimestamp(param0: number): java.sql.Timestamp;
                getTimestamp(param0: number, param1: java.util.Calendar): java.sql.Timestamp;
                getTimestamp(param0: string): java.sql.Timestamp;
                getTimestamp(param0: string, param1: java.util.Calendar): java.sql.Timestamp;
                getURL(param0: number): java.net.URL;
                getURL(param0: string): java.net.URL;
                registerOutParameter(param0: number, param1: number): void;
                registerOutParameter(param0: number, param1: number, param2: number): void;
                registerOutParameter(param0: number, param1: number, param2: string): void;
                registerOutParameter(param0: string, param1: number): void;
                registerOutParameter(param0: string, param1: number, param2: number): void;
                registerOutParameter(param0: string, param1: number, param2: string): void;
                setAsciiStream(param0: string, param1: java.io.InputStream, param2: number): void;
                setBigDecimal(param0: string, param1: java.math.BigDecimal): void;
                setBinaryStream(param0: string, param1: java.io.InputStream, param2: number): void;
                setBoolean(param0: string, param1: boolean): void;
                setByte(param0: string, param1: number): void;
                setBytes(param0: string, param1: native.Array<number>): void;
                setCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;
                setDate(param0: string, param1: java.sql.Date): void;
                setDate(param0: string, param1: java.sql.Date, param2: java.util.Calendar): void;
                setDouble(param0: string, param1: number): void;
                setFloat(param0: string, param1: number): void;
                setInt(param0: string, param1: number): void;
                setLong(param0: string, param1: number): void;
                setNull(param0: string, param1: number): void;
                setNull(param0: string, param1: number, param2: string): void;
                setObject(param0: string, param1: java.lang.Object): void;
                setObject(param0: string, param1: java.lang.Object, param2: number): void;
                setObject(param0: string, param1: java.lang.Object, param2: number, param3: number): void;
                setShort(param0: string, param1: number): void;
                setString(param0: string, param1: string): void;
                setTime(param0: string, param1: java.sql.Time): void;
                setTime(param0: string, param1: java.sql.Time, param2: java.util.Calendar): void;
                setTimestamp(param0: string, param1: java.sql.Timestamp): void;
                setTimestamp(param0: string, param1: java.sql.Timestamp, param2: java.util.Calendar): void;
                setURL(param0: string, param1: java.net.URL): void;
                wasNull(): boolean;
                getRowId(param0: number): java.sql.RowId;
                getRowId(param0: string): java.sql.RowId;
                setRowId(param0: string, param1: java.sql.RowId): void;
                setNString(param0: string, param1: string): void;
                setNCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;
                setNClob(param0: string, param1: java.sql.NClob): void;
                setClob(param0: string, param1: java.io.Reader, param2: number): void;
                setBlob(param0: string, param1: java.io.InputStream, param2: number): void;
                setNClob(param0: string, param1: java.io.Reader, param2: number): void;
                getNClob(param0: number): java.sql.NClob;
                getNClob(param0: string): java.sql.NClob;
                setSQLXML(param0: string, param1: java.sql.SQLXML): void;
                getSQLXML(param0: number): java.sql.SQLXML;
                getSQLXML(param0: string): java.sql.SQLXML;
                getNString(param0: number): string;
                getNString(param0: string): string;
                getNCharacterStream(param0: number): java.io.Reader;
                getNCharacterStream(param0: string): java.io.Reader;
                getCharacterStream(param0: number): java.io.Reader;
                getCharacterStream(param0: string): java.io.Reader;
                setBlob(param0: string, param1: java.sql.Blob): void;
                setClob(param0: string, param1: java.sql.Clob): void;
                setAsciiStream(param0: string, param1: java.io.InputStream, param2: number): void;
                setAsciiStream(param0: string, param1: java.io.InputStream): void;
                setBinaryStream(param0: string, param1: java.io.InputStream, param2: number): void;
                setBinaryStream(param0: string, param1: java.io.InputStream): void;
                setCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;
                setCharacterStream(param0: string, param1: java.io.Reader): void;
                setNCharacterStream(param0: string, param1: java.io.Reader): void;
                setClob(param0: string, param1: java.io.Reader): void;
                setBlob(param0: string, param1: java.io.InputStream): void;
                setNClob(param0: string, param1: java.io.Reader): void;
                addBatch(): void;
                clearParameters(): void;
                execute(): boolean;
                executeQuery(): java.sql.ResultSet;
                executeUpdate(): number;
                getMetaData(): java.sql.ResultSetMetaData;
                getParameterMetaData(): java.sql.ParameterMetaData;
                setArray(param0: number, param1: java.sql.Array): void;
                setAsciiStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setBigDecimal(param0: number, param1: java.math.BigDecimal): void;
                setBinaryStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setBlob(param0: number, param1: java.sql.Blob): void;
                setBoolean(param0: number, param1: boolean): void;
                setByte(param0: number, param1: number): void;
                setBytes(param0: number, param1: native.Array<number>): void;
                setCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;
                setClob(param0: number, param1: java.sql.Clob): void;
                setDate(param0: number, param1: java.sql.Date): void;
                setDate(param0: number, param1: java.sql.Date, param2: java.util.Calendar): void;
                setDouble(param0: number, param1: number): void;
                setFloat(param0: number, param1: number): void;
                setInt(param0: number, param1: number): void;
                setLong(param0: number, param1: number): void;
                setNull(param0: number, param1: number): void;
                setNull(param0: number, param1: number, param2: string): void;
                setObject(param0: number, param1: java.lang.Object): void;
                setObject(param0: number, param1: java.lang.Object, param2: number): void;
                setObject(param0: number, param1: java.lang.Object, param2: number, param3: number): void;
                setRef(param0: number, param1: java.sql.Ref): void;
                setShort(param0: number, param1: number): void;
                setString(param0: number, param1: string): void;
                setTime(param0: number, param1: java.sql.Time): void;
                setTime(param0: number, param1: java.sql.Time, param2: java.util.Calendar): void;
                setTimestamp(param0: number, param1: java.sql.Timestamp): void;
                setTimestamp(param0: number, param1: java.sql.Timestamp, param2: java.util.Calendar): void;
                setUnicodeStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setURL(param0: number, param1: java.net.URL): void;
                setRowId(param0: number, param1: java.sql.RowId): void;
                setNString(param0: number, param1: string): void;
                setNCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;
                setNClob(param0: number, param1: java.sql.NClob): void;
                setClob(param0: number, param1: java.io.Reader, param2: number): void;
                setBlob(param0: number, param1: java.io.InputStream, param2: number): void;
                setNClob(param0: number, param1: java.io.Reader, param2: number): void;
                setSQLXML(param0: number, param1: java.sql.SQLXML): void;
                setAsciiStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setBinaryStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;
                setAsciiStream(param0: number, param1: java.io.InputStream): void;
                setBinaryStream(param0: number, param1: java.io.InputStream): void;
                setCharacterStream(param0: number, param1: java.io.Reader): void;
                setNCharacterStream(param0: number, param1: java.io.Reader): void;
                setClob(param0: number, param1: java.io.Reader): void;
                setBlob(param0: number, param1: java.io.InputStream): void;
                setNClob(param0: number, param1: java.io.Reader): void;
                addBatch(param0: string): void;
                cancel(): void;
                clearBatch(): void;
                clearWarnings(): void;
                close(): void;
                execute(param0: string): boolean;
                execute(param0: string, param1: number): boolean;
                execute(param0: string, param1: native.Array<number>): boolean;
                execute(param0: string, param1: native.Array<string>): boolean;
                executeBatch(): native.Array<number>;
                executeQuery(param0: string): java.sql.ResultSet;
                executeUpdate(param0: string): number;
                executeUpdate(param0: string, param1: number): number;
                executeUpdate(param0: string, param1: native.Array<number>): number;
                executeUpdate(param0: string, param1: native.Array<string>): number;
                getConnection(): java.sql.Connection;
                getFetchDirection(): number;
                getFetchSize(): number;
                getGeneratedKeys(): java.sql.ResultSet;
                getMaxFieldSize(): number;
                getMaxRows(): number;
                getMoreResults(): boolean;
                getMoreResults(param0: number): boolean;
                getQueryTimeout(): number;
                getResultSet(): java.sql.ResultSet;
                getResultSetConcurrency(): number;
                getResultSetHoldability(): number;
                getResultSetType(): number;
                getUpdateCount(): number;
                getWarnings(): java.sql.SQLWarning;
                setCursorName(param0: string): void;
                setEscapeProcessing(param0: boolean): void;
                setFetchDirection(param0: number): void;
                setFetchSize(param0: number): void;
                setMaxFieldSize(param0: number): void;
                setMaxRows(param0: number): void;
                setQueryTimeout(param0: number): void;
                isClosed(): boolean;
                setPoolable(param0: boolean): void;
                isPoolable(): boolean;
                unwrap(param0: java.lang.Class): java.lang.Object;
                isWrapperFor(param0: java.lang.Class): boolean;
                close(): void;
            });

            public static CLOSE_CURRENT_RESULT: number;
            public static EXECUTE_FAILED: number;
            public static KEEP_CURRENT_RESULT: number;
            public static NO_GENERATED_KEYS: number;
            public static RETURN_GENERATED_KEYS: number;
            public static CLOSE_ALL_RESULTS: number;
            public static SUCCESS_NO_INFO: number;

            public getObject(param0: number, param1: java.util.Map): java.lang.Object;

            public setNClob(param0: string, param1: java.io.Reader): void;

            public cancel(): void;

            public setNString(param0: string, param1: string): void;

            public unwrap(param0: java.lang.Class): java.lang.Object;

            public setBlob(param0: number, param1: java.io.InputStream): void;

            public setPoolable(param0: boolean): void;

            public setByte(param0: number, param1: number): void;

            public setSQLXML(param0: number, param1: java.sql.SQLXML): void;

            public addBatch(param0: string): void;

            public wasNull(): boolean;

            public registerOutParameter(param0: string, param1: number, param2: number): void;

            public setNull(param0: string, param1: number, param2: string): void;

            public getNClob(param0: string): java.sql.NClob;

            public setNCharacterStream(param0: string, param1: java.io.Reader): void;

            public setCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;

            public getObject(param0: number): java.lang.Object;

            public setNClob(param0: number, param1: java.sql.NClob): void;

            public getParameterMetaData(): java.sql.ParameterMetaData;

            public executeQuery(): java.sql.ResultSet;

            public setEscapeProcessing(param0: boolean): void;

            public getDouble(param0: string): number;

            public setBlob(param0: string, param1: java.io.InputStream): void;

            public getMoreResults(param0: number): boolean;

            public setLong(param0: string, param1: number): void;

            public getRef(param0: number): java.sql.Ref;

            public isClosed(): boolean;

            public setDate(param0: string, param1: java.sql.Date, param2: java.util.Calendar): void;

            public clearParameters(): void;

            public setObject(param0: number, param1: java.lang.Object): void;

            public getObject(param0: string): java.lang.Object;

            public setDate(param0: string, param1: java.sql.Date): void;

            public isPoolable(): boolean;

            public getSQLXML(param0: number): java.sql.SQLXML;

            public registerOutParameter(param0: string, param1: number, param2: string): void;

            public execute(param0: string): boolean;

            public getCharacterStream(param0: number): java.io.Reader;

            public registerOutParameter(param0: string, param1: number): void;

            public setClob(param0: number, param1: java.io.Reader, param2: number): void;

            public isWrapperFor(param0: java.lang.Class): boolean;

            public setUnicodeStream(param0: number, param1: java.io.InputStream, param2: number): void;

            public setBytes(param0: number, param1: native.Array<number>): void;

            public getString(param0: string): string;

            public setString(param0: string, param1: string): void;

            public setCharacterStream(param0: number, param1: java.io.Reader): void;

            public setTimestamp(param0: number, param1: java.sql.Timestamp): void;

            public setArray(param0: number, param1: java.sql.Array): void;

            public setTimestamp(param0: string, param1: java.sql.Timestamp, param2: java.util.Calendar): void;

            public setClob(param0: number, param1: java.io.Reader): void;

            public setBlob(param0: number, param1: java.io.InputStream, param2: number): void;

            public setDouble(param0: number, param1: number): void;

            public getRowId(param0: string): java.sql.RowId;

            public getArray(param0: number): java.sql.Array;

            public getDate(param0: number): java.sql.Date;

            public setClob(param0: string, param1: java.io.Reader): void;

            public getTimestamp(param0: string, param1: java.util.Calendar): java.sql.Timestamp;

            public setBlob(param0: string, param1: java.io.InputStream, param2: number): void;

            public setDouble(param0: string, param1: number): void;

            public getBoolean(param0: string): boolean;

            public setNCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;

            public setNClob(param0: string, param1: java.io.Reader, param2: number): void;

            public setFloat(param0: number, param1: number): void;

            public getBigDecimal(param0: number): java.math.BigDecimal;

            public setBlob(param0: string, param1: java.sql.Blob): void;

            public getShort(param0: number): number;

            public setBoolean(param0: number, param1: boolean): void;

            public setShort(param0: string, param1: number): void;

            public setObject(param0: number, param1: java.lang.Object, param2: number): void;

            public getDouble(param0: number): number;

            public getBytes(param0: string): native.Array<number>;

            public getString(param0: number): string;

            public setNull(param0: number, param1: number): void;

            public getFetchDirection(): number;

            public executeUpdate(): number;

            public setTimestamp(param0: number, param1: java.sql.Timestamp, param2: java.util.Calendar): void;

            public setInt(param0: number, param1: number): void;

            public getTime(param0: string, param1: java.util.Calendar): java.sql.Time;

            public getRowId(param0: number): java.sql.RowId;

            public setSQLXML(param0: string, param1: java.sql.SQLXML): void;

            public setTime(param0: string, param1: java.sql.Time, param2: java.util.Calendar): void;
            public setTime(param0: number, param1: java.sql.Time, param2: java.util.Calendar): void;

            public setURL(param0: number, param1: java.net.URL): void;

            public getRef(param0: string): java.sql.Ref;

            public getGeneratedKeys(): java.sql.ResultSet;

            public setBigDecimal(param0: number, param1: java.math.BigDecimal): void;

            public setObject(param0: string, param1: java.lang.Object, param2: number): void;

            public setTime(param0: number, param1: java.sql.Time): void;

            public getNString(param0: number): string;

            public clearBatch(): void;

            public setRowId(param0: string, param1: java.sql.RowId): void;

            public execute(): boolean;

            public getLong(param0: number): number;

            public execute(param0: string, param1: native.Array<number>): boolean;

            public getQueryTimeout(): number;

            public setAsciiStream(param0: number, param1: java.io.InputStream): void;

            public getClob(param0: string): java.sql.Clob;

            public setLong(param0: number, param1: number): void;

            public setNull(param0: number, param1: number, param2: string): void;

            public setMaxRows(param0: number): void;

            public setBinaryStream(param0: string, param1: java.io.InputStream): void;

            public setCharacterStream(param0: string, param1: java.io.Reader): void;

            public registerOutParameter(param0: number, param1: number): void;
            public registerOutParameter(param0: number, param1: number, param2: number): void;

            public clearWarnings(): void;

            public setByte(param0: string, param1: number): void;

            public setAsciiStream(param0: string, param1: java.io.InputStream): void;

            public getResultSetHoldability(): number;

            public getByte(param0: number): number;

            public getNString(param0: string): string;

            public setCursorName(param0: string): void;

            public getMoreResults(): boolean;

            public setClob(param0: number, param1: java.sql.Clob): void;

            public setBinaryStream(param0: number, param1: java.io.InputStream): void;

            public setQueryTimeout(param0: number): void;

            public setNClob(param0: number, param1: java.io.Reader): void;

            public setMaxFieldSize(param0: number): void;

            public setObject(param0: string, param1: java.lang.Object, param2: number, param3: number): void;

            public getFloat(param0: string): number;

            public setFetchSize(param0: number): void;

            public setNString(param0: number, param1: string): void;

            public getResultSet(): java.sql.ResultSet;

            public addBatch(): void;

            public setNCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;

            public getInt(param0: number): number;

            public setNull(param0: string, param1: number): void;

            public setDate(param0: number, param1: java.sql.Date): void;

            public setCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;

            public getMaxRows(): number;

            public setNClob(param0: string, param1: java.sql.NClob): void;

            public executeUpdate(param0: string, param1: native.Array<number>): number;

            public getMetaData(): java.sql.ResultSetMetaData;

            public setURL(param0: string, param1: java.net.URL): void;

            public getUpdateCount(): number;

            public executeBatch(): native.Array<number>;

            public getTimestamp(param0: number, param1: java.util.Calendar): java.sql.Timestamp;

            public setNClob(param0: number, param1: java.io.Reader, param2: number): void;

            public close(): void;

            public setFloat(param0: string, param1: number): void;

            public setDate(param0: number, param1: java.sql.Date, param2: java.util.Calendar): void;

            public getDate(param0: string): java.sql.Date;

            public getBigDecimal(param0: number, param1: number): java.math.BigDecimal;

            public getResultSetConcurrency(): number;

            public getURL(param0: number): java.net.URL;

            public executeQuery(param0: string): java.sql.ResultSet;

            public getObject(param0: string, param1: java.util.Map): java.lang.Object;

            public setBigDecimal(param0: string, param1: java.math.BigDecimal): void;

            public getShort(param0: string): number;

            public setBlob(param0: number, param1: java.sql.Blob): void;

            public getDate(param0: number, param1: java.util.Calendar): java.sql.Date;

            public setInt(param0: string, param1: number): void;

            public setBoolean(param0: string, param1: boolean): void;

            public getFloat(param0: number): number;

            public setClob(param0: string, param1: java.io.Reader, param2: number): void;

            public executeUpdate(param0: string, param1: native.Array<string>): number;

            public getWarnings(): java.sql.SQLWarning;

            public getBlob(param0: string): java.sql.Blob;

            public getSQLXML(param0: string): java.sql.SQLXML;

            public getCharacterStream(param0: string): java.io.Reader;

            public getMaxFieldSize(): number;

            public getTime(param0: number, param1: java.util.Calendar): java.sql.Time;

            public getFetchSize(): number;

            public getLong(param0: string): number;

            public getTime(param0: number): java.sql.Time;

            public getClob(param0: number): java.sql.Clob;

            public getInt(param0: string): number;

            public getArray(param0: string): java.sql.Array;

            public getByte(param0: string): number;

            public setRef(param0: number, param1: java.sql.Ref): void;

            public setClob(param0: string, param1: java.sql.Clob): void;

            public executeUpdate(param0: string, param1: number): number;

            public getNCharacterStream(param0: string): java.io.Reader;

            public getBoolean(param0: number): boolean;

            public setString(param0: number, param1: string): void;

            public getBytes(param0: number): native.Array<number>;

            public setRowId(param0: number, param1: java.sql.RowId): void;

            public getTimestamp(param0: string): java.sql.Timestamp;

            public getTime(param0: string): java.sql.Time;

            public setShort(param0: number, param1: number): void;

            public getBlob(param0: number): java.sql.Blob;

            public setTime(param0: string, param1: java.sql.Time): void;

            public setBinaryStream(param0: number, param1: java.io.InputStream, param2: number): void;

            public setObject(param0: string, param1: java.lang.Object): void;

            public getDate(param0: string, param1: java.util.Calendar): java.sql.Date;

            public getNClob(param0: number): java.sql.NClob;

            public execute(param0: string, param1: number): boolean;

            public getConnection(): java.sql.Connection;

            public getURL(param0: string): java.net.URL;

            public getTimestamp(param0: number): java.sql.Timestamp;

            public getResultSetType(): number;

            public executeUpdate(param0: string): number;

            public setBinaryStream(param0: string, param1: java.io.InputStream, param2: number): void;

            public setBytes(param0: string, param1: native.Array<number>): void;

            public setObject(param0: number, param1: java.lang.Object, param2: number, param3: number): void;

            public getNCharacterStream(param0: number): java.io.Reader;

            public setNCharacterStream(param0: number, param1: java.io.Reader): void;

            public registerOutParameter(param0: number, param1: number, param2: string): void;

            public setFetchDirection(param0: number): void;

            public getBigDecimal(param0: string): java.math.BigDecimal;

            public setAsciiStream(param0: string, param1: java.io.InputStream, param2: number): void;

            public setTimestamp(param0: string, param1: java.sql.Timestamp): void;

            public setAsciiStream(param0: number, param1: java.io.InputStream, param2: number): void;

            public execute(param0: string, param1: native.Array<string>): boolean;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module sql {
        export class ClientInfoStatus extends java.lang.Enum {
            public static REASON_UNKNOWN: java.sql.ClientInfoStatus;
            public static REASON_UNKNOWN_PROPERTY: java.sql.ClientInfoStatus;
            public static REASON_VALUE_INVALID: java.sql.ClientInfoStatus;
            public static REASON_VALUE_TRUNCATED: java.sql.ClientInfoStatus;

            public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;

            public static values(): native.Array<java.sql.ClientInfoStatus>;

            public static valueOf(param0: string): java.sql.ClientInfoStatus;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module sql {
        export class Clob extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.Clob interface with the provided implementation.
             */
            public constructor(implementation: {
                getAsciiStream(): java.io.InputStream;
                getCharacterStream(): java.io.Reader;
                getSubString(param0: number, param1: number): string;
                length(): number;
                position(param0: java.sql.Clob, param1: number): number;
                position(param0: string, param1: number): number;
                setAsciiStream(param0: number): java.io.OutputStream;
                setCharacterStream(param0: number): java.io.Writer;
                setString(param0: number, param1: string): number;
                setString(param0: number, param1: string, param2: number, param3: number): number;
                truncate(param0: number): void;
                free(): void;
                getCharacterStream(param0: number, param1: number): java.io.Reader;
            });

            public getSubString(param0: number, param1: number): string;

            public setCharacterStream(param0: number): java.io.Writer;

            public free(): void;

            public truncate(param0: number): void;

            public getCharacterStream(param0: number, param1: number): java.io.Reader;

            public length(): number;

            public setString(param0: number, param1: string, param2: number, param3: number): number;
            public setString(param0: number, param1: string): number;

            public getCharacterStream(): java.io.Reader;

            public position(param0: string, param1: number): number;

            public setAsciiStream(param0: number): java.io.OutputStream;

            public position(param0: java.sql.Clob, param1: number): number;

            public getAsciiStream(): java.io.InputStream;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.sql.Array.d.ts" />
/// <reference path="./java.sql.Blob.d.ts" />
/// <reference path="./java.sql.CallableStatement.d.ts" />
/// <reference path="./java.sql.Clob.d.ts" />
/// <reference path="./java.sql.DatabaseMetaData.d.ts" />
/// <reference path="./java.sql.NClob.d.ts" />
/// <reference path="./java.sql.PreparedStatement.d.ts" />
/// <reference path="./java.sql.SQLWarning.d.ts" />
/// <reference path="./java.sql.SQLXML.d.ts" />
/// <reference path="./java.sql.Savepoint.d.ts" />
/// <reference path="./java.sql.Statement.d.ts" />
/// <reference path="./java.sql.Struct.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Properties.d.ts" />
declare module java {
    export module sql {
        export class Connection extends java.lang.Object implements java.sql.Wrapper, java.lang.AutoCloseable {
            /**
             * Constructs a new instance of the java.sql.Connection interface with the provided implementation.
             */
            public constructor(implementation: {
                clearWarnings(): void;
                close(): void;
                commit(): void;
                createStatement(): java.sql.Statement;
                createStatement(param0: number, param1: number): java.sql.Statement;
                createStatement(param0: number, param1: number, param2: number): java.sql.Statement;
                getAutoCommit(): boolean;
                getCatalog(): string;
                getHoldability(): number;
                getMetaData(): java.sql.DatabaseMetaData;
                getTransactionIsolation(): number;
                getTypeMap(): java.util.Map;
                getWarnings(): java.sql.SQLWarning;
                isClosed(): boolean;
                isReadOnly(): boolean;
                nativeSQL(param0: string): string;
                prepareCall(param0: string): java.sql.CallableStatement;
                prepareCall(param0: string, param1: number, param2: number): java.sql.CallableStatement;
                prepareCall(param0: string, param1: number, param2: number, param3: number): java.sql.CallableStatement;
                prepareStatement(param0: string): java.sql.PreparedStatement;
                prepareStatement(param0: string, param1: number): java.sql.PreparedStatement;
                prepareStatement(param0: string, param1: native.Array<number>): java.sql.PreparedStatement;
                prepareStatement(param0: string, param1: number, param2: number): java.sql.PreparedStatement;
                prepareStatement(param0: string, param1: number, param2: number, param3: number): java.sql.PreparedStatement;
                prepareStatement(param0: string, param1: native.Array<string>): java.sql.PreparedStatement;
                releaseSavepoint(param0: java.sql.Savepoint): void;
                rollback(): void;
                rollback(param0: java.sql.Savepoint): void;
                setAutoCommit(param0: boolean): void;
                setCatalog(param0: string): void;
                setHoldability(param0: number): void;
                setReadOnly(param0: boolean): void;
                setSavepoint(): java.sql.Savepoint;
                setSavepoint(param0: string): java.sql.Savepoint;
                setTransactionIsolation(param0: number): void;
                setTypeMap(param0: java.util.Map): void;
                createClob(): java.sql.Clob;
                createBlob(): java.sql.Blob;
                createNClob(): java.sql.NClob;
                createSQLXML(): java.sql.SQLXML;
                isValid(param0: number): boolean;
                setClientInfo(param0: string, param1: string): void;
                setClientInfo(param0: java.util.Properties): void;
                getClientInfo(param0: string): string;
                getClientInfo(): java.util.Properties;
                createArrayOf(param0: string, param1: native.Array<java.lang.Object>): java.sql.Array;
                createStruct(param0: string, param1: native.Array<java.lang.Object>): java.sql.Struct;
                unwrap(param0: java.lang.Class): java.lang.Object;
                isWrapperFor(param0: java.lang.Class): boolean;
                close(): void;
            });

            public static TRANSACTION_READ_COMMITTED: number;
            public static TRANSACTION_NONE: number;
            public static TRANSACTION_READ_UNCOMMITTED: number;
            public static TRANSACTION_SERIALIZABLE: number;
            public static TRANSACTION_REPEATABLE_READ: number;

            public isReadOnly(): boolean;

            public rollback(param0: java.sql.Savepoint): void;

            public commit(): void;

            public releaseSavepoint(param0: java.sql.Savepoint): void;

            public setSavepoint(param0: string): java.sql.Savepoint;

            public unwrap(param0: java.lang.Class): java.lang.Object;

            public createSQLXML(): java.sql.SQLXML;

            public getWarnings(): java.sql.SQLWarning;

            public isValid(param0: number): boolean;

            public prepareStatement(param0: string): java.sql.PreparedStatement;
            public prepareStatement(param0: string, param1: native.Array<string>): java.sql.PreparedStatement;

            public clearWarnings(): void;

            public getClientInfo(param0: string): string;

            public setClientInfo(param0: string, param1: string): void;

            public getMetaData(): java.sql.DatabaseMetaData;

            public prepareCall(param0: string, param1: number, param2: number): java.sql.CallableStatement;

            public setTypeMap(param0: java.util.Map): void;

            public prepareCall(param0: string): java.sql.CallableStatement;

            public prepareStatement(param0: string, param1: number, param2: number): java.sql.PreparedStatement;

            public rollback(): void;

            public setHoldability(param0: number): void;

            public prepareStatement(param0: string, param1: number, param2: number, param3: number): java.sql.PreparedStatement;

            public createStatement(): java.sql.Statement;

            public createNClob(): java.sql.NClob;

            public isClosed(): boolean;

            public createStatement(param0: number, param1: number): java.sql.Statement;

            public setCatalog(param0: string): void;

            public setSavepoint(): java.sql.Savepoint;

            public setReadOnly(param0: boolean): void;

            public getTypeMap(): java.util.Map;

            public createStatement(param0: number, param1: number, param2: number): java.sql.Statement;

            public getCatalog(): string;

            public createClob(): java.sql.Clob;

            public setAutoCommit(param0: boolean): void;

            public getClientInfo(): java.util.Properties;

            public getHoldability(): number;

            public close(): void;

            public createBlob(): java.sql.Blob;

            public prepareStatement(param0: string, param1: number): java.sql.PreparedStatement;

            public setClientInfo(param0: java.util.Properties): void;

            public prepareCall(param0: string, param1: number, param2: number, param3: number): java.sql.CallableStatement;

            public isWrapperFor(param0: java.lang.Class): boolean;

            public createStruct(param0: string, param1: native.Array<java.lang.Object>): java.sql.Struct;

            public setTransactionIsolation(param0: number): void;

            public createArrayOf(param0: string, param1: native.Array<java.lang.Object>): java.sql.Array;

            public nativeSQL(param0: string): string;

            public getAutoCommit(): boolean;

            public getTransactionIsolation(): number;

            public prepareStatement(param0: string, param1: native.Array<number>): java.sql.PreparedStatement;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class DataTruncation extends java.sql.SQLWarning implements java.io.Serializable {
            public constructor(param0: number, param1: boolean, param2: boolean, param3: number, param4: number);

            public getIndex(): number;

            public constructor(param0: java.lang.Throwable);

            public getParameter(): boolean;

            public getDataSize(): number;

            public constructor();
            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: number, param1: boolean, param2: boolean, param3: number, param4: number, param5: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);

            public getTransferSize(): number;

            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public getRead(): boolean;

            public iterator(): java.util.Iterator;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.sql.Connection.d.ts" />
/// <reference path="./java.sql.ResultSet.d.ts" />
/// <reference path="./java.sql.RowIdLifetime.d.ts" />
declare module java {
    export module sql {
        export class DatabaseMetaData extends java.lang.Object implements java.sql.Wrapper {
            /**
             * Constructs a new instance of the java.sql.DatabaseMetaData interface with the provided implementation.
             */
            public constructor(implementation: {
                allProceduresAreCallable(): boolean;
                allTablesAreSelectable(): boolean;
                dataDefinitionCausesTransactionCommit(): boolean;
                dataDefinitionIgnoredInTransactions(): boolean;
                deletesAreDetected(param0: number): boolean;
                doesMaxRowSizeIncludeBlobs(): boolean;
                getAttributes(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;
                getBestRowIdentifier(param0: string, param1: string, param2: string, param3: number, param4: boolean): java.sql.ResultSet;
                getCatalogs(): java.sql.ResultSet;
                getCatalogSeparator(): string;
                getCatalogTerm(): string;
                getColumnPrivileges(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;
                getColumns(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;
                getConnection(): java.sql.Connection;
                getCrossReference(param0: string, param1: string, param2: string, param3: string, param4: string, param5: string): java.sql.ResultSet;
                getDatabaseMajorVersion(): number;
                getDatabaseMinorVersion(): number;
                getDatabaseProductName(): string;
                getDatabaseProductVersion(): string;
                getDefaultTransactionIsolation(): number;
                getDriverMajorVersion(): number;
                getDriverMinorVersion(): number;
                getDriverName(): string;
                getDriverVersion(): string;
                getExportedKeys(param0: string, param1: string, param2: string): java.sql.ResultSet;
                getExtraNameCharacters(): string;
                getIdentifierQuoteString(): string;
                getImportedKeys(param0: string, param1: string, param2: string): java.sql.ResultSet;
                getIndexInfo(param0: string, param1: string, param2: string, param3: boolean, param4: boolean): java.sql.ResultSet;
                getJDBCMajorVersion(): number;
                getJDBCMinorVersion(): number;
                getMaxBinaryLiteralLength(): number;
                getMaxCatalogNameLength(): number;
                getMaxCharLiteralLength(): number;
                getMaxColumnNameLength(): number;
                getMaxColumnsInGroupBy(): number;
                getMaxColumnsInIndex(): number;
                getMaxColumnsInOrderBy(): number;
                getMaxColumnsInSelect(): number;
                getMaxColumnsInTable(): number;
                getMaxConnections(): number;
                getMaxCursorNameLength(): number;
                getMaxIndexLength(): number;
                getMaxProcedureNameLength(): number;
                getMaxRowSize(): number;
                getMaxSchemaNameLength(): number;
                getMaxStatementLength(): number;
                getMaxStatements(): number;
                getMaxTableNameLength(): number;
                getMaxTablesInSelect(): number;
                getMaxUserNameLength(): number;
                getNumericFunctions(): string;
                getPrimaryKeys(param0: string, param1: string, param2: string): java.sql.ResultSet;
                getProcedureColumns(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;
                getProcedures(param0: string, param1: string, param2: string): java.sql.ResultSet;
                getProcedureTerm(): string;
                getResultSetHoldability(): number;
                getSchemas(): java.sql.ResultSet;
                getSchemaTerm(): string;
                getSearchStringEscape(): string;
                getSQLKeywords(): string;
                getSQLStateType(): number;
                getStringFunctions(): string;
                getSuperTables(param0: string, param1: string, param2: string): java.sql.ResultSet;
                getSuperTypes(param0: string, param1: string, param2: string): java.sql.ResultSet;
                getSystemFunctions(): string;
                getTablePrivileges(param0: string, param1: string, param2: string): java.sql.ResultSet;
                getTables(param0: string, param1: string, param2: string, param3: native.Array<string>): java.sql.ResultSet;
                getTableTypes(): java.sql.ResultSet;
                getTimeDateFunctions(): string;
                getTypeInfo(): java.sql.ResultSet;
                getUDTs(param0: string, param1: string, param2: string, param3: native.Array<number>): java.sql.ResultSet;
                getURL(): string;
                getUserName(): string;
                getVersionColumns(param0: string, param1: string, param2: string): java.sql.ResultSet;
                insertsAreDetected(param0: number): boolean;
                isCatalogAtStart(): boolean;
                isReadOnly(): boolean;
                locatorsUpdateCopy(): boolean;
                nullPlusNonNullIsNull(): boolean;
                nullsAreSortedAtEnd(): boolean;
                nullsAreSortedAtStart(): boolean;
                nullsAreSortedHigh(): boolean;
                nullsAreSortedLow(): boolean;
                othersDeletesAreVisible(param0: number): boolean;
                othersInsertsAreVisible(param0: number): boolean;
                othersUpdatesAreVisible(param0: number): boolean;
                ownDeletesAreVisible(param0: number): boolean;
                ownInsertsAreVisible(param0: number): boolean;
                ownUpdatesAreVisible(param0: number): boolean;
                storesLowerCaseIdentifiers(): boolean;
                storesLowerCaseQuotedIdentifiers(): boolean;
                storesMixedCaseIdentifiers(): boolean;
                storesMixedCaseQuotedIdentifiers(): boolean;
                storesUpperCaseIdentifiers(): boolean;
                storesUpperCaseQuotedIdentifiers(): boolean;
                supportsAlterTableWithAddColumn(): boolean;
                supportsAlterTableWithDropColumn(): boolean;
                supportsANSI92EntryLevelSQL(): boolean;
                supportsANSI92FullSQL(): boolean;
                supportsANSI92IntermediateSQL(): boolean;
                supportsBatchUpdates(): boolean;
                supportsCatalogsInDataManipulation(): boolean;
                supportsCatalogsInIndexDefinitions(): boolean;
                supportsCatalogsInPrivilegeDefinitions(): boolean;
                supportsCatalogsInProcedureCalls(): boolean;
                supportsCatalogsInTableDefinitions(): boolean;
                supportsColumnAliasing(): boolean;
                supportsConvert(): boolean;
                supportsConvert(param0: number, param1: number): boolean;
                supportsCoreSQLGrammar(): boolean;
                supportsCorrelatedSubqueries(): boolean;
                supportsDataDefinitionAndDataManipulationTransactions(): boolean;
                supportsDataManipulationTransactionsOnly(): boolean;
                supportsDifferentTableCorrelationNames(): boolean;
                supportsExpressionsInOrderBy(): boolean;
                supportsExtendedSQLGrammar(): boolean;
                supportsFullOuterJoins(): boolean;
                supportsGetGeneratedKeys(): boolean;
                supportsGroupBy(): boolean;
                supportsGroupByBeyondSelect(): boolean;
                supportsGroupByUnrelated(): boolean;
                supportsIntegrityEnhancementFacility(): boolean;
                supportsLikeEscapeClause(): boolean;
                supportsLimitedOuterJoins(): boolean;
                supportsMinimumSQLGrammar(): boolean;
                supportsMixedCaseIdentifiers(): boolean;
                supportsMixedCaseQuotedIdentifiers(): boolean;
                supportsMultipleOpenResults(): boolean;
                supportsMultipleResultSets(): boolean;
                supportsMultipleTransactions(): boolean;
                supportsNamedParameters(): boolean;
                supportsNonNullableColumns(): boolean;
                supportsOpenCursorsAcrossCommit(): boolean;
                supportsOpenCursorsAcrossRollback(): boolean;
                supportsOpenStatementsAcrossCommit(): boolean;
                supportsOpenStatementsAcrossRollback(): boolean;
                supportsOrderByUnrelated(): boolean;
                supportsOuterJoins(): boolean;
                supportsPositionedDelete(): boolean;
                supportsPositionedUpdate(): boolean;
                supportsResultSetConcurrency(param0: number, param1: number): boolean;
                supportsResultSetHoldability(param0: number): boolean;
                supportsResultSetType(param0: number): boolean;
                supportsSavepoints(): boolean;
                supportsSchemasInDataManipulation(): boolean;
                supportsSchemasInIndexDefinitions(): boolean;
                supportsSchemasInPrivilegeDefinitions(): boolean;
                supportsSchemasInProcedureCalls(): boolean;
                supportsSchemasInTableDefinitions(): boolean;
                supportsSelectForUpdate(): boolean;
                supportsStatementPooling(): boolean;
                supportsStoredProcedures(): boolean;
                supportsSubqueriesInComparisons(): boolean;
                supportsSubqueriesInExists(): boolean;
                supportsSubqueriesInIns(): boolean;
                supportsSubqueriesInQuantifieds(): boolean;
                supportsTableCorrelationNames(): boolean;
                supportsTransactionIsolationLevel(param0: number): boolean;
                supportsTransactions(): boolean;
                supportsUnion(): boolean;
                supportsUnionAll(): boolean;
                updatesAreDetected(param0: number): boolean;
                usesLocalFilePerTable(): boolean;
                usesLocalFiles(): boolean;
                autoCommitFailureClosesAllResultSets(): boolean;
                getClientInfoProperties(): java.sql.ResultSet;
                getFunctionColumns(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;
                getFunctions(param0: string, param1: string, param2: string): java.sql.ResultSet;
                getRowIdLifetime(): java.sql.RowIdLifetime;
                getSchemas(param0: string, param1: string): java.sql.ResultSet;
                supportsStoredFunctionsUsingCallSyntax(): boolean;
                unwrap(param0: java.lang.Class): java.lang.Object;
                isWrapperFor(param0: java.lang.Class): boolean;
            });

            public static bestRowNotPseudo: number;
            public static procedureColumnOut: number;
            public static attributeNullableUnknown: number;
            public static typePredNone: number;
            public static functionNoTable: number;
            public static typeNoNulls: number;
            public static functionColumnOut: number;
            public static typeNullable: number;
            public static bestRowTemporary: number;
            public static importedKeyInitiallyImmediate: number;
            public static tableIndexHashed: number;
            public static versionColumnUnknown: number;
            public static functionColumnUnknown: number;
            public static versionColumnNotPseudo: number;
            public static versionColumnPseudo: number;
            public static importedKeyNotDeferrable: number;
            public static functionColumnInOut: number;
            public static bestRowPseudo: number;
            public static procedureNullable: number;
            public static procedureColumnResult: number;
            public static tableIndexClustered: number;
            public static importedKeySetNull: number;
            public static importedKeyRestrict: number;
            public static columnNoNulls: number;
            public static bestRowTransaction: number;
            public static typePredChar: number;
            public static columnNullableUnknown: number;
            public static procedureColumnUnknown: number;
            public static procedureColumnInOut: number;
            public static functionNullable: number;
            public static attributeNullable: number;
            public static procedureColumnReturn: number;
            public static functionReturnsTable: number;
            public static functionNullableUnknown: number;
            public static functionColumnIn: number;
            public static functionReturn: number;
            public static importedKeySetDefault: number;
            public static bestRowSession: number;
            public static tableIndexStatistic: number;
            public static procedureNoNulls: number;
            public static procedureNullableUnknown: number;
            public static typeSearchable: number;
            public static importedKeyNoAction: number;
            public static sqlStateSQL99: number;
            public static sqlStateSQL: number;
            public static functionNoNulls: number;
            public static importedKeyCascade: number;
            public static procedureNoResult: number;
            public static tableIndexOther: number;
            public static columnNullable: number;
            public static importedKeyInitiallyDeferred: number;
            public static procedureColumnIn: number;
            public static typeNullableUnknown: number;
            public static typePredBasic: number;
            public static procedureResultUnknown: number;
            public static functionColumnResult: number;
            public static attributeNoNulls: number;
            public static procedureReturnsResult: number;
            public static sqlStateXOpen: number;
            public static functionResultUnknown: number;
            public static bestRowUnknown: number;

            public isReadOnly(): boolean;

            public nullsAreSortedAtStart(): boolean;

            public storesUpperCaseIdentifiers(): boolean;

            public supportsBatchUpdates(): boolean;

            public getDatabaseMajorVersion(): number;

            public updatesAreDetected(param0: number): boolean;

            public getJDBCMinorVersion(): number;

            public supportsNonNullableColumns(): boolean;

            public othersInsertsAreVisible(param0: number): boolean;

            public getRowIdLifetime(): java.sql.RowIdLifetime;

            public getNumericFunctions(): string;

            public supportsSubqueriesInQuantifieds(): boolean;

            public ownUpdatesAreVisible(param0: number): boolean;

            public supportsSchemasInProcedureCalls(): boolean;

            public getMaxStatementLength(): number;

            public unwrap(param0: java.lang.Class): java.lang.Object;

            public getColumnPrivileges(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;

            public supportsMixedCaseIdentifiers(): boolean;

            public getTypeInfo(): java.sql.ResultSet;

            public usesLocalFiles(): boolean;

            public getMaxCatalogNameLength(): number;

            public getStringFunctions(): string;

            public supportsSchemasInTableDefinitions(): boolean;

            public getSystemFunctions(): string;

            public getFunctionColumns(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;

            public isCatalogAtStart(): boolean;

            public getMaxSchemaNameLength(): number;

            public supportsMultipleResultSets(): boolean;

            public getDatabaseProductVersion(): string;

            public getResultSetHoldability(): number;

            public getDriverMajorVersion(): number;

            public usesLocalFilePerTable(): boolean;

            public supportsStatementPooling(): boolean;

            public getFunctions(param0: string, param1: string, param2: string): java.sql.ResultSet;

            public supportsResultSetHoldability(param0: number): boolean;

            public supportsUnionAll(): boolean;

            public storesLowerCaseIdentifiers(): boolean;

            public supportsAlterTableWithDropColumn(): boolean;

            public supportsStoredProcedures(): boolean;

            public getProcedureColumns(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;

            public supportsOpenCursorsAcrossCommit(): boolean;

            public getExtraNameCharacters(): string;

            public supportsPositionedDelete(): boolean;

            public getMaxColumnsInOrderBy(): number;

            public supportsConvert(): boolean;

            public supportsANSI92EntryLevelSQL(): boolean;

            public getSchemas(): java.sql.ResultSet;

            public nullsAreSortedAtEnd(): boolean;

            public getDefaultTransactionIsolation(): number;

            public supportsOpenStatementsAcrossRollback(): boolean;

            public supportsOuterJoins(): boolean;

            public getDriverMinorVersion(): number;

            public getMaxBinaryLiteralLength(): number;

            public supportsAlterTableWithAddColumn(): boolean;

            public supportsLikeEscapeClause(): boolean;

            public getMaxColumnNameLength(): number;

            public getPrimaryKeys(param0: string, param1: string, param2: string): java.sql.ResultSet;

            public dataDefinitionIgnoredInTransactions(): boolean;

            public getMaxCharLiteralLength(): number;

            public ownInsertsAreVisible(param0: number): boolean;

            public getMaxStatements(): number;

            public supportsPositionedUpdate(): boolean;

            public getIndexInfo(param0: string, param1: string, param2: string, param3: boolean, param4: boolean): java.sql.ResultSet;

            public nullsAreSortedLow(): boolean;

            public supportsSavepoints(): boolean;

            public supportsGroupBy(): boolean;

            public supportsOpenCursorsAcrossRollback(): boolean;

            public getProcedureTerm(): string;

            public supportsUnion(): boolean;

            public supportsConvert(param0: number, param1: number): boolean;

            public supportsResultSetType(param0: number): boolean;

            public nullPlusNonNullIsNull(): boolean;

            public getMaxConnections(): number;

            public supportsColumnAliasing(): boolean;

            public supportsGroupByBeyondSelect(): boolean;

            public getIdentifierQuoteString(): string;

            public getMaxTablesInSelect(): number;

            public nullsAreSortedHigh(): boolean;

            public getSchemas(param0: string, param1: string): java.sql.ResultSet;

            public isWrapperFor(param0: java.lang.Class): boolean;

            public storesUpperCaseQuotedIdentifiers(): boolean;

            public getMaxColumnsInSelect(): number;

            public dataDefinitionCausesTransactionCommit(): boolean;

            public supportsOrderByUnrelated(): boolean;

            public getDriverName(): string;

            public getSQLKeywords(): string;

            public supportsFullOuterJoins(): boolean;

            public doesMaxRowSizeIncludeBlobs(): boolean;

            public getSearchStringEscape(): string;

            public storesMixedCaseIdentifiers(): boolean;

            public getMaxProcedureNameLength(): number;

            public getUDTs(param0: string, param1: string, param2: string, param3: native.Array<number>): java.sql.ResultSet;

            public supportsSchemasInPrivilegeDefinitions(): boolean;

            public supportsStoredFunctionsUsingCallSyntax(): boolean;

            public supportsCatalogsInPrivilegeDefinitions(): boolean;

            public supportsMinimumSQLGrammar(): boolean;

            public getTableTypes(): java.sql.ResultSet;

            public supportsSubqueriesInExists(): boolean;

            public supportsMixedCaseQuotedIdentifiers(): boolean;

            public supportsCatalogsInProcedureCalls(): boolean;

            public supportsGroupByUnrelated(): boolean;

            public getImportedKeys(param0: string, param1: string, param2: string): java.sql.ResultSet;

            public getSuperTypes(param0: string, param1: string, param2: string): java.sql.ResultSet;

            public getMaxColumnsInGroupBy(): number;

            public getMaxIndexLength(): number;

            public supportsCoreSQLGrammar(): boolean;

            public getDatabaseMinorVersion(): number;

            public supportsExpressionsInOrderBy(): boolean;

            public supportsSchemasInDataManipulation(): boolean;

            public supportsDataDefinitionAndDataManipulationTransactions(): boolean;

            public supportsTransactions(): boolean;

            public getClientInfoProperties(): java.sql.ResultSet;

            public supportsOpenStatementsAcrossCommit(): boolean;

            public supportsGetGeneratedKeys(): boolean;

            public supportsDataManipulationTransactionsOnly(): boolean;

            public supportsCatalogsInDataManipulation(): boolean;

            public othersDeletesAreVisible(param0: number): boolean;

            public allTablesAreSelectable(): boolean;

            public getCrossReference(param0: string, param1: string, param2: string, param3: string, param4: string, param5: string): java.sql.ResultSet;

            public ownDeletesAreVisible(param0: number): boolean;

            public storesMixedCaseQuotedIdentifiers(): boolean;

            public supportsCorrelatedSubqueries(): boolean;

            public getProcedures(param0: string, param1: string, param2: string): java.sql.ResultSet;

            public getMaxColumnsInIndex(): number;

            public getSQLStateType(): number;

            public getTimeDateFunctions(): string;

            public supportsMultipleTransactions(): boolean;

            public getCatalogTerm(): string;

            public getTablePrivileges(param0: string, param1: string, param2: string): java.sql.ResultSet;

            public supportsCatalogsInTableDefinitions(): boolean;

            public getSchemaTerm(): string;

            public insertsAreDetected(param0: number): boolean;

            public getColumns(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;

            public getVersionColumns(param0: string, param1: string, param2: string): java.sql.ResultSet;

            public supportsSubqueriesInIns(): boolean;

            public getMaxUserNameLength(): number;

            public getDatabaseProductName(): string;

            public deletesAreDetected(param0: number): boolean;

            public getCatalogs(): java.sql.ResultSet;

            public othersUpdatesAreVisible(param0: number): boolean;

            public getCatalogSeparator(): string;

            public getTables(param0: string, param1: string, param2: string, param3: native.Array<string>): java.sql.ResultSet;

            public supportsTransactionIsolationLevel(param0: number): boolean;

            public supportsMultipleOpenResults(): boolean;

            public storesLowerCaseQuotedIdentifiers(): boolean;

            public getMaxColumnsInTable(): number;

            public getConnection(): java.sql.Connection;

            public getMaxTableNameLength(): number;

            public locatorsUpdateCopy(): boolean;

            public getDriverVersion(): string;

            public supportsSelectForUpdate(): boolean;

            public supportsANSI92FullSQL(): boolean;

            public supportsCatalogsInIndexDefinitions(): boolean;

            public supportsExtendedSQLGrammar(): boolean;

            public getBestRowIdentifier(param0: string, param1: string, param2: string, param3: number, param4: boolean): java.sql.ResultSet;

            public getAttributes(param0: string, param1: string, param2: string, param3: string): java.sql.ResultSet;

            public getSuperTables(param0: string, param1: string, param2: string): java.sql.ResultSet;

            public supportsIntegrityEnhancementFacility(): boolean;

            public supportsNamedParameters(): boolean;

            public supportsSchemasInIndexDefinitions(): boolean;

            public allProceduresAreCallable(): boolean;

            public getUserName(): string;

            public getExportedKeys(param0: string, param1: string, param2: string): java.sql.ResultSet;

            public getMaxRowSize(): number;

            public autoCommitFailureClosesAllResultSets(): boolean;

            public getURL(): string;

            public supportsANSI92IntermediateSQL(): boolean;

            public supportsResultSetConcurrency(param0: number, param1: number): boolean;

            public supportsSubqueriesInComparisons(): boolean;

            public supportsTableCorrelationNames(): boolean;

            public getJDBCMajorVersion(): number;

            public supportsDifferentTableCorrelationNames(): boolean;

            public getMaxCursorNameLength(): number;

            public supportsLimitedOuterJoins(): boolean;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module sql {
        export class Date extends java.util.Date {
            public constructor(param0: number, param1: number, param2: number);

            public static valueOf(param0: string): java.sql.Date;

            public getSeconds(): number;

            public setHours(param0: number): void;

            public constructor(param0: number);
            public constructor();

            public setSeconds(param0: number): void;

            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number);

            public setMinutes(param0: number): void;

            public toString(): string;

            public setTime(param0: number): void;

            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number);

            public getHours(): number;

            public getMinutes(): number;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.sql.Connection.d.ts" />
/// <reference path="./java.sql.DriverPropertyInfo.d.ts" />
/// <reference path="./java.util.Properties.d.ts" />
declare module java {
    export module sql {
        export class Driver extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.Driver interface with the provided implementation.
             */
            public constructor(implementation: {
                acceptsURL(param0: string): boolean;
                connect(param0: string, param1: java.util.Properties): java.sql.Connection;
                getMajorVersion(): number;
                getMinorVersion(): number;
                getPropertyInfo(param0: string, param1: java.util.Properties): native.Array<java.sql.DriverPropertyInfo>;
                jdbcCompliant(): boolean;
            });

            public connect(param0: string, param1: java.util.Properties): java.sql.Connection;

            public getMinorVersion(): number;

            public getMajorVersion(): number;

            public jdbcCompliant(): boolean;

            public acceptsURL(param0: string): boolean;

            public getPropertyInfo(param0: string, param1: java.util.Properties): native.Array<java.sql.DriverPropertyInfo>;
        }
    }
}

/// <reference path="./java.io.PrintStream.d.ts" />
/// <reference path="./java.io.PrintWriter.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.sql.Connection.d.ts" />
/// <reference path="./java.sql.Driver.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.Properties.d.ts" />
declare module java {
    export module sql {
        export class DriverManager extends java.lang.Object {
            public static deregisterDriver(param0: java.sql.Driver): void;

            public static getConnection(param0: string, param1: string, param2: string): java.sql.Connection;

            public static getLogStream(): java.io.PrintStream;

            public static getDriver(param0: string): java.sql.Driver;

            public static getConnection(param0: string, param1: java.util.Properties): java.sql.Connection;

            public static setLogWriter(param0: java.io.PrintWriter): void;

            public static setLogStream(param0: java.io.PrintStream): void;

            public static getLogWriter(): java.io.PrintWriter;

            public static getConnection(param0: string): java.sql.Connection;

            public static getLoginTimeout(): number;

            public static println(param0: string): void;

            public static registerDriver(param0: java.sql.Driver): void;

            public static getDrivers(): java.util.Enumeration;

            public static setLoginTimeout(param0: number): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module sql {
        export class DriverPropertyInfo extends java.lang.Object {
            public choices: native.Array<string>;
            public description: string;
            public name: string;
            public required: boolean;
            public value: string;

            public constructor(param0: string, param1: string);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.sql.Clob.d.ts" />
declare module java {
    export module sql {
        export class NClob extends java.lang.Object implements java.sql.Clob {
            /**
             * Constructs a new instance of the java.sql.NClob interface with the provided implementation.
             */
            public constructor(implementation: {
                getAsciiStream(): java.io.InputStream;
                getCharacterStream(): java.io.Reader;
                getSubString(param0: number, param1: number): string;
                length(): number;
                position(param0: java.sql.Clob, param1: number): number;
                position(param0: string, param1: number): number;
                setAsciiStream(param0: number): java.io.OutputStream;
                setCharacterStream(param0: number): java.io.Writer;
                setString(param0: number, param1: string): number;
                setString(param0: number, param1: string, param2: number, param3: number): number;
                truncate(param0: number): void;
                free(): void;
                getCharacterStream(param0: number, param1: number): java.io.Reader;
            });

            public getSubString(param0: number, param1: number): string;

            public setCharacterStream(param0: number): java.io.Writer;

            public free(): void;

            public truncate(param0: number): void;

            public getCharacterStream(param0: number, param1: number): java.io.Reader;

            public length(): number;

            public setString(param0: number, param1: string, param2: number, param3: number): number;
            public setString(param0: number, param1: string): number;

            public getCharacterStream(): java.io.Reader;

            public position(param0: string, param1: number): number;

            public setAsciiStream(param0: number): java.io.OutputStream;

            public position(param0: java.sql.Clob, param1: number): number;

            public getAsciiStream(): java.io.InputStream;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module sql {
        export class ParameterMetaData extends java.lang.Object implements java.sql.Wrapper {
            /**
             * Constructs a new instance of the java.sql.ParameterMetaData interface with the provided implementation.
             */
            public constructor(implementation: {
                getParameterClassName(param0: number): string;
                getParameterCount(): number;
                getParameterMode(param0: number): number;
                getParameterType(param0: number): number;
                getParameterTypeName(param0: number): string;
                getPrecision(param0: number): number;
                getScale(param0: number): number;
                isNullable(param0: number): number;
                isSigned(param0: number): boolean;
                unwrap(param0: java.lang.Class): java.lang.Object;
                isWrapperFor(param0: java.lang.Class): boolean;
            });

            public static parameterNullableUnknown: number;
            public static parameterModeIn: number;
            public static parameterNoNulls: number;
            public static parameterModeOut: number;
            public static parameterModeInOut: number;
            public static parameterNullable: number;
            public static parameterModeUnknown: number;

            public isWrapperFor(param0: java.lang.Class): boolean;

            public getParameterMode(param0: number): number;

            public getParameterType(param0: number): number;

            public getParameterClassName(param0: number): string;

            public getPrecision(param0: number): number;

            public unwrap(param0: java.lang.Class): java.lang.Object;

            public getParameterCount(): number;

            public getParameterTypeName(param0: number): string;

            public isSigned(param0: number): boolean;

            public getScale(param0: number): number;

            public isNullable(param0: number): number;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigDecimal.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.sql.Array.d.ts" />
/// <reference path="./java.sql.Blob.d.ts" />
/// <reference path="./java.sql.Clob.d.ts" />
/// <reference path="./java.sql.Connection.d.ts" />
/// <reference path="./java.sql.Date.d.ts" />
/// <reference path="./java.sql.NClob.d.ts" />
/// <reference path="./java.sql.ParameterMetaData.d.ts" />
/// <reference path="./java.sql.Ref.d.ts" />
/// <reference path="./java.sql.ResultSet.d.ts" />
/// <reference path="./java.sql.ResultSetMetaData.d.ts" />
/// <reference path="./java.sql.RowId.d.ts" />
/// <reference path="./java.sql.SQLWarning.d.ts" />
/// <reference path="./java.sql.SQLXML.d.ts" />
/// <reference path="./java.sql.Time.d.ts" />
/// <reference path="./java.sql.Timestamp.d.ts" />
/// <reference path="./java.util.Calendar.d.ts" />
declare module java {
    export module sql {
        export class PreparedStatement extends java.lang.Object implements java.sql.Statement {
            /**
             * Constructs a new instance of the java.sql.PreparedStatement interface with the provided implementation.
             */
            public constructor(implementation: {
                addBatch(): void;
                clearParameters(): void;
                execute(): boolean;
                executeQuery(): java.sql.ResultSet;
                executeUpdate(): number;
                getMetaData(): java.sql.ResultSetMetaData;
                getParameterMetaData(): java.sql.ParameterMetaData;
                setArray(param0: number, param1: java.sql.Array): void;
                setAsciiStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setBigDecimal(param0: number, param1: java.math.BigDecimal): void;
                setBinaryStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setBlob(param0: number, param1: java.sql.Blob): void;
                setBoolean(param0: number, param1: boolean): void;
                setByte(param0: number, param1: number): void;
                setBytes(param0: number, param1: native.Array<number>): void;
                setCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;
                setClob(param0: number, param1: java.sql.Clob): void;
                setDate(param0: number, param1: java.sql.Date): void;
                setDate(param0: number, param1: java.sql.Date, param2: java.util.Calendar): void;
                setDouble(param0: number, param1: number): void;
                setFloat(param0: number, param1: number): void;
                setInt(param0: number, param1: number): void;
                setLong(param0: number, param1: number): void;
                setNull(param0: number, param1: number): void;
                setNull(param0: number, param1: number, param2: string): void;
                setObject(param0: number, param1: java.lang.Object): void;
                setObject(param0: number, param1: java.lang.Object, param2: number): void;
                setObject(param0: number, param1: java.lang.Object, param2: number, param3: number): void;
                setRef(param0: number, param1: java.sql.Ref): void;
                setShort(param0: number, param1: number): void;
                setString(param0: number, param1: string): void;
                setTime(param0: number, param1: java.sql.Time): void;
                setTime(param0: number, param1: java.sql.Time, param2: java.util.Calendar): void;
                setTimestamp(param0: number, param1: java.sql.Timestamp): void;
                setTimestamp(param0: number, param1: java.sql.Timestamp, param2: java.util.Calendar): void;
                setUnicodeStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setURL(param0: number, param1: java.net.URL): void;
                setRowId(param0: number, param1: java.sql.RowId): void;
                setNString(param0: number, param1: string): void;
                setNCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;
                setNClob(param0: number, param1: java.sql.NClob): void;
                setClob(param0: number, param1: java.io.Reader, param2: number): void;
                setBlob(param0: number, param1: java.io.InputStream, param2: number): void;
                setNClob(param0: number, param1: java.io.Reader, param2: number): void;
                setSQLXML(param0: number, param1: java.sql.SQLXML): void;
                setAsciiStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setBinaryStream(param0: number, param1: java.io.InputStream, param2: number): void;
                setCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;
                setAsciiStream(param0: number, param1: java.io.InputStream): void;
                setBinaryStream(param0: number, param1: java.io.InputStream): void;
                setCharacterStream(param0: number, param1: java.io.Reader): void;
                setNCharacterStream(param0: number, param1: java.io.Reader): void;
                setClob(param0: number, param1: java.io.Reader): void;
                setBlob(param0: number, param1: java.io.InputStream): void;
                setNClob(param0: number, param1: java.io.Reader): void;
                addBatch(param0: string): void;
                cancel(): void;
                clearBatch(): void;
                clearWarnings(): void;
                close(): void;
                execute(param0: string): boolean;
                execute(param0: string, param1: number): boolean;
                execute(param0: string, param1: native.Array<number>): boolean;
                execute(param0: string, param1: native.Array<string>): boolean;
                executeBatch(): native.Array<number>;
                executeQuery(param0: string): java.sql.ResultSet;
                executeUpdate(param0: string): number;
                executeUpdate(param0: string, param1: number): number;
                executeUpdate(param0: string, param1: native.Array<number>): number;
                executeUpdate(param0: string, param1: native.Array<string>): number;
                getConnection(): java.sql.Connection;
                getFetchDirection(): number;
                getFetchSize(): number;
                getGeneratedKeys(): java.sql.ResultSet;
                getMaxFieldSize(): number;
                getMaxRows(): number;
                getMoreResults(): boolean;
                getMoreResults(param0: number): boolean;
                getQueryTimeout(): number;
                getResultSet(): java.sql.ResultSet;
                getResultSetConcurrency(): number;
                getResultSetHoldability(): number;
                getResultSetType(): number;
                getUpdateCount(): number;
                getWarnings(): java.sql.SQLWarning;
                setCursorName(param0: string): void;
                setEscapeProcessing(param0: boolean): void;
                setFetchDirection(param0: number): void;
                setFetchSize(param0: number): void;
                setMaxFieldSize(param0: number): void;
                setMaxRows(param0: number): void;
                setQueryTimeout(param0: number): void;
                isClosed(): boolean;
                setPoolable(param0: boolean): void;
                isPoolable(): boolean;
                unwrap(param0: java.lang.Class): java.lang.Object;
                isWrapperFor(param0: java.lang.Class): boolean;
                close(): void;
            });

            public static CLOSE_CURRENT_RESULT: number;
            public static EXECUTE_FAILED: number;
            public static KEEP_CURRENT_RESULT: number;
            public static NO_GENERATED_KEYS: number;
            public static RETURN_GENERATED_KEYS: number;
            public static CLOSE_ALL_RESULTS: number;
            public static SUCCESS_NO_INFO: number;

            public setAsciiStream(param0: number, param1: java.io.InputStream): void;

            public cancel(): void;

            public setFloat(param0: number, param1: number): void;

            public setLong(param0: number, param1: number): void;

            public setNull(param0: number, param1: number, param2: string): void;

            public setMaxRows(param0: number): void;

            public unwrap(param0: java.lang.Class): java.lang.Object;

            public setBlob(param0: number, param1: java.io.InputStream): void;

            public setPoolable(param0: boolean): void;

            public setByte(param0: number, param1: number): void;

            public executeUpdate(param0: string, param1: native.Array<string>): number;

            public getWarnings(): java.sql.SQLWarning;

            public setSQLXML(param0: number, param1: java.sql.SQLXML): void;

            public addBatch(param0: string): void;

            public getMaxFieldSize(): number;

            public clearWarnings(): void;

            public setBoolean(param0: number, param1: boolean): void;

            public setObject(param0: number, param1: java.lang.Object, param2: number): void;

            public getFetchSize(): number;

            public getResultSetHoldability(): number;

            public setCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;

            public setCursorName(param0: string): void;

            public getMoreResults(): boolean;

            public setClob(param0: number, param1: java.sql.Clob): void;

            public setNull(param0: number, param1: number): void;

            public setBinaryStream(param0: number, param1: java.io.InputStream): void;

            public setQueryTimeout(param0: number): void;

            public setNClob(param0: number, param1: java.sql.NClob): void;
            public setNClob(param0: number, param1: java.io.Reader): void;

            public getFetchDirection(): number;

            public setMaxFieldSize(param0: number): void;

            public getParameterMetaData(): java.sql.ParameterMetaData;

            public executeUpdate(): number;

            public setTimestamp(param0: number, param1: java.sql.Timestamp, param2: java.util.Calendar): void;

            public setInt(param0: number, param1: number): void;

            public setRef(param0: number, param1: java.sql.Ref): void;

            public setFetchSize(param0: number): void;

            public executeQuery(): java.sql.ResultSet;

            public setNString(param0: number, param1: string): void;

            public setEscapeProcessing(param0: boolean): void;

            public executeUpdate(param0: string, param1: number): number;

            public getResultSet(): java.sql.ResultSet;

            public getMoreResults(param0: number): boolean;

            public addBatch(): void;

            public setString(param0: number, param1: string): void;

            public setNCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;

            public setRowId(param0: number, param1: java.sql.RowId): void;

            public setDate(param0: number, param1: java.sql.Date): void;

            public isClosed(): boolean;

            public getMaxRows(): number;

            public clearParameters(): void;

            public setShort(param0: number, param1: number): void;

            public setObject(param0: number, param1: java.lang.Object): void;

            public executeUpdate(param0: string, param1: native.Array<number>): number;

            public getMetaData(): java.sql.ResultSetMetaData;

            public setBinaryStream(param0: number, param1: java.io.InputStream, param2: number): void;

            public setTime(param0: number, param1: java.sql.Time, param2: java.util.Calendar): void;

            public getUpdateCount(): number;

            public executeBatch(): native.Array<number>;

            public isPoolable(): boolean;

            public execute(param0: string, param1: number): boolean;

            public getConnection(): java.sql.Connection;

            public setNClob(param0: number, param1: java.io.Reader, param2: number): void;

            public close(): void;

            public execute(param0: string): boolean;

            public setURL(param0: number, param1: java.net.URL): void;

            public getResultSetType(): number;

            public setDate(param0: number, param1: java.sql.Date, param2: java.util.Calendar): void;

            public executeUpdate(param0: string): number;

            public setClob(param0: number, param1: java.io.Reader, param2: number): void;

            public getGeneratedKeys(): java.sql.ResultSet;

            public isWrapperFor(param0: java.lang.Class): boolean;

            public setBigDecimal(param0: number, param1: java.math.BigDecimal): void;

            public setUnicodeStream(param0: number, param1: java.io.InputStream, param2: number): void;

            public setBytes(param0: number, param1: native.Array<number>): void;

            public getResultSetConcurrency(): number;

            public setCharacterStream(param0: number, param1: java.io.Reader): void;

            public setTime(param0: number, param1: java.sql.Time): void;

            public setTimestamp(param0: number, param1: java.sql.Timestamp): void;

            public setArray(param0: number, param1: java.sql.Array): void;

            public clearBatch(): void;

            public setObject(param0: number, param1: java.lang.Object, param2: number, param3: number): void;

            public setClob(param0: number, param1: java.io.Reader): void;

            public execute(): boolean;

            public setNCharacterStream(param0: number, param1: java.io.Reader): void;

            public executeQuery(param0: string): java.sql.ResultSet;

            public setFetchDirection(param0: number): void;

            public setBlob(param0: number, param1: java.io.InputStream, param2: number): void;

            public setDouble(param0: number, param1: number): void;

            public setBlob(param0: number, param1: java.sql.Blob): void;

            public execute(param0: string, param1: native.Array<number>): boolean;

            public getQueryTimeout(): number;

            public setAsciiStream(param0: number, param1: java.io.InputStream, param2: number): void;

            public execute(param0: string, param1: native.Array<string>): boolean;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module sql {
        export class Ref extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.Ref interface with the provided implementation.
             */
            public constructor(implementation: {
                getBaseTypeName(): string;
                getObject(): java.lang.Object;
                getObject(param0: java.util.Map): java.lang.Object;
                setObject(param0: java.lang.Object): void;
            });

            public getObject(): java.lang.Object;

            public setObject(param0: java.lang.Object): void;

            public getBaseTypeName(): string;

            public getObject(param0: java.util.Map): java.lang.Object;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigDecimal.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.sql.Array.d.ts" />
/// <reference path="./java.sql.Blob.d.ts" />
/// <reference path="./java.sql.Clob.d.ts" />
/// <reference path="./java.sql.Date.d.ts" />
/// <reference path="./java.sql.NClob.d.ts" />
/// <reference path="./java.sql.Ref.d.ts" />
/// <reference path="./java.sql.ResultSetMetaData.d.ts" />
/// <reference path="./java.sql.RowId.d.ts" />
/// <reference path="./java.sql.SQLWarning.d.ts" />
/// <reference path="./java.sql.SQLXML.d.ts" />
/// <reference path="./java.sql.Statement.d.ts" />
/// <reference path="./java.sql.Time.d.ts" />
/// <reference path="./java.sql.Timestamp.d.ts" />
/// <reference path="./java.util.Calendar.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module sql {
        export class ResultSet extends java.lang.Object implements java.sql.Wrapper, java.lang.AutoCloseable {
            /**
             * Constructs a new instance of the java.sql.ResultSet interface with the provided implementation.
             */
            public constructor(implementation: {
                absolute(param0: number): boolean;
                afterLast(): void;
                beforeFirst(): void;
                cancelRowUpdates(): void;
                clearWarnings(): void;
                close(): void;
                deleteRow(): void;
                findColumn(param0: string): number;
                first(): boolean;
                getArray(param0: number): java.sql.Array;
                getArray(param0: string): java.sql.Array;
                getAsciiStream(param0: number): java.io.InputStream;
                getAsciiStream(param0: string): java.io.InputStream;
                getBigDecimal(param0: number): java.math.BigDecimal;
                getBigDecimal(param0: number, param1: number): java.math.BigDecimal;
                getBigDecimal(param0: string): java.math.BigDecimal;
                getBigDecimal(param0: string, param1: number): java.math.BigDecimal;
                getBinaryStream(param0: number): java.io.InputStream;
                getBinaryStream(param0: string): java.io.InputStream;
                getBlob(param0: number): java.sql.Blob;
                getBlob(param0: string): java.sql.Blob;
                getBoolean(param0: number): boolean;
                getBoolean(param0: string): boolean;
                getByte(param0: number): number;
                getByte(param0: string): number;
                getBytes(param0: number): native.Array<number>;
                getBytes(param0: string): native.Array<number>;
                getCharacterStream(param0: number): java.io.Reader;
                getCharacterStream(param0: string): java.io.Reader;
                getClob(param0: number): java.sql.Clob;
                getClob(param0: string): java.sql.Clob;
                getConcurrency(): number;
                getCursorName(): string;
                getDate(param0: number): java.sql.Date;
                getDate(param0: number, param1: java.util.Calendar): java.sql.Date;
                getDate(param0: string): java.sql.Date;
                getDate(param0: string, param1: java.util.Calendar): java.sql.Date;
                getDouble(param0: number): number;
                getDouble(param0: string): number;
                getFetchDirection(): number;
                getFetchSize(): number;
                getFloat(param0: number): number;
                getFloat(param0: string): number;
                getInt(param0: number): number;
                getInt(param0: string): number;
                getLong(param0: number): number;
                getLong(param0: string): number;
                getMetaData(): java.sql.ResultSetMetaData;
                getObject(param0: number): java.lang.Object;
                getObject(param0: number, param1: java.util.Map): java.lang.Object;
                getObject(param0: string): java.lang.Object;
                getObject(param0: string, param1: java.util.Map): java.lang.Object;
                getRef(param0: number): java.sql.Ref;
                getRef(param0: string): java.sql.Ref;
                getRow(): number;
                getShort(param0: number): number;
                getShort(param0: string): number;
                getStatement(): java.sql.Statement;
                getString(param0: number): string;
                getString(param0: string): string;
                getTime(param0: number): java.sql.Time;
                getTime(param0: number, param1: java.util.Calendar): java.sql.Time;
                getTime(param0: string): java.sql.Time;
                getTime(param0: string, param1: java.util.Calendar): java.sql.Time;
                getTimestamp(param0: number): java.sql.Timestamp;
                getTimestamp(param0: number, param1: java.util.Calendar): java.sql.Timestamp;
                getTimestamp(param0: string): java.sql.Timestamp;
                getTimestamp(param0: string, param1: java.util.Calendar): java.sql.Timestamp;
                getType(): number;
                getUnicodeStream(param0: number): java.io.InputStream;
                getUnicodeStream(param0: string): java.io.InputStream;
                getURL(param0: number): java.net.URL;
                getURL(param0: string): java.net.URL;
                getWarnings(): java.sql.SQLWarning;
                insertRow(): void;
                isAfterLast(): boolean;
                isBeforeFirst(): boolean;
                isFirst(): boolean;
                isLast(): boolean;
                last(): boolean;
                moveToCurrentRow(): void;
                moveToInsertRow(): void;
                next(): boolean;
                previous(): boolean;
                refreshRow(): void;
                relative(param0: number): boolean;
                rowDeleted(): boolean;
                rowInserted(): boolean;
                rowUpdated(): boolean;
                setFetchDirection(param0: number): void;
                setFetchSize(param0: number): void;
                updateArray(param0: number, param1: java.sql.Array): void;
                updateArray(param0: string, param1: java.sql.Array): void;
                updateAsciiStream(param0: number, param1: java.io.InputStream, param2: number): void;
                updateAsciiStream(param0: string, param1: java.io.InputStream, param2: number): void;
                updateBigDecimal(param0: number, param1: java.math.BigDecimal): void;
                updateBigDecimal(param0: string, param1: java.math.BigDecimal): void;
                updateBinaryStream(param0: number, param1: java.io.InputStream, param2: number): void;
                updateBinaryStream(param0: string, param1: java.io.InputStream, param2: number): void;
                updateBlob(param0: number, param1: java.sql.Blob): void;
                updateBlob(param0: string, param1: java.sql.Blob): void;
                updateBoolean(param0: number, param1: boolean): void;
                updateBoolean(param0: string, param1: boolean): void;
                updateByte(param0: number, param1: number): void;
                updateByte(param0: string, param1: number): void;
                updateBytes(param0: number, param1: native.Array<number>): void;
                updateBytes(param0: string, param1: native.Array<number>): void;
                updateCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;
                updateCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;
                updateClob(param0: number, param1: java.sql.Clob): void;
                updateClob(param0: string, param1: java.sql.Clob): void;
                updateDate(param0: number, param1: java.sql.Date): void;
                updateDate(param0: string, param1: java.sql.Date): void;
                updateDouble(param0: number, param1: number): void;
                updateDouble(param0: string, param1: number): void;
                updateFloat(param0: number, param1: number): void;
                updateFloat(param0: string, param1: number): void;
                updateInt(param0: number, param1: number): void;
                updateInt(param0: string, param1: number): void;
                updateLong(param0: number, param1: number): void;
                updateLong(param0: string, param1: number): void;
                updateNull(param0: number): void;
                updateNull(param0: string): void;
                updateObject(param0: number, param1: java.lang.Object): void;
                updateObject(param0: number, param1: java.lang.Object, param2: number): void;
                updateObject(param0: string, param1: java.lang.Object): void;
                updateObject(param0: string, param1: java.lang.Object, param2: number): void;
                updateRef(param0: number, param1: java.sql.Ref): void;
                updateRef(param0: string, param1: java.sql.Ref): void;
                updateRow(): void;
                updateShort(param0: number, param1: number): void;
                updateShort(param0: string, param1: number): void;
                updateString(param0: number, param1: string): void;
                updateString(param0: string, param1: string): void;
                updateTime(param0: number, param1: java.sql.Time): void;
                updateTime(param0: string, param1: java.sql.Time): void;
                updateTimestamp(param0: number, param1: java.sql.Timestamp): void;
                updateTimestamp(param0: string, param1: java.sql.Timestamp): void;
                wasNull(): boolean;
                getRowId(param0: number): java.sql.RowId;
                getRowId(param0: string): java.sql.RowId;
                updateRowId(param0: number, param1: java.sql.RowId): void;
                updateRowId(param0: string, param1: java.sql.RowId): void;
                getHoldability(): number;
                isClosed(): boolean;
                updateNString(param0: number, param1: string): void;
                updateNString(param0: string, param1: string): void;
                updateNClob(param0: number, param1: java.sql.NClob): void;
                updateNClob(param0: string, param1: java.sql.NClob): void;
                getNClob(param0: number): java.sql.NClob;
                getNClob(param0: string): java.sql.NClob;
                getSQLXML(param0: number): java.sql.SQLXML;
                getSQLXML(param0: string): java.sql.SQLXML;
                updateSQLXML(param0: number, param1: java.sql.SQLXML): void;
                updateSQLXML(param0: string, param1: java.sql.SQLXML): void;
                getNString(param0: number): string;
                getNString(param0: string): string;
                getNCharacterStream(param0: number): java.io.Reader;
                getNCharacterStream(param0: string): java.io.Reader;
                updateNCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;
                updateNCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;
                updateAsciiStream(param0: number, param1: java.io.InputStream, param2: number): void;
                updateBinaryStream(param0: number, param1: java.io.InputStream, param2: number): void;
                updateCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;
                updateAsciiStream(param0: string, param1: java.io.InputStream, param2: number): void;
                updateBinaryStream(param0: string, param1: java.io.InputStream, param2: number): void;
                updateCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;
                updateBlob(param0: number, param1: java.io.InputStream, param2: number): void;
                updateBlob(param0: string, param1: java.io.InputStream, param2: number): void;
                updateClob(param0: number, param1: java.io.Reader, param2: number): void;
                updateClob(param0: string, param1: java.io.Reader, param2: number): void;
                updateNClob(param0: number, param1: java.io.Reader, param2: number): void;
                updateNClob(param0: string, param1: java.io.Reader, param2: number): void;
                updateNCharacterStream(param0: number, param1: java.io.Reader): void;
                updateNCharacterStream(param0: string, param1: java.io.Reader): void;
                updateAsciiStream(param0: number, param1: java.io.InputStream): void;
                updateBinaryStream(param0: number, param1: java.io.InputStream): void;
                updateCharacterStream(param0: number, param1: java.io.Reader): void;
                updateAsciiStream(param0: string, param1: java.io.InputStream): void;
                updateBinaryStream(param0: string, param1: java.io.InputStream): void;
                updateCharacterStream(param0: string, param1: java.io.Reader): void;
                updateBlob(param0: number, param1: java.io.InputStream): void;
                updateBlob(param0: string, param1: java.io.InputStream): void;
                updateClob(param0: number, param1: java.io.Reader): void;
                updateClob(param0: string, param1: java.io.Reader): void;
                updateNClob(param0: number, param1: java.io.Reader): void;
                updateNClob(param0: string, param1: java.io.Reader): void;
                unwrap(param0: java.lang.Class): java.lang.Object;
                isWrapperFor(param0: java.lang.Class): boolean;
                close(): void;
            });

            public static HOLD_CURSORS_OVER_COMMIT: number;
            public static CLOSE_CURSORS_AT_COMMIT: number;
            public static FETCH_UNKNOWN: number;
            public static FETCH_REVERSE: number;
            public static CONCUR_READ_ONLY: number;
            public static TYPE_SCROLL_SENSITIVE: number;
            public static CONCUR_UPDATABLE: number;
            public static TYPE_FORWARD_ONLY: number;
            public static TYPE_SCROLL_INSENSITIVE: number;
            public static FETCH_FORWARD: number;

            public getAsciiStream(param0: number): java.io.InputStream;

            public updateBinaryStream(param0: string, param1: java.io.InputStream): void;

            public getObject(param0: number, param1: java.util.Map): java.lang.Object;

            public getClob(param0: string): java.sql.Clob;

            public updateDouble(param0: number, param1: number): void;

            public previous(): boolean;

            public unwrap(param0: java.lang.Class): java.lang.Object;

            public updateBinaryStream(param0: string, param1: java.io.InputStream, param2: number): void;

            public getUnicodeStream(param0: number): java.io.InputStream;

            public cancelRowUpdates(): void;

            public getConcurrency(): number;

            public afterLast(): void;

            public wasNull(): boolean;

            public updateSQLXML(param0: string, param1: java.sql.SQLXML): void;

            public updateRef(param0: string, param1: java.sql.Ref): void;

            public clearWarnings(): void;

            public updateNClob(param0: number, param1: java.io.Reader, param2: number): void;

            public updateArray(param0: number, param1: java.sql.Array): void;

            public updateCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;

            public getNClob(param0: string): java.sql.NClob;

            public updateArray(param0: string, param1: java.sql.Array): void;

            public getByte(param0: number): number;

            public getObject(param0: number): java.lang.Object;

            public getNString(param0: string): string;

            public refreshRow(): void;

            public updateBinaryStream(param0: number, param1: java.io.InputStream): void;

            public updateTime(param0: number, param1: java.sql.Time): void;

            public updateCharacterStream(param0: string, param1: java.io.Reader): void;

            public getFloat(param0: string): number;

            public setFetchSize(param0: number): void;

            public getCursorName(): string;

            public absolute(param0: number): boolean;

            public getDouble(param0: string): number;

            public last(): boolean;

            public relative(param0: number): boolean;

            public updateNString(param0: string, param1: string): void;

            public getInt(param0: number): number;

            public getRef(param0: number): java.sql.Ref;

            public getType(): number;

            public isClosed(): boolean;

            public updateBlob(param0: number, param1: java.sql.Blob): void;

            public updateAsciiStream(param0: number, param1: java.io.InputStream, param2: number): void;

            public updateBytes(param0: string, param1: native.Array<number>): void;

            public updateNClob(param0: string, param1: java.io.Reader, param2: number): void;

            public getMetaData(): java.sql.ResultSetMetaData;

            public updateNull(param0: number): void;

            public updateCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;
            public updateCharacterStream(param0: number, param1: java.io.Reader): void;

            public updateBlob(param0: string, param1: java.sql.Blob): void;

            public getObject(param0: string): java.lang.Object;

            public updateAsciiStream(param0: number, param1: java.io.InputStream): void;
            public updateAsciiStream(param0: string, param1: java.io.InputStream, param2: number): void;

            public updateString(param0: number, param1: string): void;

            public getTimestamp(param0: number, param1: java.util.Calendar): java.sql.Timestamp;

            public isLast(): boolean;

            public updateObject(param0: string, param1: java.lang.Object, param2: number): void;

            public updateString(param0: string, param1: string): void;

            public getSQLXML(param0: number): java.sql.SQLXML;

            public updateNull(param0: string): void;

            public close(): void;

            public getCharacterStream(param0: number): java.io.Reader;

            public updateBigDecimal(param0: string, param1: java.math.BigDecimal): void;

            public updateClob(param0: number, param1: java.sql.Clob): void;

            public getUnicodeStream(param0: string): java.io.InputStream;

            public getDate(param0: string): java.sql.Date;

            public isFirst(): boolean;

            public updateNClob(param0: number, param1: java.sql.NClob): void;

            public findColumn(param0: string): number;

            public getBigDecimal(param0: number, param1: number): java.math.BigDecimal;

            public isWrapperFor(param0: java.lang.Class): boolean;

            public getString(param0: string): string;

            public updateDate(param0: string, param1: java.sql.Date): void;

            public updateNString(param0: number, param1: string): void;

            public getAsciiStream(param0: string): java.io.InputStream;

            public rowUpdated(): boolean;

            public getURL(param0: number): java.net.URL;

            public getObject(param0: string, param1: java.util.Map): java.lang.Object;

            public getRow(): number;

            public updateSQLXML(param0: number, param1: java.sql.SQLXML): void;

            public rowInserted(): boolean;

            public next(): boolean;

            public getShort(param0: string): number;

            public getRowId(param0: string): java.sql.RowId;

            public getArray(param0: number): java.sql.Array;

            public updateInt(param0: string, param1: number): void;

            public getDate(param0: number, param1: java.util.Calendar): java.sql.Date;

            public updateObject(param0: string, param1: java.lang.Object): void;

            public getDate(param0: number): java.sql.Date;

            public rowDeleted(): boolean;

            public insertRow(): void;

            public updateBlob(param0: string, param1: java.io.InputStream, param2: number): void;

            public getTimestamp(param0: string, param1: java.util.Calendar): java.sql.Timestamp;

            public updateInt(param0: number, param1: number): void;

            public updateLong(param0: number, param1: number): void;

            public getBoolean(param0: string): boolean;

            public getFloat(param0: number): number;

            public updateDate(param0: number, param1: java.sql.Date): void;

            public updateClob(param0: string, param1: java.sql.Clob): void;

            public updateTime(param0: string, param1: java.sql.Time): void;

            public getBigDecimal(param0: number): java.math.BigDecimal;

            public isAfterLast(): boolean;

            public updateBinaryStream(param0: number, param1: java.io.InputStream, param2: number): void;

            public getWarnings(): java.sql.SQLWarning;

            public beforeFirst(): void;

            public getStatement(): java.sql.Statement;

            public updateObject(param0: number, param1: java.lang.Object, param2: number): void;

            public getBlob(param0: string): java.sql.Blob;

            public updateShort(param0: string, param1: number): void;

            public updateByte(param0: number, param1: number): void;

            public updateNClob(param0: string, param1: java.sql.NClob): void;

            public getCharacterStream(param0: string): java.io.Reader;

            public getSQLXML(param0: string): java.sql.SQLXML;

            public getTime(param0: number, param1: java.util.Calendar): java.sql.Time;

            public updateByte(param0: string, param1: number): void;

            public updateNCharacterStream(param0: number, param1: java.io.Reader, param2: number): void;

            public getShort(param0: number): number;

            public updateBlob(param0: number, param1: java.io.InputStream): void;

            public getFetchSize(): number;

            public getLong(param0: string): number;

            public getTime(param0: number): java.sql.Time;

            public getClob(param0: number): java.sql.Clob;

            public getInt(param0: string): number;

            public getArray(param0: string): java.sql.Array;

            public getDouble(param0: number): number;

            public getBytes(param0: string): native.Array<number>;

            public getString(param0: number): string;

            public getFetchDirection(): number;

            public getByte(param0: string): number;

            public updateAsciiStream(param0: string, param1: java.io.InputStream): void;

            public getBinaryStream(param0: number): java.io.InputStream;

            public getTime(param0: string, param1: java.util.Calendar): java.sql.Time;

            public getRowId(param0: number): java.sql.RowId;

            public updateClob(param0: string, param1: java.io.Reader, param2: number): void;

            public updateBoolean(param0: number, param1: boolean): void;

            public updateShort(param0: number, param1: number): void;

            public updateTimestamp(param0: number, param1: java.sql.Timestamp): void;
            public updateTimestamp(param0: string, param1: java.sql.Timestamp): void;

            public updateFloat(param0: number, param1: number): void;

            public getNCharacterStream(param0: string): java.io.Reader;

            public updateRef(param0: number, param1: java.sql.Ref): void;

            public getBoolean(param0: number): boolean;

            public updateNCharacterStream(param0: string, param1: java.io.Reader): void;

            public updateRowId(param0: string, param1: java.sql.RowId): void;

            public first(): boolean;

            public getBytes(param0: number): native.Array<number>;

            public getTimestamp(param0: string): java.sql.Timestamp;

            public getTime(param0: string): java.sql.Time;

            public updateBoolean(param0: string, param1: boolean): void;

            public updateBytes(param0: number, param1: native.Array<number>): void;

            public updateFloat(param0: string, param1: number): void;

            public updateNCharacterStream(param0: string, param1: java.io.Reader, param2: number): void;

            public getBlob(param0: number): java.sql.Blob;

            public isBeforeFirst(): boolean;

            public updateBigDecimal(param0: number, param1: java.math.BigDecimal): void;

            public updateNClob(param0: string, param1: java.io.Reader): void;

            public updateRow(): void;

            public getDate(param0: string, param1: java.util.Calendar): java.sql.Date;

            public updateBlob(param0: string, param1: java.io.InputStream): void;

            public getNClob(param0: number): java.sql.NClob;

            public updateClob(param0: string, param1: java.io.Reader): void;

            public getURL(param0: string): java.net.URL;

            public getHoldability(): number;

            public updateClob(param0: number, param1: java.io.Reader): void;

            public moveToInsertRow(): void;

            public updateClob(param0: number, param1: java.io.Reader, param2: number): void;

            public getTimestamp(param0: number): java.sql.Timestamp;

            public updateDouble(param0: string, param1: number): void;

            public getBinaryStream(param0: string): java.io.InputStream;

            public updateNClob(param0: number, param1: java.io.Reader): void;

            public getRef(param0: string): java.sql.Ref;

            public moveToCurrentRow(): void;

            public getBigDecimal(param0: string, param1: number): java.math.BigDecimal;

            public getNString(param0: number): string;

            public deleteRow(): void;

            public getNCharacterStream(param0: number): java.io.Reader;

            public setFetchDirection(param0: number): void;

            public updateBlob(param0: number, param1: java.io.InputStream, param2: number): void;

            public getBigDecimal(param0: string): java.math.BigDecimal;

            public getLong(param0: number): number;

            public updateObject(param0: number, param1: java.lang.Object): void;

            public updateRowId(param0: number, param1: java.sql.RowId): void;

            public updateNCharacterStream(param0: number, param1: java.io.Reader): void;

            public updateLong(param0: string, param1: number): void;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module sql {
        export class ResultSetMetaData extends java.lang.Object implements java.sql.Wrapper {
            /**
             * Constructs a new instance of the java.sql.ResultSetMetaData interface with the provided implementation.
             */
            public constructor(implementation: {
                getCatalogName(param0: number): string;
                getColumnClassName(param0: number): string;
                getColumnCount(): number;
                getColumnDisplaySize(param0: number): number;
                getColumnLabel(param0: number): string;
                getColumnName(param0: number): string;
                getColumnType(param0: number): number;
                getColumnTypeName(param0: number): string;
                getPrecision(param0: number): number;
                getScale(param0: number): number;
                getSchemaName(param0: number): string;
                getTableName(param0: number): string;
                isAutoIncrement(param0: number): boolean;
                isCaseSensitive(param0: number): boolean;
                isCurrency(param0: number): boolean;
                isDefinitelyWritable(param0: number): boolean;
                isNullable(param0: number): number;
                isReadOnly(param0: number): boolean;
                isSearchable(param0: number): boolean;
                isSigned(param0: number): boolean;
                isWritable(param0: number): boolean;
                unwrap(param0: java.lang.Class): java.lang.Object;
                isWrapperFor(param0: java.lang.Class): boolean;
            });

            public static columnNullableUnknown: number;
            public static columnNullable: number;
            public static columnNoNulls: number;

            public getColumnCount(): number;

            public getColumnName(param0: number): string;

            public getColumnType(param0: number): number;

            public isCurrency(param0: number): boolean;

            public getTableName(param0: number): string;

            public isReadOnly(param0: number): boolean;

            public isWrapperFor(param0: java.lang.Class): boolean;

            public getColumnDisplaySize(param0: number): number;

            public getColumnTypeName(param0: number): string;

            public getPrecision(param0: number): number;

            public unwrap(param0: java.lang.Class): java.lang.Object;

            public isSigned(param0: number): boolean;

            public getColumnLabel(param0: number): string;

            public getScale(param0: number): number;

            public isAutoIncrement(param0: number): boolean;

            public isDefinitelyWritable(param0: number): boolean;

            public isCaseSensitive(param0: number): boolean;

            public getSchemaName(param0: number): string;

            public getCatalogName(param0: number): string;

            public isSearchable(param0: number): boolean;

            public isWritable(param0: number): boolean;

            public getColumnClassName(param0: number): string;

            public isNullable(param0: number): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module sql {
        export class RowId extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.RowId interface with the provided implementation.
             */
            public constructor(implementation: {
                equals(param0: java.lang.Object): boolean;
                getBytes(): native.Array<number>;
                toString(): string;
                hashCode(): number;
            });

            public toString(): string;

            public getBytes(): native.Array<number>;

            public equals(param0: java.lang.Object): boolean;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module sql {
        export class RowIdLifetime extends java.lang.Enum {
            public static ROWID_UNSUPPORTED: java.sql.RowIdLifetime;
            public static ROWID_VALID_FOREVER: java.sql.RowIdLifetime;
            public static ROWID_VALID_OTHER: java.sql.RowIdLifetime;
            public static ROWID_VALID_SESSION: java.sql.RowIdLifetime;
            public static ROWID_VALID_TRANSACTION: java.sql.RowIdLifetime;

            public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            public static valueOf(param0: string): java.sql.RowIdLifetime;

            public static values(): native.Array<java.sql.RowIdLifetime>;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module sql {
        export class SQLClientInfoException extends java.sql.SQLException {
            public constructor(param0: java.util.Map);
            public constructor(param0: java.util.Map, param1: java.lang.Throwable);
            public constructor(param0: string, param1: string, param2: java.util.Map);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.util.Map);
            public constructor(param0: string, param1: string, param2: java.util.Map, param3: java.lang.Throwable);
            public constructor(param0: string, param1: string, param2: number, param3: java.util.Map, param4: java.lang.Throwable);
            public constructor();

            public getFailedProperties(): java.util.Map;

            public constructor(param0: string, param1: string, param2: number, param3: java.util.Map);
            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor(param0: string, param1: java.util.Map, param2: java.lang.Throwable);
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.sql.SQLInput.d.ts" />
/// <reference path="./java.sql.SQLOutput.d.ts" />
declare module java {
    export module sql {
        export class SQLData extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.SQLData interface with the provided implementation.
             */
            public constructor(implementation: {
                getSQLTypeName(): string;
                readSQL(param0: java.sql.SQLInput, param1: string): void;
                writeSQL(param0: java.sql.SQLOutput): void;
            });

            public getSQLTypeName(): string;

            public writeSQL(param0: java.sql.SQLOutput): void;

            public readSQL(param0: java.sql.SQLInput, param1: string): void;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLDataException extends java.sql.SQLNonTransientException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLException extends java.lang.Exception implements java.io.Serializable, java.lang.Iterable {
            public getErrorCode(): number;

            public getNextException(): java.sql.SQLException;

            public setNextException(param0: java.sql.SQLException): void;

            public constructor(param0: java.lang.Throwable);
            public constructor();
            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public getSQLState(): string;

            public iterator(): java.util.Iterator;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLFeatureNotSupportedException extends java.sql.SQLNonTransientException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.math.BigDecimal.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.sql.Array.d.ts" />
/// <reference path="./java.sql.Blob.d.ts" />
/// <reference path="./java.sql.Clob.d.ts" />
/// <reference path="./java.sql.Date.d.ts" />
/// <reference path="./java.sql.NClob.d.ts" />
/// <reference path="./java.sql.Ref.d.ts" />
/// <reference path="./java.sql.RowId.d.ts" />
/// <reference path="./java.sql.SQLXML.d.ts" />
/// <reference path="./java.sql.Time.d.ts" />
/// <reference path="./java.sql.Timestamp.d.ts" />
declare module java {
    export module sql {
        export class SQLInput extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.SQLInput interface with the provided implementation.
             */
            public constructor(implementation: {
                readString(): string;
                readBoolean(): boolean;
                readByte(): number;
                readShort(): number;
                readInt(): number;
                readLong(): number;
                readFloat(): number;
                readDouble(): number;
                readBigDecimal(): java.math.BigDecimal;
                readBytes(): native.Array<number>;
                readDate(): java.sql.Date;
                readTime(): java.sql.Time;
                readTimestamp(): java.sql.Timestamp;
                readCharacterStream(): java.io.Reader;
                readAsciiStream(): java.io.InputStream;
                readBinaryStream(): java.io.InputStream;
                readObject(): java.lang.Object;
                readRef(): java.sql.Ref;
                readBlob(): java.sql.Blob;
                readClob(): java.sql.Clob;
                readArray(): java.sql.Array;
                wasNull(): boolean;
                readURL(): java.net.URL;
                readNClob(): java.sql.NClob;
                readNString(): string;
                readSQLXML(): java.sql.SQLXML;
                readRowId(): java.sql.RowId;
            });

            public readSQLXML(): java.sql.SQLXML;

            public readBinaryStream(): java.io.InputStream;

            public readString(): string;

            public readByte(): number;

            public readShort(): number;

            public readRef(): java.sql.Ref;

            public readURL(): java.net.URL;

            public readDate(): java.sql.Date;

            public readNString(): string;

            public readRowId(): java.sql.RowId;

            public wasNull(): boolean;

            public readDouble(): number;

            public readBigDecimal(): java.math.BigDecimal;

            public readTime(): java.sql.Time;

            public readNClob(): java.sql.NClob;

            public readInt(): number;

            public readFloat(): number;

            public readCharacterStream(): java.io.Reader;

            public readBytes(): native.Array<number>;

            public readLong(): number;

            public readAsciiStream(): java.io.InputStream;

            public readBlob(): java.sql.Blob;

            public readBoolean(): boolean;

            public readObject(): java.lang.Object;

            public readTimestamp(): java.sql.Timestamp;

            public readClob(): java.sql.Clob;

            public readArray(): java.sql.Array;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLIntegrityConstraintViolationException extends java.sql.SQLNonTransientException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLInvalidAuthorizationSpecException extends java.sql.SQLNonTransientException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLNonTransientConnectionException extends java.sql.SQLNonTransientException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLNonTransientException extends java.sql.SQLException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigDecimal.d.ts" />
/// <reference path="./java.net.URL.d.ts" />
/// <reference path="./java.sql.Array.d.ts" />
/// <reference path="./java.sql.Blob.d.ts" />
/// <reference path="./java.sql.Clob.d.ts" />
/// <reference path="./java.sql.Date.d.ts" />
/// <reference path="./java.sql.NClob.d.ts" />
/// <reference path="./java.sql.Ref.d.ts" />
/// <reference path="./java.sql.RowId.d.ts" />
/// <reference path="./java.sql.SQLData.d.ts" />
/// <reference path="./java.sql.SQLXML.d.ts" />
/// <reference path="./java.sql.Struct.d.ts" />
/// <reference path="./java.sql.Time.d.ts" />
/// <reference path="./java.sql.Timestamp.d.ts" />
declare module java {
    export module sql {
        export class SQLOutput extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.SQLOutput interface with the provided implementation.
             */
            public constructor(implementation: {
                writeString(param0: string): void;
                writeBoolean(param0: boolean): void;
                writeByte(param0: number): void;
                writeShort(param0: number): void;
                writeInt(param0: number): void;
                writeLong(param0: number): void;
                writeFloat(param0: number): void;
                writeDouble(param0: number): void;
                writeBigDecimal(param0: java.math.BigDecimal): void;
                writeBytes(param0: native.Array<number>): void;
                writeDate(param0: java.sql.Date): void;
                writeTime(param0: java.sql.Time): void;
                writeTimestamp(param0: java.sql.Timestamp): void;
                writeCharacterStream(param0: java.io.Reader): void;
                writeAsciiStream(param0: java.io.InputStream): void;
                writeBinaryStream(param0: java.io.InputStream): void;
                writeObject(param0: java.sql.SQLData): void;
                writeRef(param0: java.sql.Ref): void;
                writeBlob(param0: java.sql.Blob): void;
                writeClob(param0: java.sql.Clob): void;
                writeStruct(param0: java.sql.Struct): void;
                writeArray(param0: java.sql.Array): void;
                writeURL(param0: java.net.URL): void;
                writeNString(param0: string): void;
                writeNClob(param0: java.sql.NClob): void;
                writeRowId(param0: java.sql.RowId): void;
                writeSQLXML(param0: java.sql.SQLXML): void;
            });

            public writeNString(param0: string): void;

            public writeTime(param0: java.sql.Time): void;

            public writeFloat(param0: number): void;

            public writeURL(param0: java.net.URL): void;

            public writeString(param0: string): void;

            public writeCharacterStream(param0: java.io.Reader): void;

            public writeDate(param0: java.sql.Date): void;

            public writeStruct(param0: java.sql.Struct): void;

            public writeRowId(param0: java.sql.RowId): void;

            public writeSQLXML(param0: java.sql.SQLXML): void;

            public writeInt(param0: number): void;

            public writeLong(param0: number): void;

            public writeBigDecimal(param0: java.math.BigDecimal): void;

            public writeObject(param0: java.sql.SQLData): void;

            public writeByte(param0: number): void;

            public writeDouble(param0: number): void;

            public writeBytes(param0: native.Array<number>): void;

            public writeTimestamp(param0: java.sql.Timestamp): void;

            public writeClob(param0: java.sql.Clob): void;

            public writeArray(param0: java.sql.Array): void;

            public writeBoolean(param0: boolean): void;

            public writeAsciiStream(param0: java.io.InputStream): void;

            public writeRef(param0: java.sql.Ref): void;

            public writeShort(param0: number): void;

            public writeBlob(param0: java.sql.Blob): void;

            public writeNClob(param0: java.sql.NClob): void;

            public writeBinaryStream(param0: java.io.InputStream): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module sql {
        export class SQLPermission extends java.security.BasicPermission implements java.security.Guard, java.io.Serializable {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLRecoverableException extends java.sql.SQLException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLSyntaxErrorException extends java.sql.SQLNonTransientException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLTimeoutException extends java.sql.SQLTransientException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLTransactionRollbackException extends java.sql.SQLTransientException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLTransientConnectionException extends java.sql.SQLTransientException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLTransientException extends java.sql.SQLException {
            public constructor(param0: string, param1: string);
            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module sql {
        export class SQLWarning extends java.sql.SQLException implements java.io.Serializable {
            public constructor(param0: string, param1: string);

            public setNextWarning(param0: java.sql.SQLWarning): void;

            public constructor(param0: string, param1: string, param2: number, param3: java.lang.Throwable);
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);

            public getNextWarning(): java.sql.SQLWarning;

            public constructor();
            public constructor(param0: string);
            public constructor(param0: string, param1: string, param2: number);

            public iterator(): java.util.Iterator;

            public constructor(param0: string, param1: string, param2: java.lang.Throwable);
        }
    }
}

import javaxxmltransformSource = javax.xml.transform.Source;
import javaxxmltransformResult = javax.xml.transform.Result;
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./javax.xml.transform.Result.d.ts" />
/// <reference path="./javax.xml.transform.Source.d.ts" />
declare module java {
    export module sql {
        export class SQLXML extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.SQLXML interface with the provided implementation.
             */
            public constructor(implementation: {
                free(): void;
                getBinaryStream(): java.io.InputStream;
                setBinaryStream(): java.io.OutputStream;
                getCharacterStream(): java.io.Reader;
                setCharacterStream(): java.io.Writer;
                getString(): string;
                setString(param0: string): void;
                getSource(param0: java.lang.Class): javaxxmltransformSource;
                setResult(param0: java.lang.Class): javaxxmltransformResult;
            });

            public getBinaryStream(): java.io.InputStream;

            public free(): void;

            public getSource(param0: java.lang.Class): javaxxmltransformSource;

            public getCharacterStream(): java.io.Reader;

            public setCharacterStream(): java.io.Writer;

            public getString(): string;

            public setBinaryStream(): java.io.OutputStream;

            public setString(param0: string): void;

            public setResult(param0: java.lang.Class): javaxxmltransformResult;
        }
    }
}

declare module java {
    export module sql {
        export class Savepoint extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.Savepoint interface with the provided implementation.
             */
            public constructor(implementation: {
                getSavepointId(): number;
                getSavepointName(): string;
            });

            public getSavepointId(): number;

            public getSavepointName(): string;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.sql.Connection.d.ts" />
/// <reference path="./java.sql.ResultSet.d.ts" />
/// <reference path="./java.sql.SQLWarning.d.ts" />
declare module java {
    export module sql {
        export class Statement extends java.lang.Object implements java.sql.Wrapper, java.lang.AutoCloseable {
            /**
             * Constructs a new instance of the java.sql.Statement interface with the provided implementation.
             */
            public constructor(implementation: {
                addBatch(param0: string): void;
                cancel(): void;
                clearBatch(): void;
                clearWarnings(): void;
                close(): void;
                execute(param0: string): boolean;
                execute(param0: string, param1: number): boolean;
                execute(param0: string, param1: native.Array<number>): boolean;
                execute(param0: string, param1: native.Array<string>): boolean;
                executeBatch(): native.Array<number>;
                executeQuery(param0: string): java.sql.ResultSet;
                executeUpdate(param0: string): number;
                executeUpdate(param0: string, param1: number): number;
                executeUpdate(param0: string, param1: native.Array<number>): number;
                executeUpdate(param0: string, param1: native.Array<string>): number;
                getConnection(): java.sql.Connection;
                getFetchDirection(): number;
                getFetchSize(): number;
                getGeneratedKeys(): java.sql.ResultSet;
                getMaxFieldSize(): number;
                getMaxRows(): number;
                getMoreResults(): boolean;
                getMoreResults(param0: number): boolean;
                getQueryTimeout(): number;
                getResultSet(): java.sql.ResultSet;
                getResultSetConcurrency(): number;
                getResultSetHoldability(): number;
                getResultSetType(): number;
                getUpdateCount(): number;
                getWarnings(): java.sql.SQLWarning;
                setCursorName(param0: string): void;
                setEscapeProcessing(param0: boolean): void;
                setFetchDirection(param0: number): void;
                setFetchSize(param0: number): void;
                setMaxFieldSize(param0: number): void;
                setMaxRows(param0: number): void;
                setQueryTimeout(param0: number): void;
                isClosed(): boolean;
                setPoolable(param0: boolean): void;
                isPoolable(): boolean;
                unwrap(param0: java.lang.Class): java.lang.Object;
                isWrapperFor(param0: java.lang.Class): boolean;
                close(): void;
            });

            public static CLOSE_CURRENT_RESULT: number;
            public static EXECUTE_FAILED: number;
            public static KEEP_CURRENT_RESULT: number;
            public static NO_GENERATED_KEYS: number;
            public static RETURN_GENERATED_KEYS: number;
            public static CLOSE_ALL_RESULTS: number;
            public static SUCCESS_NO_INFO: number;

            public isClosed(): boolean;

            public getMaxRows(): number;

            public cancel(): void;

            public executeUpdate(param0: string, param1: native.Array<number>): number;

            public setMaxRows(param0: number): void;

            public unwrap(param0: java.lang.Class): java.lang.Object;

            public setPoolable(param0: boolean): void;

            public executeUpdate(param0: string, param1: native.Array<string>): number;

            public getWarnings(): java.sql.SQLWarning;

            public addBatch(param0: string): void;

            public getUpdateCount(): number;

            public executeBatch(): native.Array<number>;

            public isPoolable(): boolean;

            public execute(param0: string, param1: number): boolean;

            public getConnection(): java.sql.Connection;

            public getMaxFieldSize(): number;

            public clearWarnings(): void;

            public close(): void;

            public execute(param0: string): boolean;

            public getFetchSize(): number;

            public getResultSetHoldability(): number;

            public getResultSetType(): number;

            public executeUpdate(param0: string): number;

            public setCursorName(param0: string): void;

            public getGeneratedKeys(): java.sql.ResultSet;

            public getMoreResults(): boolean;

            public isWrapperFor(param0: java.lang.Class): boolean;

            public setQueryTimeout(param0: number): void;

            public getFetchDirection(): number;

            public getResultSetConcurrency(): number;

            public setMaxFieldSize(param0: number): void;

            public clearBatch(): void;

            public executeQuery(param0: string): java.sql.ResultSet;

            public setFetchDirection(param0: number): void;

            public setFetchSize(param0: number): void;

            public setEscapeProcessing(param0: boolean): void;

            public executeUpdate(param0: string, param1: number): number;

            public getResultSet(): java.sql.ResultSet;

            public getMoreResults(param0: number): boolean;

            public execute(param0: string, param1: native.Array<number>): boolean;

            public getQueryTimeout(): number;

            public execute(param0: string, param1: native.Array<string>): boolean;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module sql {
        export class Struct extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.Struct interface with the provided implementation.
             */
            public constructor(implementation: {
                getSQLTypeName(): string;
                getAttributes(): native.Array<java.lang.Object>;
                getAttributes(param0: java.util.Map): native.Array<java.lang.Object>;
            });

            public getAttributes(): native.Array<java.lang.Object>;

            public getSQLTypeName(): string;

            public getAttributes(param0: java.util.Map): native.Array<java.lang.Object>;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module sql {
        export class Time extends java.util.Date {
            public constructor(param0: number, param1: number, param2: number);

            public setMonth(param0: number): void;

            public getDate(): number;

            public static valueOf(param0: string): java.sql.Time;

            public setYear(param0: number): void;

            public constructor(param0: number);
            public constructor();

            public setDate(param0: number): void;

            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number);

            public getYear(): number;

            public getMonth(): number;

            public toString(): string;

            public getDay(): number;

            public setTime(param0: number): void;

            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number);
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
declare module java {
    export module sql {
        export class Timestamp extends java.util.Date {
            public constructor(param0: number, param1: number, param2: number);

            public static valueOf(param0: string): java.sql.Timestamp;

            public after(param0: java.sql.Timestamp): boolean;

            public setNanos(param0: number): void;

            public before(param0: java.util.Date): boolean;

            public constructor(param0: number);

            public after(param0: java.util.Date): boolean;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number);

            public compareTo(param0: java.util.Date): number;

            public getNanos(): number;

            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number, param6: number);

            public toString(): string;

            public setTime(param0: number): void;

            public getTime(): number;

            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number);

            public before(param0: java.sql.Timestamp): boolean;

            public compareTo(param0: java.sql.Timestamp): number;

            public equals(param0: java.sql.Timestamp): boolean;

            public constructor(param0: string);
        }
    }
}

declare module java {
    export module sql {
        export class Types extends java.lang.Object {
            public static ARRAY: number;
            public static BIGINT: number;
            public static BINARY: number;
            public static BIT: number;
            public static BLOB: number;
            public static BOOLEAN: number;
            public static CHAR: number;
            public static CLOB: number;
            public static DATALINK: number;
            public static DATE: number;
            public static DECIMAL: number;
            public static DISTINCT: number;
            public static DOUBLE: number;
            public static FLOAT: number;
            public static INTEGER: number;
            public static JAVA_OBJECT: number;
            public static LONGNVARCHAR: number;
            public static LONGVARBINARY: number;
            public static LONGVARCHAR: number;
            public static NCHAR: number;
            public static NCLOB: number;
            public static NULL: number;
            public static NUMERIC: number;
            public static NVARCHAR: number;
            public static OTHER: number;
            public static REAL: number;
            public static REF: number;
            public static ROWID: number;
            public static SMALLINT: number;
            public static SQLXML: number;
            public static STRUCT: number;
            public static TIME: number;
            public static TIMESTAMP: number;
            public static TINYINT: number;
            public static VARBINARY: number;
            public static VARCHAR: number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module sql {
        export class Wrapper extends java.lang.Object {
            /**
             * Constructs a new instance of the java.sql.Wrapper interface with the provided implementation.
             */
            public constructor(implementation: {
                unwrap(param0: java.lang.Class): java.lang.Object;
                isWrapperFor(param0: java.lang.Class): boolean;
            });

            public isWrapperFor(param0: java.lang.Class): boolean;

            public unwrap(param0: java.lang.Class): java.lang.Object;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module text {
        export class Annotation extends java.lang.Object {
            public getValue(): java.lang.Object;

            public toString(): string;

            public constructor(param0: java.lang.Object);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module text {
        export class AttributedCharacterIterator extends java.lang.Object implements java.text.CharacterIterator {
            /**
             * Constructs a new instance of the java.text.AttributedCharacterIterator interface with the provided implementation.
             */
            public constructor(implementation: {
                getAllAttributeKeys(): java.util.Set;
                getAttribute(param0: java.text.AttributedCharacterIterator.Attribute): java.lang.Object;
                getAttributes(): java.util.Map;
                getRunLimit(): number;
                getRunLimit(param0: java.text.AttributedCharacterIterator.Attribute): number;
                getRunLimit(param0: java.util.Set): number;
                getRunStart(): number;
                getRunStart(param0: java.text.AttributedCharacterIterator.Attribute): number;
                getRunStart(param0: java.util.Set): number;
                clone(): java.lang.Object;
                current(): string;
                first(): string;
                getBeginIndex(): number;
                getEndIndex(): number;
                getIndex(): number;
                last(): string;
                next(): string;
                previous(): string;
                setIndex(param0: number): string;
            });

            public static DONE: string;

            public getIndex(): number;

            public getRunStart(param0: java.text.AttributedCharacterIterator.Attribute): number;

            public setIndex(param0: number): string;

            public getRunLimit(param0: java.text.AttributedCharacterIterator.Attribute): number;

            public getAttributes(): java.util.Map;

            public getAttribute(param0: java.text.AttributedCharacterIterator.Attribute): java.lang.Object;

            public first(): string;

            public current(): string;

            public getBeginIndex(): number;

            public last(): string;

            public next(): string;

            public getRunLimit(): number;

            public getRunStart(): number;
            public getRunStart(param0: java.util.Set): number;

            public getRunLimit(param0: java.util.Set): number;

            public getEndIndex(): number;

            public clone(): java.lang.Object;

            public getAllAttributeKeys(): java.util.Set;

            public previous(): string;
        }
        export module AttributedCharacterIterator {
            export class Attribute extends java.lang.Object implements java.io.Serializable {
                public static INPUT_METHOD_SEGMENT: java.text.AttributedCharacterIterator.Attribute;
                public static LANGUAGE: java.text.AttributedCharacterIterator.Attribute;
                public static READING: java.text.AttributedCharacterIterator.Attribute;

                public equals(param0: java.lang.Object): boolean;

                public readResolve(): java.lang.Object;

                public hashCode(): number;

                public getName(): string;

                public toString(): string;

                public constructor(param0: string);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.text.AttributedCharacterIterator.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
declare module java {
    export module text {
        export class AttributedString extends java.lang.Object {
            public constructor(param0: java.text.AttributedCharacterIterator);

            public getIterator(): java.text.AttributedCharacterIterator;

            public constructor(param0: java.text.AttributedCharacterIterator, param1: number, param2: number, param3: native.Array<java.text.AttributedCharacterIterator.Attribute>);

            public getIterator(param0: native.Array<java.text.AttributedCharacterIterator.Attribute>): java.text.AttributedCharacterIterator;

            public constructor(param0: java.text.AttributedCharacterIterator, param1: number, param2: number);
            public constructor(param0: string, param1: java.util.Map);

            public addAttributes(param0: java.util.Map, param1: number, param2: number): void;

            public addAttribute(param0: java.text.AttributedCharacterIterator.Attribute, param1: java.lang.Object): void;

            public getIterator(param0: native.Array<java.text.AttributedCharacterIterator.Attribute>, param1: number, param2: number): java.text.AttributedCharacterIterator;

            public addAttribute(param0: java.text.AttributedCharacterIterator.Attribute, param1: java.lang.Object, param2: number, param3: number): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.text.AttributedCharacterIterator.d.ts" />
declare module java {
    export module text {
        export class Bidi extends java.lang.Object {
            public static DIRECTION_DEFAULT_LEFT_TO_RIGHT: number;
            public static DIRECTION_DEFAULT_RIGHT_TO_LEFT: number;
            public static DIRECTION_LEFT_TO_RIGHT: number;
            public static DIRECTION_RIGHT_TO_LEFT: number;

            public getRunStart(param0: number): number;

            public static reorderVisually(param0: native.Array<number>, param1: number, param2: native.Array<java.lang.Object>, param3: number, param4: number): void;

            public getBaseLevel(): number;

            public getRunCount(): number;

            public getLength(): number;

            public isRightToLeft(): boolean;

            public getRunLevel(param0: number): number;

            public constructor(param0: native.Array<string>, param1: number, param2: native.Array<number>, param3: number, param4: number, param5: number);

            public getRunLimit(param0: number): number;

            public isLeftToRight(): boolean;

            public getLevelAt(param0: number): number;

            public constructor(param0: java.text.AttributedCharacterIterator);

            public baseIsLeftToRight(): boolean;

            public static requiresBidi(param0: native.Array<string>, param1: number, param2: number): boolean;

            public isMixed(): boolean;

            public toString(): string;

            public constructor(param0: string, param1: number);

            public createLineBidi(param0: number, param1: number): java.text.Bidi;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.text.CharacterIterator.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module text {
        export abstract class BreakIterator extends java.lang.Object implements java.lang.Cloneable {
            public static DONE: number;

            public current(): number;

            public setText(param0: string): void;

            public static getSentenceInstance(param0: java.util.Locale): java.text.BreakIterator;

            public setText(param0: java.text.CharacterIterator): void;

            public following(param0: number): number;

            public getText(): java.text.CharacterIterator;

            public constructor();

            public static getLineInstance(param0: java.util.Locale): java.text.BreakIterator;

            public static getWordInstance(): java.text.BreakIterator;

            public next(param0: number): number;

            public previous(): number;

            public static getCharacterInstance(): java.text.BreakIterator;

            public static getWordInstance(param0: java.util.Locale): java.text.BreakIterator;

            public static getSentenceInstance(): java.text.BreakIterator;

            public next(): number;

            public static getAvailableLocales(): native.Array<java.util.Locale>;

            public last(): number;

            public static getCharacterInstance(param0: java.util.Locale): java.text.BreakIterator;

            public static getLineInstance(): java.text.BreakIterator;

            public preceding(param0: number): number;

            public clone(): java.lang.Object;

            public isBoundary(param0: number): boolean;

            public first(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module text {
        export class CharacterIterator extends java.lang.Object implements java.lang.Cloneable {
            /**
             * Constructs a new instance of the java.text.CharacterIterator interface with the provided implementation.
             */
            public constructor(implementation: {
                clone(): java.lang.Object;
                current(): string;
                first(): string;
                getBeginIndex(): number;
                getEndIndex(): number;
                getIndex(): number;
                last(): string;
                next(): string;
                previous(): string;
                setIndex(param0: number): string;
            });

            public static DONE: string;

            public getIndex(): number;

            public getEndIndex(): number;

            public setIndex(param0: number): string;

            public first(): string;

            public current(): string;

            public getBeginIndex(): number;

            public clone(): java.lang.Object;

            public last(): string;

            public next(): string;

            public previous(): string;
        }
    }
}

/// <reference path="./java.lang.Number.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
/// <reference path="./java.text.FieldPosition.d.ts" />
/// <reference path="./java.text.ParsePosition.d.ts" />
declare module java {
    export module text {
        export class ChoiceFormat extends java.text.NumberFormat {
            public format(param0: java.lang.Object): string;

            public applyPattern(param0: string): void;

            public format(param0: number): string;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public toPattern(): string;

            public constructor(param0: native.Array<number>, param1: native.Array<string>);

            public format(param0: number, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public getFormats(): native.Array<java.lang.Object>;

            public getLimits(): native.Array<number>;

            public static previousDouble(param0: number): number;

            public setChoices(param0: native.Array<number>, param1: native.Array<string>): void;

            public static nextDouble(param0: number, param1: boolean): number;
            public static nextDouble(param0: number): number;

            public format(param0: java.lang.Object, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public clone(): java.lang.Object;

            public parse(param0: string): java.lang.Number;
            public parse(param0: string, param1: java.text.ParsePosition): java.lang.Number;

            public constructor(param0: string);

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.text.CharacterIterator.d.ts" />
declare module java {
    export module text {
        export class CollationElementIterator extends java.lang.Object {
            public static NULLORDER: number;

            public static primaryOrder(param0: number): number;

            public next(): number;

            public static tertiaryOrder(param0: number): number;

            public static secondaryOrder(param0: number): number;

            public setText(param0: string): void;
            public setText(param0: java.text.CharacterIterator): void;

            public getOffset(): number;

            public reset(): void;

            public previous(): number;

            public setOffset(param0: number): void;

            public getMaxExpansion(param0: number): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module text {
        export abstract class CollationKey extends java.lang.Object {
            public toByteArray(): native.Array<number>;

            public compareTo(param0: java.text.CollationKey): number;

            public constructor(param0: string);

            public getSourceString(): string;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.text.CollationKey.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module text {
        export abstract class Collator extends java.lang.Object implements java.util.Comparator, java.lang.Cloneable {
            public static CANONICAL_DECOMPOSITION: number;
            public static FULL_DECOMPOSITION: number;
            public static IDENTICAL: number;
            public static NO_DECOMPOSITION: number;
            public static PRIMARY: number;
            public static SECONDARY: number;
            public static TERTIARY: number;

            public getCollationKey(param0: string): java.text.CollationKey;

            public getStrength(): number;

            public equals(param0: string, param1: string): boolean;

            public getDecomposition(): number;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public compare(param0: string, param1: string): number;

            public setStrength(param0: number): void;

            public static getInstance(): java.text.Collator;

            public static getAvailableLocales(): native.Array<java.util.Locale>;

            public static getInstance(param0: java.util.Locale): java.text.Collator;

            public setDecomposition(param0: number): void;

            public clone(): java.lang.Object;

            public compare(param0: java.lang.Object, param1: java.lang.Object): number;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
/// <reference path="./java.text.FieldPosition.d.ts" />
/// <reference path="./java.text.NumberFormat.d.ts" />
/// <reference path="./java.text.ParsePosition.d.ts" />
/// <reference path="./java.util.Calendar.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
/// <reference path="./java.util.TimeZone.d.ts" />
declare module java {
    export module text {
        export abstract class DateFormat extends java.text.Format {
            public static AM_PM_FIELD: number;
            public static DATE_FIELD: number;
            public static DAY_OF_WEEK_FIELD: number;
            public static DAY_OF_WEEK_IN_MONTH_FIELD: number;
            public static DAY_OF_YEAR_FIELD: number;
            public static DEFAULT: number;
            public static ERA_FIELD: number;
            public static FULL: number;
            public static HOUR0_FIELD: number;
            public static HOUR1_FIELD: number;
            public static HOUR_OF_DAY0_FIELD: number;
            public static HOUR_OF_DAY1_FIELD: number;
            public static LONG: number;
            public static MEDIUM: number;
            public static MILLISECOND_FIELD: number;
            public static MINUTE_FIELD: number;
            public static MONTH_FIELD: number;
            public static SECOND_FIELD: number;
            public static SHORT: number;
            public static TIMEZONE_FIELD: number;
            public static WEEK_OF_MONTH_FIELD: number;
            public static WEEK_OF_YEAR_FIELD: number;
            public static YEAR_FIELD: number;
            public calendar: java.util.Calendar;
            public numberFormat: java.text.NumberFormat;

            public parseObject(param0: string, param1: java.text.ParsePosition): java.lang.Object;

            public getNumberFormat(): java.text.NumberFormat;

            public getTimeZone(): java.util.TimeZone;

            public static getDateInstance(param0: number, param1: java.util.Locale): java.text.DateFormat;

            public equals(param0: java.lang.Object): boolean;

            public getCalendar(): java.util.Calendar;

            public static getTimeInstance(param0: number): java.text.DateFormat;

            public static getInstance(): java.text.DateFormat;

            public format(param0: java.util.Date): string;

            public setNumberFormat(param0: java.text.NumberFormat): void;

            public parse(param0: string, param1: java.text.ParsePosition): java.util.Date;

            public setLenient(param0: boolean): void;

            public parse(param0: string): java.util.Date;

            public format(param0: java.lang.Object, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public static getAvailableLocales(): native.Array<java.util.Locale>;

            public static getDateInstance(param0: number): java.text.DateFormat;

            public parseObject(param0: string): java.lang.Object;

            public format(param0: java.util.Date, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;
            public format(param0: java.lang.Object): string;

            public static getDateInstance(): java.text.DateFormat;

            public constructor();

            public isLenient(): boolean;

            public setCalendar(param0: java.util.Calendar): void;

            public static getTimeInstance(): java.text.DateFormat;

            public static getDateTimeInstance(): java.text.DateFormat;
            public static getDateTimeInstance(param0: number, param1: number, param2: java.util.Locale): java.text.DateFormat;

            public static getTimeInstance(param0: number, param1: java.util.Locale): java.text.DateFormat;

            public setTimeZone(param0: java.util.TimeZone): void;

            public clone(): java.lang.Object;

            public static getDateTimeInstance(param0: number, param1: number): java.text.DateFormat;

            public hashCode(): number;
        }
        export module DateFormat {
            export class Field extends java.text.Format.Field {
                public static AM_PM: java.text.DateFormat.Field;
                public static DAY_OF_MONTH: java.text.DateFormat.Field;
                public static DAY_OF_WEEK: java.text.DateFormat.Field;
                public static DAY_OF_WEEK_IN_MONTH: java.text.DateFormat.Field;
                public static DAY_OF_YEAR: java.text.DateFormat.Field;
                public static ERA: java.text.DateFormat.Field;
                public static HOUR0: java.text.DateFormat.Field;
                public static HOUR1: java.text.DateFormat.Field;
                public static HOUR_OF_DAY0: java.text.DateFormat.Field;
                public static HOUR_OF_DAY1: java.text.DateFormat.Field;
                public static MILLISECOND: java.text.DateFormat.Field;
                public static MINUTE: java.text.DateFormat.Field;
                public static MONTH: java.text.DateFormat.Field;
                public static SECOND: java.text.DateFormat.Field;
                public static TIME_ZONE: java.text.DateFormat.Field;
                public static WEEK_OF_MONTH: java.text.DateFormat.Field;
                public static WEEK_OF_YEAR: java.text.DateFormat.Field;
                public static YEAR: java.text.DateFormat.Field;

                public static ofCalendarField(param0: number): java.text.DateFormat.Field;

                public getCalendarField(): number;

                public constructor(param0: string, param1: number);
                public constructor(param0: string);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module text {
        export class DateFormatSymbols extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable {
            public setEras(param0: native.Array<string>): void;

            public setShortWeekdays(param0: native.Array<string>): void;

            public equals(param0: java.lang.Object): boolean;

            public getEras(): native.Array<string>;

            public setWeekdays(param0: native.Array<string>): void;

            public static getInstance(): java.text.DateFormatSymbols;

            public static getAvailableLocales(): native.Array<java.util.Locale>;

            public setMonths(param0: native.Array<string>): void;

            public setShortMonths(param0: native.Array<string>): void;

            public getShortWeekdays(): native.Array<string>;

            public setZoneStrings(param0: native.Array<native.Array<string>>): void;

            public getLocalPatternChars(): string;

            public getWeekdays(): native.Array<string>;

            public getAmPmStrings(): native.Array<string>;

            public setAmPmStrings(param0: native.Array<string>): void;

            public getMonths(): native.Array<string>;

            public getZoneStrings(): native.Array<native.Array<string>>;

            public constructor();

            public static getInstance(param0: java.util.Locale): java.text.DateFormatSymbols;

            public constructor(param0: java.util.Locale);

            public toString(): string;

            public getShortMonths(): native.Array<string>;

            public clone(): java.lang.Object;

            public setLocalPatternChars(param0: string): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Number.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
/// <reference path="./java.math.RoundingMode.d.ts" />
/// <reference path="./java.text.AttributedCharacterIterator.d.ts" />
/// <reference path="./java.text.DecimalFormatSymbols.d.ts" />
/// <reference path="./java.text.FieldPosition.d.ts" />
/// <reference path="./java.text.ParsePosition.d.ts" />
/// <reference path="./java.util.Currency.d.ts" />
declare module java {
    export module text {
        export class DecimalFormat extends java.text.NumberFormat {
            public setGroupingUsed(param0: boolean): void;

            public setMaximumFractionDigits(param0: number): void;

            public setNegativeSuffix(param0: string): void;

            public formatToCharacterIterator(param0: java.lang.Object): java.text.AttributedCharacterIterator;

            public getGroupingSize(): number;

            public setParseBigDecimal(param0: boolean): void;

            public getNegativePrefix(): string;

            public setGroupingSize(param0: number): void;

            public setMinimumFractionDigits(param0: number): void;

            public applyPattern(param0: string): void;

            public equals(param0: java.lang.Object): boolean;

            public setMultiplier(param0: number): void;

            public setPositiveSuffix(param0: string): void;

            public isParseIntegerOnly(): boolean;

            public setNegativePrefix(param0: string): void;

            public applyLocalizedPattern(param0: string): void;

            public getPositivePrefix(): string;

            public isGroupingUsed(): boolean;

            public getNegativeSuffix(): string;

            public setDecimalSeparatorAlwaysShown(param0: boolean): void;

            public format(param0: java.lang.Object, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public setMinimumIntegerDigits(param0: number): void;

            public parse(param0: string, param1: java.text.ParsePosition): java.lang.Number;

            public constructor(param0: string);

            public getRoundingMode(): java.math.RoundingMode;

            public constructor(param0: string, param1: java.text.DecimalFormatSymbols);

            public format(param0: java.lang.Object): string;

            public isDecimalSeparatorAlwaysShown(): boolean;

            public getPositiveSuffix(): string;

            public setPositivePrefix(param0: string): void;

            public setDecimalFormatSymbols(param0: java.text.DecimalFormatSymbols): void;

            public getDecimalFormatSymbols(): java.text.DecimalFormatSymbols;

            public setRoundingMode(param0: java.math.RoundingMode): void;

            public format(param0: number): string;

            public constructor();

            public isParseBigDecimal(): boolean;

            public toPattern(): string;

            public setCurrency(param0: java.util.Currency): void;

            public format(param0: number, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public getCurrency(): java.util.Currency;

            public setMaximumIntegerDigits(param0: number): void;

            public toString(): string;

            public setParseIntegerOnly(param0: boolean): void;

            public toLocalizedPattern(): string;

            public getMultiplier(): number;

            public clone(): java.lang.Object;

            public parse(param0: string): java.lang.Number;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Currency.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module text {
        export class DecimalFormatSymbols extends java.lang.Object implements java.lang.Cloneable, java.io.Serializable {
            public setMinusSign(param0: string): void;

            public equals(param0: java.lang.Object): boolean;

            public getPerMill(): string;

            public static getInstance(): java.text.DecimalFormatSymbols;
            public static getInstance(param0: java.util.Locale): java.text.DecimalFormatSymbols;

            public getZeroDigit(): string;

            public setGroupingSeparator(param0: string): void;

            public setMonetaryDecimalSeparator(param0: string): void;

            public setDecimalSeparator(param0: string): void;

            public static getAvailableLocales(): native.Array<java.util.Locale>;

            public getCurrencySymbol(): string;

            public getExponentSeparator(): string;

            public setZeroDigit(param0: string): void;

            public setPerMill(param0: string): void;

            public setInternationalCurrencySymbol(param0: string): void;

            public getInternationalCurrencySymbol(): string;

            public setDigit(param0: string): void;

            public setPercent(param0: string): void;

            public setExponentSeparator(param0: string): void;

            public getPatternSeparator(): string;

            public setCurrencySymbol(param0: string): void;

            public getInfinity(): string;

            public constructor();

            public getDecimalSeparator(): string;

            public getMinusSign(): string;

            public constructor(param0: java.util.Locale);

            public getDigit(): string;

            public setInfinity(param0: string): void;

            public getPercent(): string;

            public setCurrency(param0: java.util.Currency): void;

            public toString(): string;

            public getCurrency(): java.util.Currency;

            public setNaN(param0: string): void;

            public getMonetaryDecimalSeparator(): string;

            public getNaN(): string;

            public setPatternSeparator(param0: string): void;

            public getGroupingSeparator(): string;

            public clone(): java.lang.Object;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module text {
        export class FieldPosition extends java.lang.Object {
            public setBeginIndex(param0: number): void;

            public constructor(param0: java.text.Format.Field, param1: number);

            public getFieldAttribute(): java.text.Format.Field;

            public toString(): string;

            public getEndIndex(): number;

            public constructor(param0: java.text.Format.Field);
            public constructor(param0: number);

            public getField(): number;

            public equals(param0: java.lang.Object): boolean;

            public getBeginIndex(): number;

            public setEndIndex(param0: number): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
/// <reference path="./java.text.AttributedCharacterIterator.d.ts" />
/// <reference path="./java.text.FieldPosition.d.ts" />
/// <reference path="./java.text.ParsePosition.d.ts" />
declare module java {
    export module text {
        export abstract class Format extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable {
            public format(param0: java.lang.Object): string;

            public formatToCharacterIterator(param0: java.lang.Object): java.text.AttributedCharacterIterator;

            public parseObject(param0: string, param1: java.text.ParsePosition): java.lang.Object;

            public format(param0: java.lang.Object, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public parseObject(param0: string): java.lang.Object;

            public constructor();

            public clone(): java.lang.Object;
        }
        export module Format {
            export class Field extends java.text.AttributedCharacterIterator.Attribute {
                public constructor(param0: string);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
/// <reference path="./java.text.AttributedCharacterIterator.d.ts" />
/// <reference path="./java.text.FieldPosition.d.ts" />
/// <reference path="./java.text.Format.d.ts" />
/// <reference path="./java.text.ParsePosition.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module text {
        export class MessageFormat extends java.text.Format {
            public setLocale(param0: java.util.Locale): void;

            public setFormatsByArgumentIndex(param0: native.Array<java.text.Format>): void;

            public formatToCharacterIterator(param0: java.lang.Object): java.text.AttributedCharacterIterator;

            public parseObject(param0: string, param1: java.text.ParsePosition): java.lang.Object;

            public setFormats(param0: native.Array<java.text.Format>): void;

            public applyPattern(param0: string): void;

            public equals(param0: java.lang.Object): boolean;

            public format(param0: java.lang.Object, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public parse(param0: string): native.Array<java.lang.Object>;

            public parseObject(param0: string): java.lang.Object;

            public setFormat(param0: number, param1: java.text.Format): void;

            public constructor(param0: string);

            public setFormatByArgumentIndex(param0: number, param1: java.text.Format): void;

            public getLocale(): java.util.Locale;

            public format(param0: java.lang.Object): string;

            public constructor(param0: string, param1: java.util.Locale);

            public static format(param0: string, param1: native.Array<java.lang.Object>): string;

            public getFormats(): native.Array<java.text.Format>;

            public constructor();

            public toPattern(): string;

            public getFormatsByArgumentIndex(): native.Array<java.text.Format>;

            public parse(param0: string, param1: java.text.ParsePosition): native.Array<java.lang.Object>;

            public format(param0: native.Array<java.lang.Object>, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public clone(): java.lang.Object;

            public hashCode(): number;
        }
        export module MessageFormat {
            export class Field extends java.text.Format.Field {
                public static ARGUMENT: java.text.MessageFormat.Field;

                public constructor(param0: string);
            }
        }
    }
}

/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module text {
        export class Normalizer extends java.lang.Object {
            public static isNormalized(param0: string, param1: java.text.Normalizer.Form): boolean;

            public static normalize(param0: string, param1: java.text.Normalizer.Form): string;
        }
        export module Normalizer {
            export class Form extends java.lang.Enum {
                public static NFC: java.text.Normalizer.Form;
                public static NFD: java.text.Normalizer.Form;
                public static NFKC: java.text.Normalizer.Form;
                public static NFKD: java.text.Normalizer.Form;

                public static values(): native.Array<java.text.Normalizer.Form>;

                public static valueOf(param0: string): java.text.Normalizer.Form;
                public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;
            }
        }
    }
}

/// <reference path="./java.lang.Number.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
/// <reference path="./java.math.RoundingMode.d.ts" />
/// <reference path="./java.text.FieldPosition.d.ts" />
/// <reference path="./java.text.ParsePosition.d.ts" />
/// <reference path="./java.util.Currency.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module text {
        export abstract class NumberFormat extends java.text.Format {
            public static FRACTION_FIELD: number;
            public static INTEGER_FIELD: number;

            public setGroupingUsed(param0: boolean): void;

            public setMaximumFractionDigits(param0: number): void;

            public parseObject(param0: string, param1: java.text.ParsePosition): java.lang.Object;

            public setMinimumFractionDigits(param0: number): void;

            public getMaximumIntegerDigits(): number;

            public static getCurrencyInstance(): java.text.NumberFormat;

            public equals(param0: java.lang.Object): boolean;

            public static getIntegerInstance(param0: java.util.Locale): java.text.NumberFormat;

            public static getNumberInstance(): java.text.NumberFormat;

            public static getCurrencyInstance(param0: java.util.Locale): java.text.NumberFormat;

            public getMinimumIntegerDigits(): number;

            public isParseIntegerOnly(): boolean;

            public isGroupingUsed(): boolean;

            public getMaximumFractionDigits(): number;

            public format(param0: java.lang.Object, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public static getAvailableLocales(): native.Array<java.util.Locale>;

            public setMinimumIntegerDigits(param0: number): void;

            public static getInstance(param0: java.util.Locale): java.text.NumberFormat;

            public parseObject(param0: string): java.lang.Object;

            public parse(param0: string, param1: java.text.ParsePosition): java.lang.Number;

            public getRoundingMode(): java.math.RoundingMode;

            public format(param0: java.lang.Object): string;

            public static getInstance(): java.text.NumberFormat;

            public static getIntegerInstance(): java.text.NumberFormat;

            public setRoundingMode(param0: java.math.RoundingMode): void;

            public format(param0: number): string;

            public constructor();

            public static getPercentInstance(): java.text.NumberFormat;
            public static getPercentInstance(param0: java.util.Locale): java.text.NumberFormat;

            public setCurrency(param0: java.util.Currency): void;

            public format(param0: number, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public static getNumberInstance(param0: java.util.Locale): java.text.NumberFormat;

            public getCurrency(): java.util.Currency;

            public setMaximumIntegerDigits(param0: number): void;

            public setParseIntegerOnly(param0: boolean): void;

            public getMinimumFractionDigits(): number;

            public clone(): java.lang.Object;

            public parse(param0: string): java.lang.Number;

            public hashCode(): number;
        }
        export module NumberFormat {
            export class Field extends java.text.Format.Field {
                public static CURRENCY: java.text.NumberFormat.Field;
                public static DECIMAL_SEPARATOR: java.text.NumberFormat.Field;
                public static EXPONENT: java.text.NumberFormat.Field;
                public static EXPONENT_SIGN: java.text.NumberFormat.Field;
                public static EXPONENT_SYMBOL: java.text.NumberFormat.Field;
                public static FRACTION: java.text.NumberFormat.Field;
                public static GROUPING_SEPARATOR: java.text.NumberFormat.Field;
                public static INTEGER: java.text.NumberFormat.Field;
                public static PERCENT: java.text.NumberFormat.Field;
                public static PERMILLE: java.text.NumberFormat.Field;
                public static SIGN: java.text.NumberFormat.Field;

                public constructor(param0: string);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module text {
        export class ParseException extends java.lang.Exception {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: number);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);

            public getErrorOffset(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module text {
        export class ParsePosition extends java.lang.Object {
            public getIndex(): number;

            public setIndex(param0: number): void;

            public toString(): string;

            public getErrorIndex(): number;

            public constructor(param0: number);

            public equals(param0: java.lang.Object): boolean;

            public hashCode(): number;

            public setErrorIndex(param0: number): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.text.CharacterIterator.d.ts" />
/// <reference path="./java.text.CollationElementIterator.d.ts" />
/// <reference path="./java.text.CollationKey.d.ts" />
declare module java {
    export module text {
        export class RuleBasedCollator extends java.text.Collator {
            public getCollationKey(param0: string): java.text.CollationKey;

            public getCollationElementIterator(param0: string): java.text.CollationElementIterator;

            public equals(param0: string, param1: string): boolean;

            public getCollationElementIterator(param0: java.text.CharacterIterator): java.text.CollationElementIterator;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public clone(): java.lang.Object;

            public compare(param0: java.lang.Object, param1: java.lang.Object): number;

            public constructor(param0: string);

            public compare(param0: string, param1: string): number;

            public getRules(): string;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
/// <reference path="./java.text.AttributedCharacterIterator.d.ts" />
/// <reference path="./java.text.DateFormatSymbols.d.ts" />
/// <reference path="./java.text.FieldPosition.d.ts" />
/// <reference path="./java.text.ParsePosition.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module text {
        export class SimpleDateFormat extends java.text.DateFormat {
            public format(param0: java.lang.Object): string;

            public constructor(param0: string, param1: java.util.Locale);

            public formatToCharacterIterator(param0: java.lang.Object): java.text.AttributedCharacterIterator;

            public applyPattern(param0: string): void;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public toPattern(): string;

            public get2DigitYearStart(): java.util.Date;

            public applyLocalizedPattern(param0: string): void;

            public format(param0: java.util.Date): string;

            public parse(param0: string, param1: java.text.ParsePosition): java.util.Date;

            public setDateFormatSymbols(param0: java.text.DateFormatSymbols): void;

            public parse(param0: string): java.util.Date;

            public toLocalizedPattern(): string;

            public format(param0: java.lang.Object, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public constructor(param0: string, param1: java.text.DateFormatSymbols);

            public set2DigitYearStart(param0: java.util.Date): void;

            public getDateFormatSymbols(): java.text.DateFormatSymbols;

            public clone(): java.lang.Object;

            public format(param0: java.util.Date, param1: java.lang.StringBuffer, param2: java.text.FieldPosition): java.lang.StringBuffer;

            public constructor(param0: string);

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module text {
        export class StringCharacterIterator extends java.lang.Object implements java.text.CharacterIterator {
            public getIndex(): number;

            public setText(param0: string): void;

            public setIndex(param0: number): string;

            public first(): string;

            public current(): string;

            public equals(param0: java.lang.Object): boolean;

            public getBeginIndex(): number;

            public last(): string;

            public next(): string;

            public getEndIndex(): number;

            public constructor(param0: string, param1: number);
            public constructor(param0: string, param1: number, param2: number, param3: number);

            public clone(): java.lang.Object;

            public constructor(param0: string);

            public hashCode(): number;

            public previous(): string;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export abstract class AbstractCollection extends java.lang.Object implements java.util.Collection {
            public clear(): void;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public containsAll(param0: java.util.Collection): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public constructor();

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public toString(): string;

            public retainAll(param0: java.util.Collection): boolean;

            public contains(param0: java.lang.Object): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.ListIterator.d.ts" />
declare module java {
    export module util {
        export abstract class AbstractList extends java.util.AbstractCollection implements java.util.List {
            public modCount: number;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public subList(param0: number, param1: number): java.util.List;

            public get(param0: number): java.lang.Object;

            public lastIndexOf(param0: java.lang.Object): number;

            public addAll(param0: java.util.Collection): boolean;

            public listIterator(): java.util.ListIterator;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public removeRange(param0: number, param1: number): void;

            public addAll(param0: number, param1: java.util.Collection): boolean;

            public indexOf(param0: java.lang.Object): number;

            public set(param0: number, param1: java.lang.Object): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public containsAll(param0: java.util.Collection): boolean;

            public remove(param0: number): java.lang.Object;

            public constructor();

            public add(param0: number, param1: java.lang.Object): void;

            public listIterator(param0: number): java.util.ListIterator;

            public retainAll(param0: java.util.Collection): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export abstract class AbstractMap extends java.lang.Object implements java.util.Map {
            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public toString(): string;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public clone(): java.lang.Object;

            public containsKey(param0: java.lang.Object): boolean;

            public hashCode(): number;

            public putAll(param0: java.util.Map): void;
        }
        export module AbstractMap {
            export class SimpleEntry extends java.lang.Object implements java.util.Map.Entry, java.io.Serializable {
                public getKey(): java.lang.Object;

                public setValue(param0: java.lang.Object): java.lang.Object;

                public equals(param0: java.lang.Object): boolean;

                public constructor(param0: java.util.Map.Entry);
                public constructor(param0: java.lang.Object, param1: java.lang.Object);

                public getValue(): java.lang.Object;

                public hashCode(): number;

                public toString(): string;
            }
            export class SimpleImmutableEntry extends java.lang.Object implements java.util.Map.Entry, java.io.Serializable {
                public getKey(): java.lang.Object;

                public setValue(param0: java.lang.Object): java.lang.Object;

                public equals(param0: java.lang.Object): boolean;

                public constructor(param0: java.util.Map.Entry);
                public constructor(param0: java.lang.Object, param1: java.lang.Object);

                public getValue(): java.lang.Object;

                public hashCode(): number;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export abstract class AbstractQueue extends java.util.AbstractCollection implements java.util.Queue {
            public clear(): void;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public poll(): java.lang.Object;

            public element(): java.lang.Object;

            public containsAll(param0: java.util.Collection): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public constructor();

            public remove(): java.lang.Object;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public retainAll(param0: java.util.Collection): boolean;

            public offer(param0: java.lang.Object): boolean;

            public peek(): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.ListIterator.d.ts" />
declare module java {
    export module util {
        export abstract class AbstractSequentialList extends java.util.AbstractList {
            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public subList(param0: number, param1: number): java.util.List;

            public get(param0: number): java.lang.Object;

            public lastIndexOf(param0: java.lang.Object): number;

            public addAll(param0: java.util.Collection): boolean;

            public listIterator(): java.util.ListIterator;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public addAll(param0: number, param1: java.util.Collection): boolean;

            public set(param0: number, param1: java.lang.Object): java.lang.Object;

            public indexOf(param0: java.lang.Object): number;

            public contains(param0: java.lang.Object): boolean;

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public containsAll(param0: java.util.Collection): boolean;

            public remove(param0: number): java.lang.Object;

            public constructor();

            public add(param0: number, param1: java.lang.Object): void;

            public listIterator(param0: number): java.util.ListIterator;

            public retainAll(param0: java.util.Collection): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export abstract class AbstractSet extends java.util.AbstractCollection implements java.util.Set {
            public clear(): void;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public removeAll(param0: java.util.Collection): boolean;

            public remove(param0: java.lang.Object): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public containsAll(param0: java.util.Collection): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public constructor();

            public equals(param0: java.lang.Object): boolean;

            public add(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public retainAll(param0: java.util.Collection): boolean;

            public contains(param0: java.lang.Object): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export class ArrayDeque extends java.util.AbstractCollection implements java.util.Deque, java.lang.Cloneable, java.io.Serializable {
            public removeLast(): java.lang.Object;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public pollFirst(): java.lang.Object;

            public removeFirst(): java.lang.Object;

            public peekFirst(): java.lang.Object;

            public pollLast(): java.lang.Object;

            public addAll(param0: java.util.Collection): boolean;

            public remove(): java.lang.Object;

            public getFirst(): java.lang.Object;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public push(param0: java.lang.Object): void;

            public toArray(): native.Array<java.lang.Object>;

            public clone(): java.util.ArrayDeque;

            public removeFirstOccurrence(param0: java.lang.Object): boolean;

            public offer(param0: java.lang.Object): boolean;

            public offerLast(param0: java.lang.Object): boolean;

            public constructor(param0: java.util.Collection);

            public getLast(): java.lang.Object;

            public peekLast(): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public addLast(param0: java.lang.Object): void;

            public offerFirst(param0: java.lang.Object): boolean;

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public size(): number;

            public isEmpty(): boolean;

            public poll(): java.lang.Object;

            public constructor(param0: number);

            public element(): java.lang.Object;

            public containsAll(param0: java.util.Collection): boolean;

            public constructor();

            public removeLastOccurrence(param0: java.lang.Object): boolean;

            public retainAll(param0: java.util.Collection): boolean;

            public peek(): java.lang.Object;

            public descendingIterator(): java.util.Iterator;

            public addFirst(param0: java.lang.Object): void;

            public clone(): java.lang.Object;

            public pop(): java.lang.Object;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.ListIterator.d.ts" />
declare module java {
    export module util {
        export class ArrayList extends java.util.AbstractList implements java.lang.Cloneable, java.io.Serializable, java.util.RandomAccess {
            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public subList(param0: number, param1: number): java.util.List;

            public get(param0: number): java.lang.Object;

            public lastIndexOf(param0: java.lang.Object): number;

            public addAll(param0: java.util.Collection): boolean;

            public listIterator(): java.util.ListIterator;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public ensureCapacity(param0: number): void;

            public toArray(): native.Array<java.lang.Object>;

            public removeRange(param0: number, param1: number): void;

            public addAll(param0: number, param1: java.util.Collection): boolean;

            public indexOf(param0: java.lang.Object): number;

            public set(param0: number, param1: java.lang.Object): java.lang.Object;

            public constructor(param0: java.util.Collection);

            public contains(param0: java.lang.Object): boolean;

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public size(): number;

            public isEmpty(): boolean;

            public constructor(param0: number);

            public containsAll(param0: java.util.Collection): boolean;

            public remove(param0: number): java.lang.Object;

            public constructor();

            public add(param0: number, param1: java.lang.Object): void;

            public listIterator(param0: number): java.util.ListIterator;

            public retainAll(param0: java.util.Collection): boolean;

            public trimToSize(): void;

            public clone(): java.lang.Object;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module util {
        export class Arrays extends java.lang.Object {
            public static copyOf(param0: native.Array<boolean>, param1: number): native.Array<boolean>;

            public static hashCode(param0: native.Array<java.lang.Object>): number;

            public static copyOf(param0: native.Array<string>, param1: number): native.Array<string>;

            public static hashCode(param0: native.Array<string>): number;

            public static sort(param0: native.Array<java.lang.Object>): void;

            public static binarySearch(param0: native.Array<number>, param1: number, param2: number, param3: number): number;

            public equals(param0: java.lang.Object): boolean;

            public static sort(param0: native.Array<number>, param1: number, param2: number): void;

            public static fill(param0: native.Array<boolean>, param1: number, param2: number, param3: boolean): void;

            public static binarySearch(param0: native.Array<java.lang.Object>, param1: java.lang.Object): number;
            public static binarySearch(param0: native.Array<string>, param1: string): number;

            public static equals(param0: native.Array<java.lang.Object>, param1: native.Array<java.lang.Object>): boolean;

            public static sort(param0: native.Array<java.lang.Object>, param1: number, param2: number): void;

            public static binarySearch(param0: native.Array<string>, param1: number, param2: number, param3: string): number;

            public static copyOfRange(param0: native.Array<boolean>, param1: number, param2: number): native.Array<boolean>;

            public static fill(param0: native.Array<java.lang.Object>, param1: java.lang.Object): void;

            public static hashCode(param0: native.Array<number>): number;

            public static copyOfRange(param0: native.Array<java.lang.Object>, param1: number, param2: number, param3: java.lang.Class): native.Array<java.lang.Object>;

            public static sort(param0: native.Array<java.lang.Object>, param1: java.util.Comparator): void;
            public static sort(param0: native.Array<number>): void;

            public static hashCode(param0: native.Array<boolean>): number;

            public static binarySearch(param0: native.Array<java.lang.Object>, param1: number, param2: number, param3: java.lang.Object, param4: java.util.Comparator): number;

            public static copyOfRange(param0: native.Array<number>, param1: number, param2: number): native.Array<number>;

            public static deepEquals(param0: native.Array<java.lang.Object>, param1: native.Array<java.lang.Object>): boolean;

            public static copyOfRange(param0: native.Array<java.lang.Object>, param1: number, param2: number): native.Array<java.lang.Object>;

            public static binarySearch(param0: native.Array<number>, param1: number): number;

            public static copyOf(param0: native.Array<number>, param1: number): native.Array<number>;

            public static toString(param0: native.Array<java.lang.Object>): string;

            public static fill(param0: native.Array<boolean>, param1: boolean): void;

            public static binarySearch(param0: native.Array<java.lang.Object>, param1: number, param2: number, param3: java.lang.Object): number;

            public static fill(param0: native.Array<number>, param1: number, param2: number, param3: number): void;

            public static asList(param0: native.Array<java.lang.Object>): java.util.List;

            public static fill(param0: native.Array<number>, param1: number): void;

            public static toString(param0: native.Array<string>): string;

            public static copyOf(param0: native.Array<java.lang.Object>, param1: number): native.Array<java.lang.Object>;

            public static fill(param0: native.Array<java.lang.Object>, param1: number, param2: number, param3: java.lang.Object): void;

            public static deepHashCode(param0: native.Array<java.lang.Object>): number;

            public static sort(param0: native.Array<string>): void;
            public static sort(param0: native.Array<string>, param1: number, param2: number): void;

            public static equals(param0: native.Array<string>, param1: native.Array<string>): boolean;

            public static toString(param0: native.Array<boolean>): string;

            public static equals(param0: native.Array<number>, param1: native.Array<number>): boolean;
            public static equals(param0: native.Array<boolean>, param1: native.Array<boolean>): boolean;

            public static copyOfRange(param0: native.Array<string>, param1: number, param2: number): native.Array<string>;

            public static fill(param0: native.Array<string>, param1: string): void;

            public static toString(param0: native.Array<number>): string;

            public static deepToString(param0: native.Array<java.lang.Object>): string;

            public toString(): string;

            public static sort(param0: native.Array<java.lang.Object>, param1: number, param2: number, param3: java.util.Comparator): void;

            public static copyOf(param0: native.Array<java.lang.Object>, param1: number, param2: java.lang.Class): native.Array<java.lang.Object>;

            public static fill(param0: native.Array<string>, param1: number, param2: number, param3: string): void;

            public static binarySearch(param0: native.Array<java.lang.Object>, param1: java.lang.Object, param2: java.util.Comparator): number;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.nio.ByteBuffer.d.ts" />
/// <reference path="./java.nio.LongBuffer.d.ts" />
declare module java {
    export module util {
        export class BitSet extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable {
            public clear(param0: number): void;

            public equals(param0: java.lang.Object): boolean;

            public set(param0: number, param1: number): void;

            public andNot(param0: java.util.BitSet): void;

            public previousClearBit(param0: number): number;

            public nextClearBit(param0: number): number;

            public clear(param0: number, param1: number): void;

            public intersects(param0: java.util.BitSet): boolean;

            public flip(param0: number, param1: number): void;

            public set(param0: number, param1: number, param2: boolean): void;

            public static valueOf(param0: java.nio.LongBuffer): java.util.BitSet;

            public previousSetBit(param0: number): number;

            public clear(): void;

            public nextSetBit(param0: number): number;

            public set(param0: number): void;

            public size(): number;

            public isEmpty(): boolean;

            public cardinality(): number;

            public toByteArray(): native.Array<number>;

            public length(): number;

            public constructor(param0: number);

            public or(param0: java.util.BitSet): void;

            public static valueOf(param0: native.Array<number>): java.util.BitSet;

            public constructor();

            public flip(param0: number): void;

            public set(param0: number, param1: boolean): void;

            public static valueOf(param0: java.nio.ByteBuffer): java.util.BitSet;

            public get(param0: number, param1: number): java.util.BitSet;

            public and(param0: java.util.BitSet): void;

            public toString(): string;

            public toLongArray(): native.Array<number>;

            public get(param0: number): boolean;

            public xor(param0: java.util.BitSet): void;

            public clone(): java.lang.Object;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.TimeZone.d.ts" />
declare module java {
    export module util {
        export abstract class Calendar extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable {
            public static ALL_STYLES: number;
            public static AM: number;
            public static AM_PM: number;
            public static APRIL: number;
            public static AUGUST: number;
            public static DATE: number;
            public static DAY_OF_MONTH: number;
            public static DAY_OF_WEEK: number;
            public static DAY_OF_WEEK_IN_MONTH: number;
            public static DAY_OF_YEAR: number;
            public static DECEMBER: number;
            public static DST_OFFSET: number;
            public static ERA: number;
            public static FEBRUARY: number;
            public static FIELD_COUNT: number;
            public static FRIDAY: number;
            public static HOUR: number;
            public static HOUR_OF_DAY: number;
            public static JANUARY: number;
            public static JULY: number;
            public static JUNE: number;
            public static LONG: number;
            public static MARCH: number;
            public static MAY: number;
            public static MILLISECOND: number;
            public static MINUTE: number;
            public static MONDAY: number;
            public static MONTH: number;
            public static NOVEMBER: number;
            public static OCTOBER: number;
            public static PM: number;
            public static SATURDAY: number;
            public static SECOND: number;
            public static SEPTEMBER: number;
            public static SHORT: number;
            public static SUNDAY: number;
            public static THURSDAY: number;
            public static TUESDAY: number;
            public static UNDECIMBER: number;
            public static WEDNESDAY: number;
            public static WEEK_OF_MONTH: number;
            public static WEEK_OF_YEAR: number;
            public static YEAR: number;
            public static ZONE_OFFSET: number;
            public areFieldsSet: boolean;
            public fields: native.Array<number>;
            public isTimeSet: boolean;
            public time: number;

            public getTimeInMillis(): number;

            public computeFields(): void;

            public getTimeZone(): java.util.TimeZone;

            public computeTime(): void;

            public equals(param0: java.lang.Object): boolean;

            public isSet(param0: number): boolean;

            public getDisplayName(param0: number, param1: number, param2: java.util.Locale): string;

            public getActualMinimum(param0: number): number;

            public getDisplayNames(param0: number, param1: number, param2: java.util.Locale): java.util.Map;

            public getLeastMaximum(param0: number): number;

            public clear(): void;

            public complete(): void;

            public roll(param0: number, param1: number): void;

            public setTimeInMillis(param0: number): void;

            public getActualMaximum(param0: number): number;

            public setMinimalDaysInFirstWeek(param0: number): void;

            public constructor();

            public isLenient(): boolean;

            public before(param0: java.lang.Object): boolean;

            public getMinimum(param0: number): number;

            public getTime(): java.util.Date;

            public setFirstDayOfWeek(param0: number): void;

            public clone(): java.lang.Object;

            public clear(param0: number): void;

            public set(param0: number, param1: number, param2: number, param3: number, param4: number): void;

            public getGreatestMinimum(param0: number): number;

            public add(param0: number, param1: number): void;

            public set(param0: number, param1: number): void;

            public getFirstDayOfWeek(): number;

            public set(param0: number, param1: number, param2: number): void;

            public compareTo(param0: java.util.Calendar): number;

            public internalGet(param0: number): number;

            public setLenient(param0: boolean): void;

            public static getInstance(param0: java.util.Locale): java.util.Calendar;

            public static getAvailableLocales(): native.Array<java.util.Locale>;

            public get(param0: number): number;

            public getMaximum(param0: number): number;

            public set(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number): void;

            public static getInstance(param0: java.util.TimeZone): java.util.Calendar;

            public roll(param0: number, param1: boolean): void;

            public static getInstance(param0: java.util.TimeZone, param1: java.util.Locale): java.util.Calendar;

            public setTime(param0: java.util.Date): void;

            public static getInstance(): java.util.Calendar;

            public after(param0: java.lang.Object): boolean;

            public getMinimalDaysInFirstWeek(): number;

            public toString(): string;

            public constructor(param0: java.util.TimeZone, param1: java.util.Locale);

            public setTimeZone(param0: java.util.TimeZone): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export class Collection extends java.lang.Object implements java.lang.Iterable {
            /**
             * Constructs a new instance of the java.util.Collection interface with the provided implementation.
             */
            public constructor(implementation: {
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                iterator(): java.util.Iterator;
            });

            public clear(): void;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public containsAll(param0: java.util.Collection): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public retainAll(param0: java.util.Collection): boolean;

            public contains(param0: java.lang.Object): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.ArrayList.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Deque.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.ListIterator.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Queue.d.ts" />
/// <reference path="./java.util.Random.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./java.util.SortedMap.d.ts" />
/// <reference path="./java.util.SortedSet.d.ts" />
declare module java {
    export module util {
        export class Collections extends java.lang.Object {
            public static EMPTY_LIST: java.util.List;
            public static EMPTY_MAP: java.util.Map;
            public static EMPTY_SET: java.util.Set;

            public static sort(param0: java.util.List, param1: java.util.Comparator): void;

            public static enumeration(param0: java.util.Collection): java.util.Enumeration;

            public static shuffle(param0: java.util.List, param1: java.util.Random): void;

            public static singletonMap(param0: java.lang.Object, param1: java.lang.Object): java.util.Map;

            public static fill(param0: java.util.List, param1: java.lang.Object): void;

            public static singletonList(param0: java.lang.Object): java.util.List;

            public static replaceAll(param0: java.util.List, param1: java.lang.Object, param2: java.lang.Object): boolean;

            public static unmodifiableSortedSet(param0: java.util.SortedSet): java.util.SortedSet;

            public static nCopies(param0: number, param1: java.lang.Object): java.util.List;

            public static emptyIterator(): java.util.Iterator;

            public static unmodifiableList(param0: java.util.List): java.util.List;

            public static unmodifiableSortedMap(param0: java.util.SortedMap): java.util.SortedMap;

            public static binarySearch(param0: java.util.List, param1: java.lang.Object, param2: java.util.Comparator): number;

            public static synchronizedMap(param0: java.util.Map): java.util.Map;

            public static emptySet(): java.util.Set;

            public static emptyMap(): java.util.Map;

            public static min(param0: java.util.Collection): java.lang.Object;

            public static unmodifiableCollection(param0: java.util.Collection): java.util.Collection;

            public static binarySearch(param0: java.util.List, param1: java.lang.Object): number;

            public static reverseOrder(param0: java.util.Comparator): java.util.Comparator;

            public static max(param0: java.util.Collection): java.lang.Object;

            public static synchronizedSortedSet(param0: java.util.SortedSet): java.util.SortedSet;

            public static synchronizedCollection(param0: java.util.Collection): java.util.Collection;

            public static checkedSortedMap(param0: java.util.SortedMap, param1: java.lang.Class, param2: java.lang.Class): java.util.SortedMap;

            public static unmodifiableSet(param0: java.util.Set): java.util.Set;

            public static synchronizedSortedMap(param0: java.util.SortedMap): java.util.SortedMap;

            public static min(param0: java.util.Collection, param1: java.util.Comparator): java.lang.Object;

            public static checkedCollection(param0: java.util.Collection, param1: java.lang.Class): java.util.Collection;

            public static checkedMap(param0: java.util.Map, param1: java.lang.Class, param2: java.lang.Class): java.util.Map;

            public static lastIndexOfSubList(param0: java.util.List, param1: java.util.List): number;

            public static addAll(param0: java.util.Collection, param1: native.Array<java.lang.Object>): boolean;

            public static emptyList(): java.util.List;

            public static frequency(param0: java.util.Collection, param1: java.lang.Object): number;

            public static emptyEnumeration(): java.util.Enumeration;

            public static shuffle(param0: java.util.List): void;

            public static asLifoQueue(param0: java.util.Deque): java.util.Queue;

            public static checkedList(param0: java.util.List, param1: java.lang.Class): java.util.List;

            public static max(param0: java.util.Collection, param1: java.util.Comparator): java.lang.Object;

            public static synchronizedSet(param0: java.util.Set): java.util.Set;

            public static reverse(param0: java.util.List): void;

            public static checkedSet(param0: java.util.Set, param1: java.lang.Class): java.util.Set;

            public static checkedSortedSet(param0: java.util.SortedSet, param1: java.lang.Class): java.util.SortedSet;

            public static list(param0: java.util.Enumeration): java.util.ArrayList;

            public static emptyListIterator(): java.util.ListIterator;

            public static newSetFromMap(param0: java.util.Map): java.util.Set;

            public static unmodifiableMap(param0: java.util.Map): java.util.Map;

            public static reverseOrder(): java.util.Comparator;

            public static indexOfSubList(param0: java.util.List, param1: java.util.List): number;

            public static swap(param0: java.util.List, param1: number, param2: number): void;

            public static sort(param0: java.util.List): void;

            public static singleton(param0: java.lang.Object): java.util.Set;

            public static copy(param0: java.util.List, param1: java.util.List): void;

            public static disjoint(param0: java.util.Collection, param1: java.util.Collection): boolean;

            public static rotate(param0: java.util.List, param1: number): void;

            public static synchronizedList(param0: java.util.List): java.util.List;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export class Comparator extends java.lang.Object {
            /**
             * Constructs a new instance of the java.util.Comparator interface with the provided implementation.
             */
            public constructor(implementation: {
                compare(param0: java.lang.Object, param1: java.lang.Object): number;
                equals(param0: java.lang.Object): boolean;
            });

            public equals(param0: java.lang.Object): boolean;

            public compare(param0: java.lang.Object, param1: java.lang.Object): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class ConcurrentModificationException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class Currency extends java.lang.Object implements java.io.Serializable {
            public getDefaultFractionDigits(): number;

            public static getInstance(param0: string): java.util.Currency;
            public static getInstance(param0: java.util.Locale): java.util.Currency;

            public getDisplayName(param0: java.util.Locale): string;

            public toString(): string;

            public static getAvailableCurrencies(): java.util.Set;

            public getCurrencyCode(): string;

            public getSymbol(): string;

            public getDisplayName(): string;

            public getSymbol(param0: java.util.Locale): string;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module util {
        export class Date extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable {
            public constructor(param0: number, param1: number, param2: number);

            public before(param0: java.util.Date): boolean;

            public getSeconds(): number;

            public getDate(): number;

            public setYear(param0: number): void;

            public toGMTString(): string;

            public equals(param0: java.lang.Object): boolean;

            public setDate(param0: number): void;

            public setSeconds(param0: number): void;

            public compareTo(param0: java.util.Date): number;

            public setMinutes(param0: number): void;

            public static parse(param0: string): number;

            public getDay(): number;

            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number);

            public getHours(): number;

            public getMinutes(): number;

            public constructor(param0: string);

            public setMonth(param0: number): void;

            public setHours(param0: number): void;

            public toLocaleString(): string;

            public constructor(param0: number);

            public after(param0: java.util.Date): boolean;

            public constructor();
            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number);

            public getYear(): number;

            public static UTC(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number): number;

            public getMonth(): number;

            public toString(): string;

            public setTime(param0: number): void;

            public getTime(): number;

            public getTimezoneOffset(): number;

            public clone(): java.lang.Object;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export class Deque extends java.lang.Object implements java.util.Queue {
            /**
             * Constructs a new instance of the java.util.Deque interface with the provided implementation.
             */
            public constructor(implementation: {
                addFirst(param0: java.lang.Object): void;
                addLast(param0: java.lang.Object): void;
                offerFirst(param0: java.lang.Object): boolean;
                offerLast(param0: java.lang.Object): boolean;
                removeFirst(): java.lang.Object;
                removeLast(): java.lang.Object;
                pollFirst(): java.lang.Object;
                pollLast(): java.lang.Object;
                getFirst(): java.lang.Object;
                getLast(): java.lang.Object;
                peekFirst(): java.lang.Object;
                peekLast(): java.lang.Object;
                removeFirstOccurrence(param0: java.lang.Object): boolean;
                removeLastOccurrence(param0: java.lang.Object): boolean;
                add(param0: java.lang.Object): boolean;
                offer(param0: java.lang.Object): boolean;
                remove(): java.lang.Object;
                poll(): java.lang.Object;
                element(): java.lang.Object;
                peek(): java.lang.Object;
                push(param0: java.lang.Object): void;
                pop(): java.lang.Object;
                remove(param0: java.lang.Object): boolean;
                contains(param0: java.lang.Object): boolean;
                size(): number;
                iterator(): java.util.Iterator;
                descendingIterator(): java.util.Iterator;
                add(param0: java.lang.Object): boolean;
                offer(param0: java.lang.Object): boolean;
                remove(): java.lang.Object;
                poll(): java.lang.Object;
                element(): java.lang.Object;
                peek(): java.lang.Object;
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                iterator(): java.util.Iterator;
            });

            public removeLast(): java.lang.Object;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public pollFirst(): java.lang.Object;

            public removeFirst(): java.lang.Object;

            public peekFirst(): java.lang.Object;

            public pollLast(): java.lang.Object;

            public addAll(param0: java.util.Collection): boolean;

            public remove(): java.lang.Object;

            public getFirst(): java.lang.Object;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public push(param0: java.lang.Object): void;

            public toArray(): native.Array<java.lang.Object>;

            public removeFirstOccurrence(param0: java.lang.Object): boolean;

            public offer(param0: java.lang.Object): boolean;

            public offerLast(param0: java.lang.Object): boolean;

            public getLast(): java.lang.Object;

            public peekLast(): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public addLast(param0: java.lang.Object): void;

            public offerFirst(param0: java.lang.Object): boolean;

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public size(): number;

            public isEmpty(): boolean;

            public poll(): java.lang.Object;

            public element(): java.lang.Object;

            public containsAll(param0: java.util.Collection): boolean;

            public removeLastOccurrence(param0: java.lang.Object): boolean;

            public retainAll(param0: java.util.Collection): boolean;

            public peek(): java.lang.Object;

            public descendingIterator(): java.util.Iterator;

            public addFirst(param0: java.lang.Object): void;

            public pop(): java.lang.Object;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
declare module java {
    export module util {
        export abstract class Dictionary extends java.lang.Object {
            public keys(): java.util.Enumeration;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public elements(): java.util.Enumeration;

            public get(param0: java.lang.Object): java.lang.Object;

            public constructor();
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class DuplicateFormatFlagsException extends java.util.IllegalFormatException {
            public getMessage(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);

            public getFlags(): string;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class EmptyStackException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class EnumMap extends java.util.AbstractMap implements java.io.Serializable, java.lang.Cloneable, java.util.Map {
            public constructor(param0: java.util.Map);

            public clear(): void;

            public constructor(param0: java.util.EnumMap);

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public clone(): java.util.EnumMap;

            public size(): number;

            public isEmpty(): boolean;

            public remove(param0: java.lang.Object): java.lang.Object;

            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public put(param0: java.lang.Enum, param1: java.lang.Object): java.lang.Object;

            public constructor(param0: java.lang.Class);

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public clone(): java.lang.Object;

            public containsKey(param0: java.lang.Object): boolean;

            public putAll(param0: java.util.Map): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export abstract class EnumSet extends java.util.AbstractSet implements java.lang.Cloneable, java.io.Serializable {
            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public clone(): java.util.EnumSet;

            public addAll(param0: java.util.Collection): boolean;

            public static copyOf(param0: java.util.EnumSet): java.util.EnumSet;

            public static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum, param3: java.lang.Enum, param4: java.lang.Enum): java.util.EnumSet;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public static of(param0: java.lang.Enum, param1: java.lang.Enum): java.util.EnumSet;

            public static noneOf(param0: java.lang.Class): java.util.EnumSet;

            public static range(param0: java.lang.Enum, param1: java.lang.Enum): java.util.EnumSet;

            public contains(param0: java.lang.Object): boolean;

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public static allOf(param0: java.lang.Class): java.util.EnumSet;

            public containsAll(param0: java.util.Collection): boolean;

            public static of(param0: java.lang.Enum): java.util.EnumSet;
            public static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum): java.util.EnumSet;
            public static of(param0: java.lang.Enum, param1: java.lang.Enum, param2: java.lang.Enum, param3: java.lang.Enum): java.util.EnumSet;

            public static complementOf(param0: java.util.EnumSet): java.util.EnumSet;

            public retainAll(param0: java.util.Collection): boolean;

            public clone(): java.lang.Object;

            public static copyOf(param0: java.util.Collection): java.util.EnumSet;

            public iterator(): java.util.Iterator;

            public static of(param0: java.lang.Enum, param1: native.Array<java.lang.Enum>): java.util.EnumSet;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export class Enumeration extends java.lang.Object {
            /**
             * Constructs a new instance of the java.util.Enumeration interface with the provided implementation.
             */
            public constructor(implementation: {
                hasMoreElements(): boolean;
                nextElement(): java.lang.Object;
            });

            public hasMoreElements(): boolean;

            public nextElement(): java.lang.Object;
        }
    }
}

declare module java {
    export module util {
        export class EventListener extends java.lang.Object {
            /**
             * Constructs a new instance of the java.util.EventListener interface with the provided implementation.
             */
            public constructor(implementation: {});
        }
    }
}

/// <reference path="./java.util.EventListener.d.ts" />
declare module java {
    export module util {
        export abstract class EventListenerProxy extends java.lang.Object implements java.util.EventListener {
            public getListener(): java.util.EventListener;

            public constructor(param0: java.util.EventListener);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export class EventObject extends java.lang.Object implements java.io.Serializable {
            public source: java.lang.Object;

            public toString(): string;

            public getSource(): java.lang.Object;

            public constructor(param0: java.lang.Object);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class FormatFlagsConversionMismatchException extends java.util.IllegalFormatException implements java.io.Serializable {
            public constructor(param0: string, param1: string);

            public getMessage(): string;

            public getConversion(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);

            public getFlags(): string;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.util.Formatter.d.ts" />
declare module java {
    export module util {
        export class Formattable extends java.lang.Object {
            /**
             * Constructs a new instance of the java.util.Formattable interface with the provided implementation.
             */
            public constructor(implementation: {
                formatTo(param0: java.util.Formatter, param1: number, param2: number, param3: number): void;
            });

            public formatTo(param0: java.util.Formatter, param1: number, param2: number, param3: number): void;
        }
    }
}

declare module java {
    export module util {
        export class FormattableFlags extends java.lang.Object {
            public static ALTERNATE: number;
            public static LEFT_JUSTIFY: number;
            public static UPPERCASE: number;
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.IOException.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.io.PrintStream.d.ts" />
/// <reference path="./java.lang.Appendable.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module util {
        export class Formatter extends java.lang.Object implements java.io.Closeable, java.io.Flushable {
            public constructor(param0: java.lang.Appendable);

            public flush(): void;

            public ioException(): java.io.IOException;

            public constructor(param0: java.io.PrintStream);
            public constructor(param0: java.io.OutputStream, param1: string);

            public format(param0: java.util.Locale, param1: string, param2: native.Array<java.lang.Object>): java.util.Formatter;

            public constructor();

            public format(param0: string, param1: native.Array<java.lang.Object>): java.util.Formatter;

            public constructor(param0: java.util.Locale);
            public constructor(param0: java.io.File, param1: string, param2: java.util.Locale);

            public out(): java.lang.Appendable;

            public constructor(param0: java.lang.Appendable, param1: java.util.Locale);
            public constructor(param0: string, param1: string);
            public constructor(param0: java.io.File, param1: string);

            public toString(): string;

            public constructor(param0: java.io.File);
            public constructor(param0: java.io.OutputStream);

            public locale(): java.util.Locale;

            public constructor(param0: string, param1: string, param2: java.util.Locale);

            public close(): void;

            public constructor(param0: string);
            public constructor(param0: java.io.OutputStream, param1: string, param2: java.util.Locale);
        }
        export module Formatter {
            export class BigDecimalLayoutForm extends java.lang.Enum {
                public static DECIMAL_FLOAT: java.util.Formatter.BigDecimalLayoutForm;
                public static SCIENTIFIC: java.util.Formatter.BigDecimalLayoutForm;

                public static valueOf(param0: string): java.util.Formatter.BigDecimalLayoutForm;
                public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;

                public static values(): native.Array<java.util.Formatter.BigDecimalLayoutForm>;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class FormatterClosedException extends java.lang.IllegalStateException implements java.io.Serializable {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
/// <reference path="./java.util.TimeZone.d.ts" />
declare module java {
    export module util {
        export class GregorianCalendar extends java.util.Calendar {
            public static AD: number;
            public static BC: number;

            public constructor(param0: number, param1: number, param2: number);

            public setGregorianChange(param0: java.util.Date): void;

            public getGregorianChange(): java.util.Date;

            public getGreatestMinimum(param0: number): number;

            public roll(param0: number, param1: number): void;

            public computeFields(): void;

            public getActualMaximum(param0: number): number;

            public isLeapYear(param0: number): boolean;

            public constructor();

            public computeTime(): void;

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number);
            public constructor(param0: java.util.Locale);

            public add(param0: number, param1: number): void;

            public getMinimum(param0: number): number;

            public constructor(param0: java.util.TimeZone, param1: java.util.Locale);
            public constructor(param0: number, param1: number, param2: number, param3: number, param4: number);
            public constructor(param0: java.util.TimeZone);

            public getActualMinimum(param0: number): number;

            public getMaximum(param0: number): number;

            public getLeastMaximum(param0: number): number;

            public roll(param0: number, param1: boolean): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class HashMap extends java.util.AbstractMap implements java.lang.Cloneable, java.io.Serializable {
            public constructor(param0: java.util.Map);

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public constructor(param0: number);
            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public clone(): java.lang.Object;

            public constructor(param0: number, param1: number);

            public containsKey(param0: java.lang.Object): boolean;

            public putAll(param0: java.util.Map): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export class HashSet extends java.util.AbstractSet implements java.util.Set, java.lang.Cloneable, java.io.Serializable {
            public clear(): void;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public constructor(param0: number);

            public containsAll(param0: java.util.Collection): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public constructor();

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public retainAll(param0: java.util.Collection): boolean;

            public constructor(param0: java.util.Collection);

            public clone(): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public constructor(param0: number, param1: number);

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class Hashtable extends java.util.Dictionary implements java.util.Map, java.lang.Cloneable, java.io.Serializable {
            public constructor(param0: java.util.Map);

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public elements(): java.util.Enumeration;

            public constructor(param0: number);
            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public keys(): java.util.Enumeration;

            public toString(): string;

            public get(param0: java.lang.Object): java.lang.Object;

            public rehash(): void;

            public entrySet(): java.util.Set;

            public clone(): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public constructor(param0: number, param1: number);

            public containsKey(param0: java.lang.Object): boolean;

            public putAll(param0: java.util.Map): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class IdentityHashMap extends java.util.AbstractMap implements java.util.Map, java.io.Serializable, java.lang.Cloneable {
            public constructor(param0: java.util.Map);

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public constructor(param0: number);
            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public clone(): java.lang.Object;

            public containsKey(param0: java.lang.Object): boolean;

            public putAll(param0: java.util.Map): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class IllegalFormatCodePointException extends java.util.IllegalFormatException implements java.io.Serializable {
            public getMessage(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);

            public getCodePoint(): number;

            public constructor(param0: number);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class IllegalFormatConversionException extends java.util.IllegalFormatException implements java.io.Serializable {
            public getMessage(): string;

            public getConversion(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Class);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);

            public getArgumentClass(): java.lang.Class;
        }
    }
}

declare module java {
    export module util {
        export class IllegalFormatException extends java.lang.IllegalArgumentException implements java.io.Serializable {
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class IllegalFormatFlagsException extends java.util.IllegalFormatException implements java.io.Serializable {
            public getMessage(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);

            public getFlags(): string;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class IllegalFormatPrecisionException extends java.util.IllegalFormatException {
            public getMessage(): string;

            public getPrecision(): number;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: number);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class IllegalFormatWidthException extends java.util.IllegalFormatException {
            public getMessage(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: number);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);

            public getWidth(): number;

            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class IllformedLocaleException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: number);

            public getErrorIndex(): number;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class InputMismatchException extends java.util.NoSuchElementException implements java.io.Serializable {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class InvalidPropertiesFormatException extends java.io.IOException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export class Iterator extends java.lang.Object {
            /**
             * Constructs a new instance of the java.util.Iterator interface with the provided implementation.
             */
            public constructor(implementation: {
                hasNext(): boolean;
                next(): java.lang.Object;
                remove(): void;
            });

            public next(): java.lang.Object;

            public hasNext(): boolean;

            public remove(): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class LinkedHashMap extends java.util.HashMap {
            public constructor(param0: java.util.Map);

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public constructor(param0: number);
            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public constructor(param0: number, param1: number, param2: boolean);

            public removeEldestEntry(param0: java.util.Map.Entry): boolean;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public constructor(param0: number, param1: number);

            public containsKey(param0: java.lang.Object): boolean;

            public hashCode(): number;

            public putAll(param0: java.util.Map): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export class LinkedHashSet extends java.util.HashSet implements java.util.Set, java.lang.Cloneable, java.io.Serializable {
            public clear(): void;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public constructor(param0: number);

            public containsAll(param0: java.util.Collection): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public constructor();

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public retainAll(param0: java.util.Collection): boolean;

            public constructor(param0: java.util.Collection);

            public contains(param0: java.lang.Object): boolean;

            public constructor(param0: number, param1: number);

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.ListIterator.d.ts" />
declare module java {
    export module util {
        export class LinkedList extends java.util.AbstractSequentialList implements java.util.List, java.util.Deque, java.util.Queue, java.lang.Cloneable, java.io.Serializable {
            public removeLast(): java.lang.Object;

            public remove(param0: java.lang.Object): boolean;

            public get(param0: number): java.lang.Object;

            public pollFirst(): java.lang.Object;

            public addAll(param0: java.util.Collection): boolean;

            public remove(): java.lang.Object;

            public add(param0: java.lang.Object): boolean;

            public getFirst(): java.lang.Object;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public removeFirstOccurrence(param0: java.lang.Object): boolean;

            public offer(param0: java.lang.Object): boolean;

            public indexOf(param0: java.lang.Object): number;

            public constructor(param0: java.util.Collection);

            public getLast(): java.lang.Object;

            public peekLast(): java.lang.Object;

            public addLast(param0: java.lang.Object): void;

            public clear(): void;

            public offerFirst(param0: java.lang.Object): boolean;

            public removeAll(param0: java.util.Collection): boolean;

            public element(): java.lang.Object;

            public containsAll(param0: java.util.Collection): boolean;

            public remove(param0: number): java.lang.Object;

            public constructor();

            public add(param0: number, param1: java.lang.Object): void;

            public listIterator(param0: number): java.util.ListIterator;

            public addFirst(param0: java.lang.Object): void;

            public clone(): java.lang.Object;

            public iterator(): java.util.Iterator;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public subList(param0: number, param1: number): java.util.List;

            public lastIndexOf(param0: java.lang.Object): number;

            public removeFirst(): java.lang.Object;

            public peekFirst(): java.lang.Object;

            public listIterator(): java.util.ListIterator;

            public pollLast(): java.lang.Object;

            public push(param0: java.lang.Object): void;

            public offerLast(param0: java.lang.Object): boolean;

            public addAll(param0: number, param1: java.util.Collection): boolean;

            public set(param0: number, param1: java.lang.Object): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public size(): number;

            public isEmpty(): boolean;

            public poll(): java.lang.Object;

            public removeLastOccurrence(param0: java.lang.Object): boolean;

            public retainAll(param0: java.util.Collection): boolean;

            public descendingIterator(): java.util.Iterator;

            public peek(): java.lang.Object;

            public pop(): java.lang.Object;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.ListIterator.d.ts" />
declare module java {
    export module util {
        export class List extends java.lang.Object implements java.util.Collection {
            /**
             * Constructs a new instance of the java.util.List interface with the provided implementation.
             */
            public constructor(implementation: {
                add(param0: number, param1: java.lang.Object): void;
                add(param0: java.lang.Object): boolean;
                addAll(param0: number, param1: java.util.Collection): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                get(param0: number): java.lang.Object;
                hashCode(): number;
                indexOf(param0: java.lang.Object): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                lastIndexOf(param0: java.lang.Object): number;
                listIterator(): java.util.ListIterator;
                listIterator(param0: number): java.util.ListIterator;
                remove(param0: number): java.lang.Object;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                set(param0: number, param1: java.lang.Object): java.lang.Object;
                size(): number;
                subList(param0: number, param1: number): java.util.List;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                iterator(): java.util.Iterator;
            });

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public subList(param0: number, param1: number): java.util.List;

            public get(param0: number): java.lang.Object;

            public lastIndexOf(param0: java.lang.Object): number;

            public addAll(param0: java.util.Collection): boolean;

            public listIterator(): java.util.ListIterator;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public addAll(param0: number, param1: java.util.Collection): boolean;

            public indexOf(param0: java.lang.Object): number;

            public set(param0: number, param1: java.lang.Object): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public containsAll(param0: java.util.Collection): boolean;

            public remove(param0: number): java.lang.Object;

            public add(param0: number, param1: java.lang.Object): void;

            public listIterator(param0: number): java.util.ListIterator;

            public retainAll(param0: java.util.Collection): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export class ListIterator extends java.lang.Object {
            /**
             * Constructs a new instance of the java.util.ListIterator interface with the provided implementation.
             */
            public constructor(implementation: {
                add(param0: java.lang.Object): void;
                hasNext(): boolean;
                hasPrevious(): boolean;
                next(): java.lang.Object;
                nextIndex(): number;
                previous(): java.lang.Object;
                previousIndex(): number;
                remove(): void;
                set(param0: java.lang.Object): void;
            });

            public next(): java.lang.Object;

            public set(param0: java.lang.Object): void;

            public previous(): java.lang.Object;

            public hasPrevious(): boolean;

            public previousIndex(): number;

            public add(param0: java.lang.Object): void;

            public hasNext(): boolean;

            public nextIndex(): number;

            public remove(): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export abstract class ListResourceBundle extends java.util.ResourceBundle {
            public handleKeySet(): java.util.Set;

            public getContents(): native.Array<native.Array<java.lang.Object>>;

            public handleGetObject(param0: string): java.lang.Object;

            public constructor();

            public getKeys(): java.util.Enumeration;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class Locale extends java.lang.Object implements java.lang.Cloneable, java.io.Serializable {
            public static CANADA: java.util.Locale;
            public static CANADA_FRENCH: java.util.Locale;
            public static CHINA: java.util.Locale;
            public static CHINESE: java.util.Locale;
            public static ENGLISH: java.util.Locale;
            public static FRANCE: java.util.Locale;
            public static FRENCH: java.util.Locale;
            public static GERMAN: java.util.Locale;
            public static GERMANY: java.util.Locale;
            public static ITALIAN: java.util.Locale;
            public static ITALY: java.util.Locale;
            public static JAPAN: java.util.Locale;
            public static JAPANESE: java.util.Locale;
            public static KOREA: java.util.Locale;
            public static KOREAN: java.util.Locale;
            public static PRC: java.util.Locale;
            public static PRIVATE_USE_EXTENSION: string;
            public static ROOT: java.util.Locale;
            public static SIMPLIFIED_CHINESE: java.util.Locale;
            public static TAIWAN: java.util.Locale;
            public static TRADITIONAL_CHINESE: java.util.Locale;
            public static UK: java.util.Locale;
            public static UNICODE_LOCALE_EXTENSION: string;
            public static US: java.util.Locale;

            public static setDefault(param0: java.util.Locale): void;

            public getCountry(): string;

            public getUnicodeLocaleAttributes(): java.util.Set;

            public constructor(param0: string, param1: string, param2: string);

            public equals(param0: java.lang.Object): boolean;

            public getDisplayCountry(param0: java.util.Locale): string;

            public getScript(): string;

            public getDisplayScript(param0: java.util.Locale): string;

            public constructor(param0: string, param1: string);

            public getDisplayVariant(param0: java.util.Locale): string;

            public static forLanguageTag(param0: string): java.util.Locale;

            public getISO3Country(): string;

            public static getAvailableLocales(): native.Array<java.util.Locale>;

            public getDisplayLanguage(param0: java.util.Locale): string;
            public getDisplayLanguage(): string;

            public constructor(param0: string);

            public getDisplayName(): string;

            public getDisplayScript(): string;

            public getLanguage(): string;

            public getUnicodeLocaleKeys(): java.util.Set;

            public toLanguageTag(): string;

            public static getISOLanguages(): native.Array<string>;

            public getExtension(param0: string): string;

            public getVariant(): string;

            public getUnicodeLocaleType(param0: string): string;

            public getDisplayName(param0: java.util.Locale): string;

            public toString(): string;

            public getDisplayCountry(): string;

            public getISO3Language(): string;

            public static getISOCountries(): native.Array<string>;

            public getExtensionKeys(): java.util.Set;

            public getDisplayVariant(): string;

            public clone(): java.lang.Object;

            public static getDefault(): java.util.Locale;

            public hashCode(): number;
        }
        export module Locale {
            export class Builder extends java.lang.Object {
                public setExtension(param0: string, param1: string): java.util.Locale.Builder;

                public clear(): java.util.Locale.Builder;

                public removeUnicodeLocaleAttribute(param0: string): java.util.Locale.Builder;

                public setVariant(param0: string): java.util.Locale.Builder;

                public setUnicodeLocaleKeyword(param0: string, param1: string): java.util.Locale.Builder;

                public setScript(param0: string): java.util.Locale.Builder;

                public constructor();

                public clearExtensions(): java.util.Locale.Builder;

                public setLanguageTag(param0: string): java.util.Locale.Builder;

                public setLanguage(param0: string): java.util.Locale.Builder;

                public setRegion(param0: string): java.util.Locale.Builder;

                public build(): java.util.Locale;

                public addUnicodeLocaleAttribute(param0: string): java.util.Locale.Builder;

                public setLocale(param0: java.util.Locale): java.util.Locale.Builder;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class Map extends java.lang.Object {
            /**
             * Constructs a new instance of the java.util.Map interface with the provided implementation.
             */
            public constructor(implementation: {
                clear(): void;
                containsKey(param0: java.lang.Object): boolean;
                containsValue(param0: java.lang.Object): boolean;
                entrySet(): java.util.Set;
                equals(param0: java.lang.Object): boolean;
                get(param0: java.lang.Object): java.lang.Object;
                hashCode(): number;
                isEmpty(): boolean;
                keySet(): java.util.Set;
                put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                putAll(param0: java.util.Map): void;
                remove(param0: java.lang.Object): java.lang.Object;
                size(): number;
                values(): java.util.Collection;
            });

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public containsKey(param0: java.lang.Object): boolean;

            public hashCode(): number;

            public putAll(param0: java.util.Map): void;
        }
        export module Map {
            export class Entry extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.Map$Entry interface with the provided implementation.
                 */
                public constructor(implementation: {
                    equals(param0: java.lang.Object): boolean;
                    getKey(): java.lang.Object;
                    getValue(): java.lang.Object;
                    hashCode(): number;
                    setValue(param0: java.lang.Object): java.lang.Object;
                });

                public getKey(): java.lang.Object;

                public equals(param0: java.lang.Object): boolean;

                public setValue(param0: java.lang.Object): java.lang.Object;

                public getValue(): java.lang.Object;

                public hashCode(): number;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class MissingFormatArgumentException extends java.util.IllegalFormatException {
            public getMessage(): string;

            public getFormatSpecifier(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class MissingFormatWidthException extends java.util.IllegalFormatException {
            public getMessage(): string;

            public getFormatSpecifier(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class MissingResourceException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);

            public getClassName(): string;

            public constructor(param0: string, param1: string, param2: string);

            public getKey(): string;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.NavigableSet.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./java.util.SortedMap.d.ts" />
declare module java {
    export module util {
        export class NavigableMap extends java.lang.Object implements java.util.SortedMap {
            /**
             * Constructs a new instance of the java.util.NavigableMap interface with the provided implementation.
             */
            public constructor(implementation: {
                lowerEntry(param0: java.lang.Object): java.util.Map.Entry;
                lowerKey(param0: java.lang.Object): java.lang.Object;
                floorEntry(param0: java.lang.Object): java.util.Map.Entry;
                floorKey(param0: java.lang.Object): java.lang.Object;
                ceilingEntry(param0: java.lang.Object): java.util.Map.Entry;
                ceilingKey(param0: java.lang.Object): java.lang.Object;
                higherEntry(param0: java.lang.Object): java.util.Map.Entry;
                higherKey(param0: java.lang.Object): java.lang.Object;
                firstEntry(): java.util.Map.Entry;
                lastEntry(): java.util.Map.Entry;
                pollFirstEntry(): java.util.Map.Entry;
                pollLastEntry(): java.util.Map.Entry;
                descendingMap(): java.util.NavigableMap;
                navigableKeySet(): java.util.NavigableSet;
                descendingKeySet(): java.util.NavigableSet;
                subMap(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableMap;
                headMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;
                tailMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;
                subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;
                headMap(param0: java.lang.Object): java.util.SortedMap;
                tailMap(param0: java.lang.Object): java.util.SortedMap;
                comparator(): java.util.Comparator;
                firstKey(): java.lang.Object;
                headMap(param0: java.lang.Object): java.util.SortedMap;
                lastKey(): java.lang.Object;
                subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;
                tailMap(param0: java.lang.Object): java.util.SortedMap;
                clear(): void;
                containsKey(param0: java.lang.Object): boolean;
                containsValue(param0: java.lang.Object): boolean;
                entrySet(): java.util.Set;
                equals(param0: java.lang.Object): boolean;
                get(param0: java.lang.Object): java.lang.Object;
                hashCode(): number;
                isEmpty(): boolean;
                keySet(): java.util.Set;
                put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                putAll(param0: java.util.Map): void;
                remove(param0: java.lang.Object): java.lang.Object;
                size(): number;
                values(): java.util.Collection;
            });

            public lowerKey(param0: java.lang.Object): java.lang.Object;

            public higherKey(param0: java.lang.Object): java.lang.Object;

            public ceilingKey(param0: java.lang.Object): java.lang.Object;

            public tailMap(param0: java.lang.Object): java.util.SortedMap;

            public firstEntry(): java.util.Map.Entry;

            public equals(param0: java.lang.Object): boolean;

            public values(): java.util.Collection;

            public pollLastEntry(): java.util.Map.Entry;

            public navigableKeySet(): java.util.NavigableSet;

            public tailMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;

            public descendingMap(): java.util.NavigableMap;

            public lowerEntry(param0: java.lang.Object): java.util.Map.Entry;

            public headMap(param0: java.lang.Object): java.util.SortedMap;

            public ceilingEntry(param0: java.lang.Object): java.util.Map.Entry;

            public higherEntry(param0: java.lang.Object): java.util.Map.Entry;

            public lastEntry(): java.util.Map.Entry;

            public clear(): void;

            public subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public lastKey(): java.lang.Object;

            public remove(param0: java.lang.Object): java.lang.Object;

            public containsValue(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public comparator(): java.util.Comparator;

            public floorKey(param0: java.lang.Object): java.lang.Object;

            public firstKey(): java.lang.Object;

            public subMap(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableMap;

            public get(param0: java.lang.Object): java.lang.Object;

            public pollFirstEntry(): java.util.Map.Entry;

            public descendingKeySet(): java.util.NavigableSet;

            public floorEntry(param0: java.lang.Object): java.util.Map.Entry;

            public entrySet(): java.util.Set;

            public headMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;

            public containsKey(param0: java.lang.Object): boolean;

            public hashCode(): number;

            public putAll(param0: java.util.Map): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.SortedSet.d.ts" />
declare module java {
    export module util {
        export class NavigableSet extends java.lang.Object implements java.util.SortedSet {
            /**
             * Constructs a new instance of the java.util.NavigableSet interface with the provided implementation.
             */
            public constructor(implementation: {
                lower(param0: java.lang.Object): java.lang.Object;
                floor(param0: java.lang.Object): java.lang.Object;
                ceiling(param0: java.lang.Object): java.lang.Object;
                higher(param0: java.lang.Object): java.lang.Object;
                pollFirst(): java.lang.Object;
                pollLast(): java.lang.Object;
                iterator(): java.util.Iterator;
                descendingSet(): java.util.NavigableSet;
                descendingIterator(): java.util.Iterator;
                subSet(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableSet;
                headSet(param0: java.lang.Object, param1: boolean): java.util.NavigableSet;
                tailSet(param0: java.lang.Object, param1: boolean): java.util.NavigableSet;
                subSet(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedSet;
                headSet(param0: java.lang.Object): java.util.SortedSet;
                tailSet(param0: java.lang.Object): java.util.SortedSet;
                comparator(): java.util.Comparator;
                first(): java.lang.Object;
                headSet(param0: java.lang.Object): java.util.SortedSet;
                last(): java.lang.Object;
                subSet(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedSet;
                tailSet(param0: java.lang.Object): java.util.SortedSet;
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                iterator(): java.util.Iterator;
            });

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public pollFirst(): java.lang.Object;

            public pollLast(): java.lang.Object;

            public addAll(param0: java.util.Collection): boolean;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public descendingSet(): java.util.NavigableSet;

            public toArray(): native.Array<java.lang.Object>;

            public subSet(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedSet;

            public contains(param0: java.lang.Object): boolean;

            public lower(param0: java.lang.Object): java.lang.Object;

            public tailSet(param0: java.lang.Object, param1: boolean): java.util.NavigableSet;

            public clear(): void;

            public first(): java.lang.Object;

            public removeAll(param0: java.util.Collection): boolean;

            public tailSet(param0: java.lang.Object): java.util.SortedSet;

            public isEmpty(): boolean;

            public size(): number;

            public containsAll(param0: java.util.Collection): boolean;

            public ceiling(param0: java.lang.Object): java.lang.Object;

            public headSet(param0: java.lang.Object, param1: boolean): java.util.NavigableSet;

            public floor(param0: java.lang.Object): java.lang.Object;

            public comparator(): java.util.Comparator;

            public subSet(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableSet;

            public headSet(param0: java.lang.Object): java.util.SortedSet;

            public retainAll(param0: java.util.Collection): boolean;

            public higher(param0: java.lang.Object): java.lang.Object;

            public last(): java.lang.Object;

            public descendingIterator(): java.util.Iterator;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class NoSuchElementException extends java.lang.RuntimeException {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
declare module java {
    export module util {
        export class Objects extends java.lang.Object {
            public static toString(param0: java.lang.Object): string;

            public static compare(param0: java.lang.Object, param1: java.lang.Object, param2: java.util.Comparator): number;

            public static requireNonNull(param0: java.lang.Object, param1: string): java.lang.Object;

            public toString(): string;

            public static hash(param0: native.Array<java.lang.Object>): number;

            public static toString(param0: java.lang.Object, param1: string): string;

            public static deepEquals(param0: java.lang.Object, param1: java.lang.Object): boolean;

            public static requireNonNull(param0: java.lang.Object): java.lang.Object;

            public static equals(param0: java.lang.Object, param1: java.lang.Object): boolean;
            public equals(param0: java.lang.Object): boolean;

            public static hashCode(param0: java.lang.Object): number;
            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Observer.d.ts" />
declare module java {
    export module util {
        export class Observable extends java.lang.Object {
            public addObserver(param0: java.util.Observer): void;

            public hasChanged(): boolean;

            public countObservers(): number;

            public notifyObservers(param0: java.lang.Object): void;

            public constructor();

            public clearChanged(): void;

            public deleteObservers(): void;

            public notifyObservers(): void;

            public setChanged(): void;

            public deleteObserver(param0: java.util.Observer): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Observable.d.ts" />
declare module java {
    export module util {
        export class Observer extends java.lang.Object {
            /**
             * Constructs a new instance of the java.util.Observer interface with the provided implementation.
             */
            public constructor(implementation: {
                update(param0: java.util.Observable, param1: java.lang.Object): void;
            });

            public update(param0: java.util.Observable, param1: java.lang.Object): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.SortedSet.d.ts" />
declare module java {
    export module util {
        export class PriorityQueue extends java.util.AbstractQueue implements java.io.Serializable {
            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public remove(): java.lang.Object;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: java.util.SortedSet);

            public toArray(): native.Array<java.lang.Object>;

            public offer(param0: java.lang.Object): boolean;

            public constructor(param0: java.util.PriorityQueue);
            public constructor(param0: java.util.Collection);

            public contains(param0: java.lang.Object): boolean;

            public constructor(param0: number, param1: java.util.Comparator);

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public size(): number;

            public isEmpty(): boolean;

            public poll(): java.lang.Object;

            public constructor(param0: number);

            public containsAll(param0: java.util.Collection): boolean;

            public element(): java.lang.Object;

            public constructor();

            public comparator(): java.util.Comparator;

            public retainAll(param0: java.util.Collection): boolean;

            public peek(): java.lang.Object;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.io.PrintStream.d.ts" />
/// <reference path="./java.io.PrintWriter.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.io.Writer.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class Properties extends java.util.Hashtable {
            public defaults: java.util.Properties;

            public constructor(param0: java.util.Map);
            public constructor(param0: java.util.Properties);

            public equals(param0: java.lang.Object): boolean;

            public values(): java.util.Collection;

            public save(param0: java.io.OutputStream, param1: string): void;

            public load(param0: java.io.Reader): void;

            public constructor(param0: number, param1: number);

            public stringPropertyNames(): java.util.Set;

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public getProperty(param0: string, param1: string): string;

            public isEmpty(): boolean;

            public size(): number;

            public store(param0: java.io.OutputStream, param1: string): void;

            public remove(param0: java.lang.Object): java.lang.Object;

            public store(param0: java.io.Writer, param1: string): void;

            public storeToXML(param0: java.io.OutputStream, param1: string, param2: string): void;

            public constructor(param0: number);

            public list(param0: java.io.PrintStream): void;

            public propertyNames(): java.util.Enumeration;

            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public getProperty(param0: string): string;

            public loadFromXML(param0: java.io.InputStream): void;

            public list(param0: java.io.PrintWriter): void;

            public storeToXML(param0: java.io.OutputStream, param1: string): void;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public setProperty(param0: string, param1: string): java.lang.Object;

            public load(param0: java.io.InputStream): void;

            public containsKey(param0: java.lang.Object): boolean;

            public hashCode(): number;

            public putAll(param0: java.util.Map): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module util {
        export class PropertyPermission extends java.security.BasicPermission {
            public constructor(param0: string, param1: string);

            public implies(param0: java.security.Permission): boolean;

            public getActions(): string;

            public checkGuard(param0: java.lang.Object): void;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.Reader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class PropertyResourceBundle extends java.util.ResourceBundle {
            public constructor(param0: java.io.Reader);

            public handleKeySet(): java.util.Set;

            public handleGetObject(param0: string): java.lang.Object;

            public constructor(param0: java.io.InputStream);
            public constructor();

            public getKeys(): java.util.Enumeration;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export class Queue extends java.lang.Object implements java.util.Collection {
            /**
             * Constructs a new instance of the java.util.Queue interface with the provided implementation.
             */
            public constructor(implementation: {
                add(param0: java.lang.Object): boolean;
                offer(param0: java.lang.Object): boolean;
                remove(): java.lang.Object;
                poll(): java.lang.Object;
                element(): java.lang.Object;
                peek(): java.lang.Object;
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                iterator(): java.util.Iterator;
            });

            public clear(): void;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public poll(): java.lang.Object;

            public element(): java.lang.Object;

            public containsAll(param0: java.util.Collection): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public remove(): java.lang.Object;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public retainAll(param0: java.util.Collection): boolean;

            public offer(param0: java.lang.Object): boolean;

            public peek(): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

declare module java {
    export module util {
        export class Random extends java.lang.Object implements java.io.Serializable {
            public nextDouble(): number;

            public nextFloat(): number;

            public nextInt(param0: number): number;

            public nextBoolean(): boolean;

            public nextBytes(param0: native.Array<number>): void;

            public setSeed(param0: number): void;

            public constructor(param0: number);

            public nextGaussian(): number;

            public nextInt(): number;

            public constructor();

            public next(param0: number): number;

            public nextLong(): number;
        }
    }
}

declare module java {
    export module util {
        export class RandomAccess extends java.lang.Object {
            /**
             * Constructs a new instance of the java.util.RandomAccess interface with the provided implementation.
             */
            public constructor(implementation: {});
        }
    }
}

/// <reference path="./java.lang.ClassLoader.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
/// <reference path="./java.util.ResourceBundle.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export abstract class ResourceBundle extends java.lang.Object {
            public parent: java.util.ResourceBundle;

            public handleKeySet(): java.util.Set;

            public static getBundle(param0: string, param1: java.util.ResourceBundle.Control): java.util.ResourceBundle;
            public static getBundle(param0: string, param1: java.util.Locale, param2: java.util.ResourceBundle.Control): java.util.ResourceBundle;
            public static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader, param3: java.util.ResourceBundle.Control): java.util.ResourceBundle;
            public static getBundle(param0: string, param1: java.util.Locale, param2: java.lang.ClassLoader): java.util.ResourceBundle;

            public getString(param0: string): string;

            public handleGetObject(param0: string): java.lang.Object;

            public constructor();

            public keySet(): java.util.Set;

            public setParent(param0: java.util.ResourceBundle): void;

            public static clearCache(param0: java.lang.ClassLoader): void;

            public getObject(param0: string): java.lang.Object;

            public static clearCache(): void;

            public static getBundle(param0: string): java.util.ResourceBundle;

            public getStringArray(param0: string): native.Array<string>;

            public getKeys(): java.util.Enumeration;

            public containsKey(param0: string): boolean;

            public static getBundle(param0: string, param1: java.util.Locale): java.util.ResourceBundle;

            public getLocale(): java.util.Locale;
        }
        export module ResourceBundle {
            export class Control extends java.lang.Object {
                public static FORMAT_CLASS: java.util.List;
                public static FORMAT_DEFAULT: java.util.List;
                public static FORMAT_PROPERTIES: java.util.List;
                public static TTL_DONT_CACHE: number;
                public static TTL_NO_EXPIRATION_CONTROL: number;

                public getTimeToLive(param0: string, param1: java.util.Locale): number;

                public static getControl(param0: java.util.List): java.util.ResourceBundle.Control;

                public newBundle(param0: string, param1: java.util.Locale, param2: string, param3: java.lang.ClassLoader, param4: boolean): java.util.ResourceBundle;

                public toResourceName(param0: string, param1: string): string;

                public getFallbackLocale(param0: string, param1: java.util.Locale): java.util.Locale;

                public static getNoFallbackControl(param0: java.util.List): java.util.ResourceBundle.Control;

                public needsReload(param0: string, param1: java.util.Locale, param2: string, param3: java.lang.ClassLoader, param4: java.util.ResourceBundle, param5: number): boolean;

                public toBundleName(param0: string, param1: java.util.Locale): string;

                public getFormats(param0: string): java.util.List;

                public getCandidateLocales(param0: string, param1: java.util.Locale): java.util.List;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.IOException.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.Readable.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.math.BigDecimal.d.ts" />
/// <reference path="./java.math.BigInteger.d.ts" />
/// <reference path="./java.nio.channels.ReadableByteChannel.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
/// <reference path="./java.util.regex.MatchResult.d.ts" />
/// <reference path="./java.util.regex.Pattern.d.ts" />
declare module java {
    export module util {
        export class Scanner extends java.lang.Object implements java.io.Closeable {
            public ioException(): java.io.IOException;

            public match(): java.util.regex.MatchResult;

            public hasNextBigInteger(): boolean;

            public next(): string;

            public useDelimiter(param0: java.util.regex.Pattern): java.util.Scanner;

            public constructor(param0: java.lang.Readable);

            public findWithinHorizon(param0: java.util.regex.Pattern, param1: number): string;

            public useLocale(param0: java.util.Locale): java.util.Scanner;

            public nextDouble(): number;

            public nextBigDecimal(): java.math.BigDecimal;

            public constructor(param0: java.io.File, param1: string);

            public findInLine(param0: java.util.regex.Pattern): string;

            public hasNextBigDecimal(): boolean;

            public hasNextByte(): boolean;

            public constructor(param0: java.io.File);

            public hasNextInt(): boolean;

            public constructor(param0: java.io.InputStream);

            public nextBigInteger(param0: number): java.math.BigInteger;

            public hasNext(param0: string): boolean;

            public constructor(param0: string);

            public hasNextByte(param0: number): boolean;

            public hasNextInt(param0: number): boolean;

            public nextInt(param0: number): number;

            public delimiter(): java.util.regex.Pattern;

            public hasNext(): boolean;

            public hasNextFloat(): boolean;

            public radix(): number;

            public nextLong(): number;

            public remove(): void;

            public hasNextDouble(): boolean;

            public hasNextLine(): boolean;

            public hasNextBoolean(): boolean;

            public nextInt(): number;

            public skip(param0: java.util.regex.Pattern): java.util.Scanner;

            public next(param0: java.util.regex.Pattern): string;

            public nextByte(param0: number): number;

            public next(param0: string): string;

            public constructor(param0: java.nio.channels.ReadableByteChannel);

            public findWithinHorizon(param0: string, param1: number): string;

            public hasNextBigInteger(param0: number): boolean;

            public findInLine(param0: string): string;

            public skip(param0: string): java.util.Scanner;

            public hasNextShort(param0: number): boolean;

            public close(): void;

            public reset(): java.util.Scanner;

            public nextBoolean(): boolean;

            public nextBigInteger(): java.math.BigInteger;

            public nextByte(): number;

            public useRadix(param0: number): java.util.Scanner;

            public hasNextLong(param0: number): boolean;

            public nextLine(): string;

            public nextFloat(): number;

            public hasNext(param0: java.util.regex.Pattern): boolean;

            public hasNextLong(): boolean;

            public toString(): string;

            public constructor(param0: java.io.InputStream, param1: string);

            public nextLong(param0: number): number;

            public useDelimiter(param0: string): java.util.Scanner;

            public nextShort(param0: number): number;

            public constructor(param0: java.nio.channels.ReadableByteChannel, param1: string);

            public hasNextShort(): boolean;

            public locale(): java.util.Locale;

            public nextShort(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class ServiceConfigurationError extends java.lang.Error {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.ClassLoader.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export class ServiceLoader extends java.lang.Object implements java.lang.Iterable {
            public static load(param0: java.lang.Class, param1: java.lang.ClassLoader): java.util.ServiceLoader;
            public static load(param0: java.lang.Class): java.util.ServiceLoader;

            public toString(): string;

            public reload(): void;

            public iterator(): java.util.Iterator;

            public static loadInstalled(param0: java.lang.Class): java.util.ServiceLoader;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export class Set extends java.lang.Object implements java.util.Collection {
            /**
             * Constructs a new instance of the java.util.Set interface with the provided implementation.
             */
            public constructor(implementation: {
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                iterator(): java.util.Iterator;
            });

            public clear(): void;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public containsAll(param0: java.util.Collection): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public retainAll(param0: java.util.Collection): boolean;

            public contains(param0: java.lang.Object): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.TimeZone.d.ts" />
declare module java {
    export module util {
        export class SimpleTimeZone extends java.util.TimeZone {
            public static STANDARD_TIME: number;
            public static UTC_TIME: number;
            public static WALL_TIME: number;

            public constructor(param0: number, param1: string, param2: number, param3: number, param4: number, param5: number, param6: number, param7: number, param8: number, param9: number, param10: number, param11: number, param12: number);
            public constructor(param0: number, param1: string, param2: number, param3: number, param4: number, param5: number, param6: number, param7: number, param8: number, param9: number);

            public getDSTSavings(): number;

            public getOffset(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number): number;

            public setEndRule(param0: number, param1: number, param2: number, param3: number): void;

            public useDaylightTime(): boolean;

            public constructor(param0: number, param1: string);

            public equals(param0: java.lang.Object): boolean;

            public setStartRule(param0: number, param1: number, param2: number, param3: number, param4: boolean): void;

            public getOffset(param0: number): number;

            public setEndRule(param0: number, param1: number, param2: number): void;

            public getRawOffset(): number;

            public setDSTSavings(param0: number): void;

            public hasSameRules(param0: java.util.TimeZone): boolean;

            public setEndRule(param0: number, param1: number, param2: number, param3: number, param4: boolean): void;

            public setRawOffset(param0: number): void;

            public constructor();

            public setStartRule(param0: number, param1: number, param2: number): void;

            public toString(): string;

            public constructor(param0: number, param1: string, param2: number, param3: number, param4: number, param5: number, param6: number, param7: number, param8: number, param9: number, param10: number);

            public inDaylightTime(param0: java.util.Date): boolean;

            public clone(): java.lang.Object;

            public setStartRule(param0: number, param1: number, param2: number, param3: number): void;

            public hashCode(): number;

            public setStartYear(param0: number): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class SortedMap extends java.lang.Object implements java.util.Map {
            /**
             * Constructs a new instance of the java.util.SortedMap interface with the provided implementation.
             */
            public constructor(implementation: {
                comparator(): java.util.Comparator;
                firstKey(): java.lang.Object;
                headMap(param0: java.lang.Object): java.util.SortedMap;
                lastKey(): java.lang.Object;
                subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;
                tailMap(param0: java.lang.Object): java.util.SortedMap;
                clear(): void;
                containsKey(param0: java.lang.Object): boolean;
                containsValue(param0: java.lang.Object): boolean;
                entrySet(): java.util.Set;
                equals(param0: java.lang.Object): boolean;
                get(param0: java.lang.Object): java.lang.Object;
                hashCode(): number;
                isEmpty(): boolean;
                keySet(): java.util.Set;
                put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                putAll(param0: java.util.Map): void;
                remove(param0: java.lang.Object): java.lang.Object;
                size(): number;
                values(): java.util.Collection;
            });

            public clear(): void;

            public subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public lastKey(): java.lang.Object;

            public remove(param0: java.lang.Object): java.lang.Object;

            public tailMap(param0: java.lang.Object): java.util.SortedMap;

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public comparator(): java.util.Comparator;

            public firstKey(): java.lang.Object;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public headMap(param0: java.lang.Object): java.util.SortedMap;

            public containsKey(param0: java.lang.Object): boolean;

            public hashCode(): number;

            public putAll(param0: java.util.Map): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export class SortedSet extends java.lang.Object implements java.util.Set {
            /**
             * Constructs a new instance of the java.util.SortedSet interface with the provided implementation.
             */
            public constructor(implementation: {
                comparator(): java.util.Comparator;
                first(): java.lang.Object;
                headSet(param0: java.lang.Object): java.util.SortedSet;
                last(): java.lang.Object;
                subSet(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedSet;
                tailSet(param0: java.lang.Object): java.util.SortedSet;
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                add(param0: java.lang.Object): boolean;
                addAll(param0: java.util.Collection): boolean;
                clear(): void;
                contains(param0: java.lang.Object): boolean;
                containsAll(param0: java.util.Collection): boolean;
                equals(param0: java.lang.Object): boolean;
                hashCode(): number;
                isEmpty(): boolean;
                iterator(): java.util.Iterator;
                remove(param0: java.lang.Object): boolean;
                removeAll(param0: java.util.Collection): boolean;
                retainAll(param0: java.util.Collection): boolean;
                size(): number;
                toArray(): native.Array<java.lang.Object>;
                toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                iterator(): java.util.Iterator;
            });

            public clear(): void;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public first(): java.lang.Object;

            public remove(param0: java.lang.Object): boolean;

            public removeAll(param0: java.util.Collection): boolean;

            public tailSet(param0: java.lang.Object): java.util.SortedSet;

            public isEmpty(): boolean;

            public size(): number;

            public containsAll(param0: java.util.Collection): boolean;

            public addAll(param0: java.util.Collection): boolean;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public subSet(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedSet;

            public comparator(): java.util.Comparator;

            public headSet(param0: java.lang.Object): java.util.SortedSet;

            public retainAll(param0: java.util.Collection): boolean;

            public last(): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.ListIterator.d.ts" />
declare module java {
    export module util {
        export class Stack extends java.util.Vector {
            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public subList(param0: number, param1: number): java.util.List;

            public get(param0: number): java.lang.Object;

            public lastIndexOf(param0: java.lang.Object): number;

            public addAll(param0: java.util.Collection): boolean;

            public listIterator(): java.util.ListIterator;

            public empty(): boolean;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public toArray(): native.Array<java.lang.Object>;

            public search(param0: java.lang.Object): number;

            public addAll(param0: number, param1: java.util.Collection): boolean;

            public indexOf(param0: java.lang.Object): number;

            public set(param0: number, param1: java.lang.Object): java.lang.Object;

            public constructor(param0: java.util.Collection);

            public contains(param0: java.lang.Object): boolean;

            public constructor(param0: number, param1: number);

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public constructor(param0: number);

            public containsAll(param0: java.util.Collection): boolean;

            public remove(param0: number): java.lang.Object;

            public constructor();

            public add(param0: number, param1: java.lang.Object): void;

            public lastIndexOf(param0: java.lang.Object, param1: number): number;

            public listIterator(param0: number): java.util.ListIterator;

            public retainAll(param0: java.util.Collection): boolean;

            public indexOf(param0: java.lang.Object, param1: number): number;

            public peek(): java.lang.Object;

            public push(param0: java.lang.Object): java.lang.Object;

            public pop(): java.lang.Object;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module util {
        export class StringTokenizer extends java.lang.Object implements java.util.Enumeration {
            public constructor(param0: string, param1: string);

            public nextToken(): string;

            public hasMoreElements(): boolean;

            public hasMoreTokens(): boolean;

            public nextElement(): java.lang.Object;

            public nextToken(param0: string): string;

            public constructor(param0: string, param1: string, param2: boolean);

            public countTokens(): number;

            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.Locale.d.ts" />
declare module java {
    export module util {
        export abstract class TimeZone extends java.lang.Object implements java.io.Serializable, java.lang.Cloneable {
            public static LONG: number;
            public static SHORT: number;

            public static setDefault(param0: java.util.TimeZone): void;

            public getDisplayName(param0: boolean, param1: number): string;

            public setID(param0: string): void;

            public getDSTSavings(): number;

            public getOffset(param0: number, param1: number, param2: number, param3: number, param4: number, param5: number): number;

            public useDaylightTime(): boolean;

            public static getAvailableIDs(param0: number): native.Array<string>;

            public setRawOffset(param0: number): void;

            public constructor();

            public getOffset(param0: number): number;

            public static getTimeZone(param0: string): java.util.TimeZone;

            public static getAvailableIDs(): native.Array<string>;

            public getDisplayName(param0: java.util.Locale): string;

            public getRawOffset(): number;

            public static getDefault(): java.util.TimeZone;

            public getDisplayName(param0: boolean, param1: number, param2: java.util.Locale): string;

            public inDaylightTime(param0: java.util.Date): boolean;

            public getID(): string;

            public clone(): java.lang.Object;

            public getDisplayName(): string;

            public hasSameRules(param0: java.util.TimeZone): boolean;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.TimerTask.d.ts" />
declare module java {
    export module util {
        export class Timer extends java.lang.Object {
            public schedule(param0: java.util.TimerTask, param1: number, param2: number): void;

            public constructor(param0: boolean);

            public schedule(param0: java.util.TimerTask, param1: java.util.Date): void;
            public schedule(param0: java.util.TimerTask, param1: java.util.Date, param2: number): void;

            public scheduleAtFixedRate(param0: java.util.TimerTask, param1: java.util.Date, param2: number): void;

            public constructor(param0: string, param1: boolean);

            public scheduleAtFixedRate(param0: java.util.TimerTask, param1: number, param2: number): void;

            public cancel(): void;

            public constructor();

            public purge(): number;

            public schedule(param0: java.util.TimerTask, param1: number): void;

            public constructor(param0: string);
        }
    }
}

declare module java {
    export module util {
        export abstract class TimerTask extends java.lang.Object implements java.lang.Runnable {
            public cancel(): boolean;

            public scheduledExecutionTime(): number;

            public run(): void;

            public constructor();
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class TooManyListenersException extends java.lang.Exception {
            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.NavigableMap.d.ts" />
/// <reference path="./java.util.NavigableSet.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./java.util.SortedMap.d.ts" />
declare module java {
    export module util {
        export class TreeMap extends java.util.AbstractMap implements java.util.SortedMap, java.util.NavigableMap, java.lang.Cloneable, java.io.Serializable {
            public constructor(param0: java.util.Map);

            public lowerKey(param0: java.lang.Object): java.lang.Object;

            public constructor(param0: java.util.SortedMap);

            public higherKey(param0: java.lang.Object): java.lang.Object;

            public ceilingKey(param0: java.lang.Object): java.lang.Object;

            public tailMap(param0: java.lang.Object): java.util.SortedMap;

            public firstEntry(): java.util.Map.Entry;

            public equals(param0: java.lang.Object): boolean;

            public values(): java.util.Collection;

            public pollLastEntry(): java.util.Map.Entry;

            public navigableKeySet(): java.util.NavigableSet;

            public tailMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;

            public descendingMap(): java.util.NavigableMap;

            public lowerEntry(param0: java.lang.Object): java.util.Map.Entry;

            public headMap(param0: java.lang.Object): java.util.SortedMap;

            public constructor(param0: java.util.Comparator);

            public ceilingEntry(param0: java.lang.Object): java.util.Map.Entry;

            public higherEntry(param0: java.lang.Object): java.util.Map.Entry;

            public lastEntry(): java.util.Map.Entry;

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;

            public size(): number;

            public isEmpty(): boolean;

            public remove(param0: java.lang.Object): java.lang.Object;

            public lastKey(): java.lang.Object;

            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public comparator(): java.util.Comparator;

            public firstKey(): java.lang.Object;

            public floorKey(param0: java.lang.Object): java.lang.Object;

            public subMap(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableMap;

            public get(param0: java.lang.Object): java.lang.Object;

            public pollFirstEntry(): java.util.Map.Entry;

            public descendingKeySet(): java.util.NavigableSet;

            public floorEntry(param0: java.lang.Object): java.util.Map.Entry;

            public entrySet(): java.util.Set;

            public headMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;

            public clone(): java.lang.Object;

            public containsKey(param0: java.lang.Object): boolean;

            public hashCode(): number;

            public putAll(param0: java.util.Map): void;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.NavigableSet.d.ts" />
/// <reference path="./java.util.SortedSet.d.ts" />
declare module java {
    export module util {
        export class TreeSet extends java.util.AbstractSet implements java.util.NavigableSet, java.lang.Cloneable, java.io.Serializable {
            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public pollFirst(): java.lang.Object;

            public addAll(param0: java.util.Collection): boolean;

            public pollLast(): java.lang.Object;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public constructor(param0: java.util.SortedSet);

            public descendingSet(): java.util.NavigableSet;

            public toArray(): native.Array<java.lang.Object>;

            public subSet(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedSet;

            public constructor(param0: java.util.Collection);
            public constructor(param0: java.util.Comparator);

            public contains(param0: java.lang.Object): boolean;

            public lower(param0: java.lang.Object): java.lang.Object;

            public tailSet(param0: java.lang.Object, param1: boolean): java.util.NavigableSet;

            public clear(): void;

            public first(): java.lang.Object;

            public removeAll(param0: java.util.Collection): boolean;

            public isEmpty(): boolean;

            public size(): number;

            public tailSet(param0: java.lang.Object): java.util.SortedSet;

            public containsAll(param0: java.util.Collection): boolean;

            public constructor();

            public ceiling(param0: java.lang.Object): java.lang.Object;

            public headSet(param0: java.lang.Object, param1: boolean): java.util.NavigableSet;

            public comparator(): java.util.Comparator;

            public floor(param0: java.lang.Object): java.lang.Object;

            public subSet(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableSet;

            public headSet(param0: java.lang.Object): java.util.SortedSet;

            public retainAll(param0: java.util.Collection): boolean;

            public higher(param0: java.lang.Object): java.lang.Object;

            public last(): java.lang.Object;

            public descendingIterator(): java.util.Iterator;

            public clone(): java.lang.Object;

            public iterator(): java.util.Iterator;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module util {
        export class UUID extends java.lang.Object implements java.io.Serializable {
            public clockSequence(): number;

            public version(): number;

            public node(): number;

            public static nameUUIDFromBytes(param0: native.Array<number>): java.util.UUID;

            public getMostSignificantBits(): number;

            public static randomUUID(): java.util.UUID;

            public equals(param0: java.lang.Object): boolean;

            public toString(): string;

            public timestamp(): number;

            public variant(): number;

            public getLeastSignificantBits(): number;

            public compareTo(param0: java.util.UUID): number;

            public constructor(param0: number, param1: number);

            public static fromString(param0: string): java.util.UUID;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class UnknownFormatConversionException extends java.util.IllegalFormatException {
            public getMessage(): string;

            public getConversion(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export class UnknownFormatFlagsException extends java.util.IllegalFormatException {
            public getMessage(): string;

            public constructor(param0: java.lang.Throwable);
            public constructor(param0: string, param1: java.lang.Throwable);

            public getFlags(): string;

            public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            public constructor();
            public constructor(param0: string);
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.ListIterator.d.ts" />
declare module java {
    export module util {
        export class Vector extends java.util.AbstractList implements java.util.List, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable {
            public capacityIncrement: number;
            public elementCount: number;
            public elementData: native.Array<java.lang.Object>;

            public remove(param0: java.lang.Object): boolean;

            public get(param0: number): java.lang.Object;

            public addAll(param0: java.util.Collection): boolean;

            public add(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public removeElementAt(param0: number): void;

            public toArray(): native.Array<java.lang.Object>;

            public elementAt(param0: number): java.lang.Object;

            public removeAllElements(): void;

            public lastElement(): java.lang.Object;

            public removeRange(param0: number, param1: number): void;

            public indexOf(param0: java.lang.Object): number;

            public constructor(param0: java.util.Collection);

            public clear(): void;

            public removeAll(param0: java.util.Collection): boolean;

            public elements(): java.util.Enumeration;

            public constructor(param0: number);

            public containsAll(param0: java.util.Collection): boolean;

            public remove(param0: number): java.lang.Object;

            public constructor();

            public add(param0: number, param1: java.lang.Object): void;

            public listIterator(param0: number): java.util.ListIterator;

            public setElementAt(param0: java.lang.Object, param1: number): void;

            public clone(): java.lang.Object;

            public iterator(): java.util.Iterator;

            public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

            public subList(param0: number, param1: number): java.util.List;

            public lastIndexOf(param0: java.lang.Object): number;

            public listIterator(): java.util.ListIterator;

            public ensureCapacity(param0: number): void;

            public removeElement(param0: java.lang.Object): boolean;

            public copyInto(param0: native.Array<java.lang.Object>): void;

            public setSize(param0: number): void;

            public addElement(param0: java.lang.Object): void;

            public addAll(param0: number, param1: java.util.Collection): boolean;

            public set(param0: number, param1: java.lang.Object): java.lang.Object;

            public contains(param0: java.lang.Object): boolean;

            public constructor(param0: number, param1: number);

            public firstElement(): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public insertElementAt(param0: java.lang.Object, param1: number): void;

            public lastIndexOf(param0: java.lang.Object, param1: number): number;

            public toString(): string;

            public retainAll(param0: java.util.Collection): boolean;

            public capacity(): number;

            public indexOf(param0: java.lang.Object, param1: number): number;

            public trimToSize(): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export class WeakHashMap extends java.util.AbstractMap implements java.util.Map {
            public constructor(param0: java.util.Map);

            public clear(): void;

            public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

            public isEmpty(): boolean;

            public size(): number;

            public remove(param0: java.lang.Object): java.lang.Object;

            public constructor(param0: number);
            public constructor();

            public containsValue(param0: java.lang.Object): boolean;

            public equals(param0: java.lang.Object): boolean;

            public keySet(): java.util.Set;

            public values(): java.util.Collection;

            public get(param0: java.lang.Object): java.lang.Object;

            public entrySet(): java.util.Set;

            public constructor(param0: number, param1: number);

            public containsKey(param0: java.lang.Object): boolean;

            public putAll(param0: java.util.Map): void;

            public hashCode(): number;
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.Future.d.ts" />
/// <reference path="./java.util.concurrent.RunnableFuture.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export abstract class AbstractExecutorService extends java.lang.Object implements java.util.concurrent.ExecutorService {
                public invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;

                public isTerminated(): boolean;

                public newTaskFor(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.RunnableFuture;
                public newTaskFor(param0: java.util.concurrent.Callable): java.util.concurrent.RunnableFuture;

                public submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                public submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;

                public invokeAny(param0: java.util.Collection): java.lang.Object;

                public constructor();

                public invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.lang.Object;

                public submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;

                public awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                public shutdown(): void;

                public execute(param0: java.lang.Runnable): void;

                public isShutdown(): boolean;

                public invokeAll(param0: java.util.Collection): java.util.List;

                public shutdownNow(): java.util.List;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ArrayBlockingQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue, java.io.Serializable {
                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public toArray(): native.Array<java.lang.Object>;

                public put(param0: java.lang.Object): void;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public take(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public element(): java.lang.Object;

                public iterator(): java.util.Iterator;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public constructor(param0: number, param1: boolean);

                public toString(): string;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public peek(): java.lang.Object;

                public constructor(param0: number, param1: boolean, param2: java.util.Collection);

                public addAll(param0: java.util.Collection): boolean;

                public remainingCapacity(): number;

                public constructor(param0: number);

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class BlockingDeque extends java.lang.Object implements java.util.concurrent.BlockingQueue, java.util.Deque {
                /**
                 * Constructs a new instance of the java.util.concurrent.BlockingDeque interface with the provided implementation.
                 */
                public constructor(implementation: {
                    addFirst(param0: java.lang.Object): void;
                    addLast(param0: java.lang.Object): void;
                    offerFirst(param0: java.lang.Object): boolean;
                    offerLast(param0: java.lang.Object): boolean;
                    putFirst(param0: java.lang.Object): void;
                    putLast(param0: java.lang.Object): void;
                    offerFirst(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                    offerLast(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                    takeFirst(): java.lang.Object;
                    takeLast(): java.lang.Object;
                    pollFirst(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                    pollLast(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                    removeFirstOccurrence(param0: java.lang.Object): boolean;
                    removeLastOccurrence(param0: java.lang.Object): boolean;
                    add(param0: java.lang.Object): boolean;
                    offer(param0: java.lang.Object): boolean;
                    put(param0: java.lang.Object): void;
                    offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                    remove(): java.lang.Object;
                    poll(): java.lang.Object;
                    take(): java.lang.Object;
                    poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                    element(): java.lang.Object;
                    peek(): java.lang.Object;
                    remove(param0: java.lang.Object): boolean;
                    contains(param0: java.lang.Object): boolean;
                    size(): number;
                    iterator(): java.util.Iterator;
                    push(param0: java.lang.Object): void;
                    add(param0: java.lang.Object): boolean;
                    offer(param0: java.lang.Object): boolean;
                    put(param0: java.lang.Object): void;
                    offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                    take(): java.lang.Object;
                    poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                    remainingCapacity(): number;
                    remove(param0: java.lang.Object): boolean;
                    contains(param0: java.lang.Object): boolean;
                    drainTo(param0: java.util.Collection): number;
                    drainTo(param0: java.util.Collection, param1: number): number;
                    addFirst(param0: java.lang.Object): void;
                    addLast(param0: java.lang.Object): void;
                    offerFirst(param0: java.lang.Object): boolean;
                    offerLast(param0: java.lang.Object): boolean;
                    removeFirst(): java.lang.Object;
                    removeLast(): java.lang.Object;
                    pollFirst(): java.lang.Object;
                    pollLast(): java.lang.Object;
                    getFirst(): java.lang.Object;
                    getLast(): java.lang.Object;
                    peekFirst(): java.lang.Object;
                    peekLast(): java.lang.Object;
                    removeFirstOccurrence(param0: java.lang.Object): boolean;
                    removeLastOccurrence(param0: java.lang.Object): boolean;
                    add(param0: java.lang.Object): boolean;
                    offer(param0: java.lang.Object): boolean;
                    remove(): java.lang.Object;
                    poll(): java.lang.Object;
                    element(): java.lang.Object;
                    peek(): java.lang.Object;
                    push(param0: java.lang.Object): void;
                    pop(): java.lang.Object;
                    remove(param0: java.lang.Object): boolean;
                    contains(param0: java.lang.Object): boolean;
                    size(): number;
                    iterator(): java.util.Iterator;
                    descendingIterator(): java.util.Iterator;
                    add(param0: java.lang.Object): boolean;
                    offer(param0: java.lang.Object): boolean;
                    remove(): java.lang.Object;
                    poll(): java.lang.Object;
                    element(): java.lang.Object;
                    peek(): java.lang.Object;
                    add(param0: java.lang.Object): boolean;
                    offer(param0: java.lang.Object): boolean;
                    remove(): java.lang.Object;
                    poll(): java.lang.Object;
                    element(): java.lang.Object;
                    peek(): java.lang.Object;
                    add(param0: java.lang.Object): boolean;
                    addAll(param0: java.util.Collection): boolean;
                    clear(): void;
                    contains(param0: java.lang.Object): boolean;
                    containsAll(param0: java.util.Collection): boolean;
                    equals(param0: java.lang.Object): boolean;
                    hashCode(): number;
                    isEmpty(): boolean;
                    iterator(): java.util.Iterator;
                    remove(param0: java.lang.Object): boolean;
                    removeAll(param0: java.util.Collection): boolean;
                    retainAll(param0: java.util.Collection): boolean;
                    size(): number;
                    toArray(): native.Array<java.lang.Object>;
                    toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                    add(param0: java.lang.Object): boolean;
                    addAll(param0: java.util.Collection): boolean;
                    clear(): void;
                    contains(param0: java.lang.Object): boolean;
                    containsAll(param0: java.util.Collection): boolean;
                    equals(param0: java.lang.Object): boolean;
                    hashCode(): number;
                    isEmpty(): boolean;
                    iterator(): java.util.Iterator;
                    remove(param0: java.lang.Object): boolean;
                    removeAll(param0: java.util.Collection): boolean;
                    retainAll(param0: java.util.Collection): boolean;
                    size(): number;
                    toArray(): native.Array<java.lang.Object>;
                    toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                    iterator(): java.util.Iterator;
                    iterator(): java.util.Iterator;
                });

                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public retainAll(param0: java.util.Collection): boolean;

                public toArray(): native.Array<java.lang.Object>;

                public removeLastOccurrence(param0: java.lang.Object): boolean;

                public push(param0: java.lang.Object): void;

                public hashCode(): number;

                public removeLast(): java.lang.Object;

                public pollLast(): java.lang.Object;

                public removeFirstOccurrence(param0: java.lang.Object): boolean;

                public pop(): java.lang.Object;

                public contains(param0: java.lang.Object): boolean;

                public offerLast(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public pollFirst(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public element(): java.lang.Object;

                public offerLast(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public takeFirst(): java.lang.Object;

                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public pollFirst(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public pollLast(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public addFirst(param0: java.lang.Object): void;

                public remainingCapacity(): number;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public putLast(param0: java.lang.Object): void;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public offerFirst(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public put(param0: java.lang.Object): void;

                public getFirst(): java.lang.Object;

                public putFirst(param0: java.lang.Object): void;

                public removeFirst(): java.lang.Object;

                public peekFirst(): java.lang.Object;

                public clear(): void;

                public offer(param0: java.lang.Object): boolean;

                public takeLast(): java.lang.Object;

                public take(): java.lang.Object;

                public offerFirst(param0: java.lang.Object): boolean;

                public iterator(): java.util.Iterator;

                public addLast(param0: java.lang.Object): void;

                public getLast(): java.lang.Object;

                public descendingIterator(): java.util.Iterator;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public peekLast(): java.lang.Object;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class BlockingQueue extends java.lang.Object implements java.util.Queue {
                /**
                 * Constructs a new instance of the java.util.concurrent.BlockingQueue interface with the provided implementation.
                 */
                public constructor(implementation: {
                    add(param0: java.lang.Object): boolean;
                    offer(param0: java.lang.Object): boolean;
                    put(param0: java.lang.Object): void;
                    offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                    take(): java.lang.Object;
                    poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                    remainingCapacity(): number;
                    remove(param0: java.lang.Object): boolean;
                    contains(param0: java.lang.Object): boolean;
                    drainTo(param0: java.util.Collection): number;
                    drainTo(param0: java.util.Collection, param1: number): number;
                    add(param0: java.lang.Object): boolean;
                    offer(param0: java.lang.Object): boolean;
                    remove(): java.lang.Object;
                    poll(): java.lang.Object;
                    element(): java.lang.Object;
                    peek(): java.lang.Object;
                    add(param0: java.lang.Object): boolean;
                    addAll(param0: java.util.Collection): boolean;
                    clear(): void;
                    contains(param0: java.lang.Object): boolean;
                    containsAll(param0: java.util.Collection): boolean;
                    equals(param0: java.lang.Object): boolean;
                    hashCode(): number;
                    isEmpty(): boolean;
                    iterator(): java.util.Iterator;
                    remove(param0: java.lang.Object): boolean;
                    removeAll(param0: java.util.Collection): boolean;
                    retainAll(param0: java.util.Collection): boolean;
                    size(): number;
                    toArray(): native.Array<java.lang.Object>;
                    toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                    iterator(): java.util.Iterator;
                });

                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public retainAll(param0: java.util.Collection): boolean;

                public toArray(): native.Array<java.lang.Object>;

                public put(param0: java.lang.Object): void;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public take(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public element(): java.lang.Object;

                public iterator(): java.util.Iterator;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public remainingCapacity(): number;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class BrokenBarrierException extends java.lang.Exception {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class Callable extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.concurrent.Callable interface with the provided implementation.
                 */
                public constructor(implementation: {
                    call(): java.lang.Object;
                });

                public call(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class CancellationException extends java.lang.IllegalStateException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.Future.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class CompletionService extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.concurrent.CompletionService interface with the provided implementation.
                 */
                public constructor(implementation: {
                    submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                    submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;
                    take(): java.util.concurrent.Future;
                    poll(): java.util.concurrent.Future;
                    poll(param0: number, param1: java.util.concurrent.TimeUnit): java.util.concurrent.Future;
                });

                public submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.util.concurrent.Future;

                public take(): java.util.concurrent.Future;

                public submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;

                public poll(): java.util.concurrent.Future;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ConcurrentHashMap extends java.util.AbstractMap implements java.util.concurrent.ConcurrentMap, java.io.Serializable {
                public constructor(param0: number, param1: number);

                public remove(param0: java.lang.Object, param1: java.lang.Object): boolean;

                public constructor(param0: number, param1: number, param2: number);

                public keySet(): java.util.Set;

                public equals(param0: java.lang.Object): boolean;

                public values(): java.util.Collection;

                public elements(): java.util.Enumeration;

                public containsValue(param0: java.lang.Object): boolean;

                public keys(): java.util.Enumeration;

                public putAll(param0: java.util.Map): void;

                public constructor();

                public get(param0: java.lang.Object): java.lang.Object;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public isEmpty(): boolean;

                public constructor(param0: java.util.Map);

                public replace(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public putIfAbsent(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public containsKey(param0: java.lang.Object): boolean;

                public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public toString(): string;

                public entrySet(): java.util.Set;

                public size(): number;

                public replace(param0: java.lang.Object, param1: java.lang.Object, param2: java.lang.Object): boolean;

                public constructor(param0: number);

                public remove(param0: java.lang.Object): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ConcurrentLinkedDeque extends java.util.AbstractCollection implements java.util.Deque, java.io.Serializable {
                public constructor(param0: java.util.Collection);

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public toArray(): native.Array<java.lang.Object>;

                public removeLastOccurrence(param0: java.lang.Object): boolean;

                public push(param0: java.lang.Object): void;

                public getFirst(): java.lang.Object;

                public removeFirst(): java.lang.Object;

                public hashCode(): number;

                public peekFirst(): java.lang.Object;

                public pollLast(): java.lang.Object;

                public removeLast(): java.lang.Object;

                public pop(): java.lang.Object;

                public removeFirstOccurrence(param0: java.lang.Object): boolean;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offerLast(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public pollFirst(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public offerFirst(param0: java.lang.Object): boolean;

                public element(): java.lang.Object;

                public iterator(): java.util.Iterator;

                public addLast(param0: java.lang.Object): void;

                public getLast(): java.lang.Object;

                public size(): number;

                public descendingIterator(): java.util.Iterator;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public addFirst(param0: java.lang.Object): void;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public peekLast(): java.lang.Object;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ConcurrentLinkedQueue extends java.util.AbstractQueue implements java.util.Queue, java.io.Serializable {
                public constructor(param0: java.util.Collection);

                public iterator(): java.util.Iterator;

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public size(): number;

                public toArray(): native.Array<java.lang.Object>;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public remove(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public add(param0: java.lang.Object): boolean;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public containsAll(param0: java.util.Collection): boolean;

                public element(): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ConcurrentMap extends java.lang.Object implements java.util.Map {
                /**
                 * Constructs a new instance of the java.util.concurrent.ConcurrentMap interface with the provided implementation.
                 */
                public constructor(implementation: {
                    putIfAbsent(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                    remove(param0: java.lang.Object, param1: java.lang.Object): boolean;
                    replace(param0: java.lang.Object, param1: java.lang.Object, param2: java.lang.Object): boolean;
                    replace(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                    clear(): void;
                    containsKey(param0: java.lang.Object): boolean;
                    containsValue(param0: java.lang.Object): boolean;
                    entrySet(): java.util.Set;
                    equals(param0: java.lang.Object): boolean;
                    get(param0: java.lang.Object): java.lang.Object;
                    hashCode(): number;
                    isEmpty(): boolean;
                    keySet(): java.util.Set;
                    put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                    putAll(param0: java.util.Map): void;
                    remove(param0: java.lang.Object): java.lang.Object;
                    size(): number;
                    values(): java.util.Collection;
                });

                public remove(param0: java.lang.Object, param1: java.lang.Object): boolean;

                public keySet(): java.util.Set;

                public putIfAbsent(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public containsKey(param0: java.lang.Object): boolean;

                public equals(param0: java.lang.Object): boolean;

                public values(): java.util.Collection;

                public containsValue(param0: java.lang.Object): boolean;

                public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public putAll(param0: java.util.Map): void;

                public entrySet(): java.util.Set;

                public get(param0: java.lang.Object): java.lang.Object;

                public size(): number;

                public replace(param0: java.lang.Object, param1: java.lang.Object, param2: java.lang.Object): boolean;

                public hashCode(): number;

                public clear(): void;

                public isEmpty(): boolean;

                public replace(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public remove(param0: java.lang.Object): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.NavigableMap.d.ts" />
/// <reference path="./java.util.NavigableSet.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./java.util.SortedMap.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ConcurrentNavigableMap extends java.lang.Object implements java.util.concurrent.ConcurrentMap, java.util.NavigableMap {
                /**
                 * Constructs a new instance of the java.util.concurrent.ConcurrentNavigableMap interface with the provided implementation.
                 */
                public constructor(implementation: {
                    subMap(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.concurrent.ConcurrentNavigableMap;
                    headMap(param0: java.lang.Object, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                    tailMap(param0: java.lang.Object, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                    subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.concurrent.ConcurrentNavigableMap;
                    headMap(param0: java.lang.Object): java.util.concurrent.ConcurrentNavigableMap;
                    tailMap(param0: java.lang.Object): java.util.concurrent.ConcurrentNavigableMap;
                    descendingMap(): java.util.concurrent.ConcurrentNavigableMap;
                    navigableKeySet(): java.util.NavigableSet;
                    keySet(): java.util.NavigableSet;
                    descendingKeySet(): java.util.NavigableSet;
                    putIfAbsent(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                    remove(param0: java.lang.Object, param1: java.lang.Object): boolean;
                    replace(param0: java.lang.Object, param1: java.lang.Object, param2: java.lang.Object): boolean;
                    replace(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                    lowerEntry(param0: java.lang.Object): java.util.Map.Entry;
                    lowerKey(param0: java.lang.Object): java.lang.Object;
                    floorEntry(param0: java.lang.Object): java.util.Map.Entry;
                    floorKey(param0: java.lang.Object): java.lang.Object;
                    ceilingEntry(param0: java.lang.Object): java.util.Map.Entry;
                    ceilingKey(param0: java.lang.Object): java.lang.Object;
                    higherEntry(param0: java.lang.Object): java.util.Map.Entry;
                    higherKey(param0: java.lang.Object): java.lang.Object;
                    firstEntry(): java.util.Map.Entry;
                    lastEntry(): java.util.Map.Entry;
                    pollFirstEntry(): java.util.Map.Entry;
                    pollLastEntry(): java.util.Map.Entry;
                    descendingMap(): java.util.NavigableMap;
                    navigableKeySet(): java.util.NavigableSet;
                    descendingKeySet(): java.util.NavigableSet;
                    subMap(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableMap;
                    headMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;
                    tailMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;
                    subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;
                    headMap(param0: java.lang.Object): java.util.SortedMap;
                    tailMap(param0: java.lang.Object): java.util.SortedMap;
                    clear(): void;
                    containsKey(param0: java.lang.Object): boolean;
                    containsValue(param0: java.lang.Object): boolean;
                    entrySet(): java.util.Set;
                    equals(param0: java.lang.Object): boolean;
                    get(param0: java.lang.Object): java.lang.Object;
                    hashCode(): number;
                    isEmpty(): boolean;
                    keySet(): java.util.Set;
                    put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                    putAll(param0: java.util.Map): void;
                    remove(param0: java.lang.Object): java.lang.Object;
                    size(): number;
                    values(): java.util.Collection;
                    comparator(): java.util.Comparator;
                    firstKey(): java.lang.Object;
                    headMap(param0: java.lang.Object): java.util.SortedMap;
                    lastKey(): java.lang.Object;
                    subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;
                    tailMap(param0: java.lang.Object): java.util.SortedMap;
                    clear(): void;
                    containsKey(param0: java.lang.Object): boolean;
                    containsValue(param0: java.lang.Object): boolean;
                    entrySet(): java.util.Set;
                    equals(param0: java.lang.Object): boolean;
                    get(param0: java.lang.Object): java.lang.Object;
                    hashCode(): number;
                    isEmpty(): boolean;
                    keySet(): java.util.Set;
                    put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;
                    putAll(param0: java.util.Map): void;
                    remove(param0: java.lang.Object): java.lang.Object;
                    size(): number;
                    values(): java.util.Collection;
                });

                public keySet(): java.util.Set;

                public equals(param0: java.lang.Object): boolean;

                public descendingMap(): java.util.concurrent.ConcurrentNavigableMap;

                public values(): java.util.Collection;

                public headMap(param0: java.lang.Object, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;

                public descendingMap(): java.util.NavigableMap;

                public containsValue(param0: java.lang.Object): boolean;

                public headMap(param0: java.lang.Object): java.util.concurrent.ConcurrentNavigableMap;

                public lowerKey(param0: java.lang.Object): java.lang.Object;

                public ceilingKey(param0: java.lang.Object): java.lang.Object;

                public hashCode(): number;

                public higherEntry(param0: java.lang.Object): java.util.Map.Entry;

                public isEmpty(): boolean;

                public firstKey(): java.lang.Object;

                public putIfAbsent(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public pollFirstEntry(): java.util.Map.Entry;

                public subMap(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableMap;

                public keySet(): java.util.NavigableSet;

                public higherKey(param0: java.lang.Object): java.lang.Object;

                public subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;

                public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public floorKey(param0: java.lang.Object): java.lang.Object;

                public subMap(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.concurrent.ConcurrentNavigableMap;

                public descendingKeySet(): java.util.NavigableSet;

                public size(): number;

                public subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.concurrent.ConcurrentNavigableMap;

                public replace(param0: java.lang.Object, param1: java.lang.Object, param2: java.lang.Object): boolean;

                public pollLastEntry(): java.util.Map.Entry;

                public headMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;

                public navigableKeySet(): java.util.NavigableSet;

                public remove(param0: java.lang.Object): java.lang.Object;

                public lowerEntry(param0: java.lang.Object): java.util.Map.Entry;

                public remove(param0: java.lang.Object, param1: java.lang.Object): boolean;

                public putAll(param0: java.util.Map): void;

                public ceilingEntry(param0: java.lang.Object): java.util.Map.Entry;

                public get(param0: java.lang.Object): java.lang.Object;

                public headMap(param0: java.lang.Object): java.util.SortedMap;

                public lastEntry(): java.util.Map.Entry;

                public clear(): void;

                public replace(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public floorEntry(param0: java.lang.Object): java.util.Map.Entry;

                public firstEntry(): java.util.Map.Entry;

                public containsKey(param0: java.lang.Object): boolean;

                public tailMap(param0: java.lang.Object): java.util.SortedMap;

                public lastKey(): java.lang.Object;

                public entrySet(): java.util.Set;

                public comparator(): java.util.Comparator;

                public tailMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;
                public tailMap(param0: java.lang.Object, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                public tailMap(param0: java.lang.Object): java.util.concurrent.ConcurrentNavigableMap;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.NavigableMap.d.ts" />
/// <reference path="./java.util.NavigableSet.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
/// <reference path="./java.util.SortedMap.d.ts" />
/// <reference path="./java.util.concurrent.ConcurrentNavigableMap.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ConcurrentSkipListMap extends java.util.AbstractMap implements java.util.concurrent.ConcurrentNavigableMap, java.lang.Cloneable, java.io.Serializable {
                public keySet(): java.util.Set;

                public equals(param0: java.lang.Object): boolean;

                public constructor(param0: java.util.SortedMap);

                public descendingMap(): java.util.concurrent.ConcurrentNavigableMap;

                public values(): java.util.Collection;

                public headMap(param0: java.lang.Object, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;

                public containsValue(param0: java.lang.Object): boolean;

                public descendingMap(): java.util.NavigableMap;

                public clone(): java.lang.Object;

                public constructor();

                public headMap(param0: java.lang.Object): java.util.concurrent.ConcurrentNavigableMap;

                public lowerKey(param0: java.lang.Object): java.lang.Object;

                public ceilingKey(param0: java.lang.Object): java.lang.Object;

                public hashCode(): number;

                public higherEntry(param0: java.lang.Object): java.util.Map.Entry;

                public isEmpty(): boolean;

                public constructor(param0: java.util.Map);

                public firstKey(): java.lang.Object;

                public putIfAbsent(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public pollFirstEntry(): java.util.Map.Entry;

                public subMap(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableMap;

                public keySet(): java.util.NavigableSet;

                public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public higherKey(param0: java.lang.Object): java.lang.Object;

                public subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedMap;

                public floorKey(param0: java.lang.Object): java.lang.Object;

                public subMap(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.concurrent.ConcurrentNavigableMap;

                public size(): number;

                public descendingKeySet(): java.util.NavigableSet;

                public replace(param0: java.lang.Object, param1: java.lang.Object, param2: java.lang.Object): boolean;

                public subMap(param0: java.lang.Object, param1: java.lang.Object): java.util.concurrent.ConcurrentNavigableMap;

                public constructor(param0: java.util.Comparator);

                public pollLastEntry(): java.util.Map.Entry;

                public headMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;

                public navigableKeySet(): java.util.NavigableSet;

                public remove(param0: java.lang.Object): java.lang.Object;

                public lowerEntry(param0: java.lang.Object): java.util.Map.Entry;

                public remove(param0: java.lang.Object, param1: java.lang.Object): boolean;

                public putAll(param0: java.util.Map): void;

                public ceilingEntry(param0: java.lang.Object): java.util.Map.Entry;

                public get(param0: java.lang.Object): java.lang.Object;

                public headMap(param0: java.lang.Object): java.util.SortedMap;

                public clear(): void;

                public lastEntry(): java.util.Map.Entry;

                public replace(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public floorEntry(param0: java.lang.Object): java.util.Map.Entry;

                public firstEntry(): java.util.Map.Entry;

                public containsKey(param0: java.lang.Object): boolean;

                public lastKey(): java.lang.Object;

                public tailMap(param0: java.lang.Object): java.util.SortedMap;

                public entrySet(): java.util.Set;

                public comparator(): java.util.Comparator;

                public tailMap(param0: java.lang.Object, param1: boolean): java.util.NavigableMap;
                public tailMap(param0: java.lang.Object, param1: boolean): java.util.concurrent.ConcurrentNavigableMap;
                public tailMap(param0: java.lang.Object): java.util.concurrent.ConcurrentNavigableMap;

                public clone(): java.util.concurrent.ConcurrentSkipListMap;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.NavigableSet.d.ts" />
/// <reference path="./java.util.SortedSet.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ConcurrentSkipListSet extends java.util.AbstractSet implements java.util.NavigableSet, java.lang.Cloneable, java.io.Serializable {
                public constructor(param0: java.util.Collection);

                public subSet(param0: java.lang.Object, param1: boolean, param2: java.lang.Object, param3: boolean): java.util.NavigableSet;
                public subSet(param0: java.lang.Object, param1: java.lang.Object): java.util.NavigableSet;

                public equals(param0: java.lang.Object): boolean;

                public tailSet(param0: java.lang.Object): java.util.NavigableSet;

                public first(): java.lang.Object;

                public clone(): java.lang.Object;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public toArray(): native.Array<java.lang.Object>;

                public tailSet(param0: java.lang.Object): java.util.SortedSet;

                public constructor(param0: java.util.SortedSet);

                public hashCode(): number;

                public pollLast(): java.lang.Object;

                public clear(): void;

                public descendingSet(): java.util.NavigableSet;

                public contains(param0: java.lang.Object): boolean;

                public subSet(param0: java.lang.Object, param1: java.lang.Object): java.util.SortedSet;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public pollFirst(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public headSet(param0: java.lang.Object): java.util.SortedSet;

                public iterator(): java.util.Iterator;

                public lower(param0: java.lang.Object): java.lang.Object;

                public ceiling(param0: java.lang.Object): java.lang.Object;

                public headSet(param0: java.lang.Object, param1: boolean): java.util.NavigableSet;

                public last(): java.lang.Object;

                public comparator(): java.util.Comparator;

                public size(): number;

                public descendingIterator(): java.util.Iterator;

                public addAll(param0: java.util.Collection): boolean;

                public constructor(param0: java.util.Comparator);

                public floor(param0: java.lang.Object): java.lang.Object;

                public headSet(param0: java.lang.Object): java.util.NavigableSet;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public tailSet(param0: java.lang.Object, param1: boolean): java.util.NavigableSet;

                public containsAll(param0: java.util.Collection): boolean;

                public clone(): java.util.concurrent.ConcurrentSkipListSet;

                public higher(param0: java.lang.Object): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.ListIterator.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class CopyOnWriteArrayList extends java.lang.Object implements java.util.List, java.util.RandomAccess, java.lang.Cloneable, java.io.Serializable {
                public constructor(param0: java.util.Collection);

                public addIfAbsent(param0: java.lang.Object): boolean;

                public subList(param0: number, param1: number): java.util.List;

                public equals(param0: java.lang.Object): boolean;

                public addAll(param0: number, param1: java.util.Collection): boolean;

                public listIterator(param0: number): java.util.ListIterator;

                public clone(): java.lang.Object;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public toArray(): native.Array<java.lang.Object>;

                public add(param0: number, param1: java.lang.Object): void;

                public remove(param0: number): java.lang.Object;

                public indexOf(param0: java.lang.Object, param1: number): number;

                public hashCode(): number;

                public constructor(param0: native.Array<java.lang.Object>);

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public addAllAbsent(param0: java.util.Collection): number;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public listIterator(): java.util.ListIterator;

                public iterator(): java.util.Iterator;

                public toString(): string;

                public size(): number;

                public lastIndexOf(param0: java.lang.Object): number;

                public set(param0: number, param1: java.lang.Object): java.lang.Object;

                public get(param0: number): java.lang.Object;

                public indexOf(param0: java.lang.Object): number;

                public addAll(param0: java.util.Collection): boolean;

                public lastIndexOf(param0: java.lang.Object, param1: number): number;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class CopyOnWriteArraySet extends java.util.AbstractSet implements java.io.Serializable {
                public constructor(param0: java.util.Collection);

                public iterator(): java.util.Iterator;

                public equals(param0: java.lang.Object): boolean;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public size(): number;

                public toArray(): native.Array<java.lang.Object>;

                public addAll(param0: java.util.Collection): boolean;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public remove(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public add(param0: java.lang.Object): boolean;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class CountDownLatch extends java.lang.Object {
                public countDown(): void;

                public constructor(param0: number);

                public getCount(): number;

                public await(): void;

                public toString(): string;

                public await(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class CyclicBarrier extends java.lang.Object {
                public reset(): void;

                public await(): number;

                public constructor(param0: number);

                public await(param0: number, param1: java.util.concurrent.TimeUnit): number;

                public getNumberWaiting(): number;

                public isBroken(): boolean;

                public getParties(): number;

                public constructor(param0: number, param1: java.lang.Runnable);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.Delayed.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class DelayQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue {
                public constructor(param0: java.util.Collection);

                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public put(param0: java.util.concurrent.Delayed): void;

                public toArray(): native.Array<java.lang.Object>;

                public offer(param0: java.util.concurrent.Delayed): boolean;

                public put(param0: java.lang.Object): void;

                public poll(): java.util.concurrent.Delayed;

                public hashCode(): number;

                public add(param0: java.util.concurrent.Delayed): boolean;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public take(): java.lang.Object;

                public element(): java.lang.Object;

                public iterator(): java.util.Iterator;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.util.concurrent.Delayed;

                public offer(param0: java.util.concurrent.Delayed, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public take(): java.util.concurrent.Delayed;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public peek(): java.util.concurrent.Delayed;

                public remainingCapacity(): number;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class Delayed extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.concurrent.Delayed interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getDelay(param0: java.util.concurrent.TimeUnit): number;
                });

                public getDelay(param0: java.util.concurrent.TimeUnit): number;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class Exchanger extends java.lang.Object {
                public exchange(param0: java.lang.Object): java.lang.Object;
                public exchange(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): java.lang.Object;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ExecutionException extends java.lang.Exception {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Runnable.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class Executor extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.concurrent.Executor interface with the provided implementation.
                 */
                public constructor(implementation: {
                    execute(param0: java.lang.Runnable): void;
                });

                public execute(param0: java.lang.Runnable): void;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.util.concurrent.BlockingQueue.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.Executor.d.ts" />
/// <reference path="./java.util.concurrent.Future.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ExecutorCompletionService extends java.lang.Object implements java.util.concurrent.CompletionService {
                public constructor(param0: java.util.concurrent.Executor, param1: java.util.concurrent.BlockingQueue);

                public submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.util.concurrent.Future;

                public constructor(param0: java.util.concurrent.Executor);

                public take(): java.util.concurrent.Future;

                public submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;

                public poll(): java.util.concurrent.Future;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.Future.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ExecutorService extends java.lang.Object implements java.util.concurrent.Executor {
                /**
                 * Constructs a new instance of the java.util.concurrent.ExecutorService interface with the provided implementation.
                 */
                public constructor(implementation: {
                    shutdown(): void;
                    shutdownNow(): java.util.List;
                    isShutdown(): boolean;
                    isTerminated(): boolean;
                    awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                    submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;
                    submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                    invokeAll(param0: java.util.Collection): java.util.List;
                    invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                    invokeAny(param0: java.util.Collection): java.lang.Object;
                    invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.lang.Object;
                    execute(param0: java.lang.Runnable): void;
                });

                public invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;

                public isTerminated(): boolean;

                public submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                public submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;

                public invokeAny(param0: java.util.Collection): java.lang.Object;
                public invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.lang.Object;

                public awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                public submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;

                public shutdown(): void;

                public execute(param0: java.lang.Runnable): void;

                public isShutdown(): boolean;

                public invokeAll(param0: java.util.Collection): java.util.List;

                public shutdownNow(): java.util.List;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.security.PrivilegedAction.d.ts" />
/// <reference path="./java.security.PrivilegedExceptionAction.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.ExecutorService.d.ts" />
/// <reference path="./java.util.concurrent.ScheduledExecutorService.d.ts" />
/// <reference path="./java.util.concurrent.ThreadFactory.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class Executors extends java.lang.Object {
                public static newScheduledThreadPool(param0: number): java.util.concurrent.ScheduledExecutorService;

                public static privilegedCallableUsingCurrentClassLoader(param0: java.util.concurrent.Callable): java.util.concurrent.Callable;

                public static unconfigurableScheduledExecutorService(param0: java.util.concurrent.ScheduledExecutorService): java.util.concurrent.ScheduledExecutorService;

                public static callable(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Callable;

                public static newCachedThreadPool(param0: java.util.concurrent.ThreadFactory): java.util.concurrent.ExecutorService;

                public static privilegedThreadFactory(): java.util.concurrent.ThreadFactory;

                public static callable(param0: java.security.PrivilegedExceptionAction): java.util.concurrent.Callable;

                public static newFixedThreadPool(param0: number): java.util.concurrent.ExecutorService;

                public static privilegedCallable(param0: java.util.concurrent.Callable): java.util.concurrent.Callable;

                public static newCachedThreadPool(): java.util.concurrent.ExecutorService;

                public static newSingleThreadScheduledExecutor(): java.util.concurrent.ScheduledExecutorService;
                public static newSingleThreadScheduledExecutor(param0: java.util.concurrent.ThreadFactory): java.util.concurrent.ScheduledExecutorService;

                public static defaultThreadFactory(): java.util.concurrent.ThreadFactory;

                public static newFixedThreadPool(param0: number, param1: java.util.concurrent.ThreadFactory): java.util.concurrent.ExecutorService;

                public static newSingleThreadExecutor(): java.util.concurrent.ExecutorService;

                public static callable(param0: java.security.PrivilegedAction): java.util.concurrent.Callable;

                public static newSingleThreadExecutor(param0: java.util.concurrent.ThreadFactory): java.util.concurrent.ExecutorService;

                public static newScheduledThreadPool(param0: number, param1: java.util.concurrent.ThreadFactory): java.util.concurrent.ScheduledExecutorService;

                public static unconfigurableExecutorService(param0: java.util.concurrent.ExecutorService): java.util.concurrent.ExecutorService;

                public static callable(param0: java.lang.Runnable): java.util.concurrent.Callable;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.ForkJoinPool.d.ts" />
/// <reference path="./java.util.concurrent.ForkJoinTask.d.ts" />
/// <reference path="./java.util.concurrent.ForkJoinWorkerThread.d.ts" />
/// <reference path="./java.util.concurrent.Future.d.ts" />
/// <reference path="./java.util.concurrent.RunnableFuture.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ForkJoinPool extends java.util.concurrent.AbstractExecutorService {
                public static defaultForkJoinWorkerThreadFactory: java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory;

                public submit(param0: java.util.concurrent.ForkJoinTask): java.util.concurrent.ForkJoinTask;

                public getAsyncMode(): boolean;

                public isTerminated(): boolean;

                public submit(param0: java.lang.Runnable): java.util.concurrent.Future;

                public newTaskFor(param0: java.util.concurrent.Callable): java.util.concurrent.RunnableFuture;
                public newTaskFor(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.RunnableFuture;

                public submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;

                public invoke(param0: java.util.concurrent.ForkJoinTask): java.lang.Object;

                public submit(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;

                public pollSubmission(): java.util.concurrent.ForkJoinTask;

                public getStealCount(): number;

                public isTerminating(): boolean;

                public constructor();

                public submit(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;

                public awaitQuiescence(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                public submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;

                public hasQueuedSubmissions(): boolean;

                public awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                public shutdown(): void;

                public getFactory(): java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory;

                public isShutdown(): boolean;

                public shutdownNow(): java.util.List;

                public getParallelism(): number;

                public getPoolSize(): number;

                public invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;

                public getRunningThreadCount(): number;

                public getActiveThreadCount(): number;

                public getQueuedSubmissionCount(): number;

                public getQueuedTaskCount(): number;

                public constructor(param0: number, param1: java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory, param2: java.lang.Thread.UncaughtExceptionHandler, param3: boolean);

                public toString(): string;

                public getUncaughtExceptionHandler(): java.lang.Thread.UncaughtExceptionHandler;

                public invokeAny(param0: java.util.Collection): java.lang.Object;

                public drainTasksTo(param0: java.util.Collection): number;

                public invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.lang.Object;

                public static managedBlock(param0: java.util.concurrent.ForkJoinPool.ManagedBlocker): void;

                public execute(param0: java.lang.Runnable): void;
                public execute(param0: java.util.concurrent.ForkJoinTask): void;

                public constructor(param0: number);

                public invokeAll(param0: java.util.Collection): java.util.List;

                public isQuiescent(): boolean;

                public submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.ForkJoinTask;
            }
            export module ForkJoinPool {
                export class ForkJoinWorkerThreadFactory extends java.lang.Object {
                    /**
                     * Constructs a new instance of the java.util.concurrent.ForkJoinPool$ForkJoinWorkerThreadFactory interface with the provided implementation.
                     */
                    public constructor(implementation: {
                        newThread(param0: java.util.concurrent.ForkJoinPool): java.util.concurrent.ForkJoinWorkerThread;
                    });

                    public newThread(param0: java.util.concurrent.ForkJoinPool): java.util.concurrent.ForkJoinWorkerThread;
                }
                export class ManagedBlocker extends java.lang.Object {
                    /**
                     * Constructs a new instance of the java.util.concurrent.ForkJoinPool$ManagedBlocker interface with the provided implementation.
                     */
                    public constructor(implementation: {
                        block(): boolean;
                        isReleasable(): boolean;
                    });

                    public block(): boolean;

                    public isReleasable(): boolean;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.ForkJoinPool.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export abstract class ForkJoinTask extends java.lang.Object implements java.util.concurrent.Future, java.io.Serializable {
                public reinitialize(): void;

                public isCompletedNormally(): boolean;

                public exec(): boolean;

                public static invokeAll(param0: java.util.concurrent.ForkJoinTask, param1: java.util.concurrent.ForkJoinTask): void;

                public static inForkJoinPool(): boolean;

                public static getPool(): java.util.concurrent.ForkJoinPool;

                public fork(): java.util.concurrent.ForkJoinTask;

                public completeExceptionally(param0: java.lang.Throwable): void;

                public constructor();

                public static invokeAll(param0: native.Array<java.util.concurrent.ForkJoinTask>): void;

                public isCompletedAbnormally(): boolean;

                public complete(param0: java.lang.Object): void;

                public quietlyInvoke(): void;

                public static adapt(param0: java.lang.Runnable): java.util.concurrent.ForkJoinTask;
                public static adapt(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.ForkJoinTask;

                public get(): java.lang.Object;

                public tryUnfork(): boolean;

                public static getQueuedTaskCount(): number;

                public cancel(param0: boolean): boolean;

                public static helpQuiesce(): void;

                public static getSurplusQueuedTaskCount(): number;

                public join(): java.lang.Object;

                public quietlyJoin(): void;

                public getRawResult(): java.lang.Object;

                public static peekNextLocalTask(): java.util.concurrent.ForkJoinTask;

                public static adapt(param0: java.util.concurrent.Callable): java.util.concurrent.ForkJoinTask;

                public static pollNextLocalTask(): java.util.concurrent.ForkJoinTask;

                public isDone(): boolean;

                public invoke(): java.lang.Object;

                public getException(): java.lang.Throwable;

                public setRawResult(param0: java.lang.Object): void;

                public static pollTask(): java.util.concurrent.ForkJoinTask;

                public static invokeAll(param0: java.util.Collection): java.util.Collection;

                public isCancelled(): boolean;

                public get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.ThreadGroup.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.concurrent.ForkJoinPool.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ForkJoinWorkerThread extends java.lang.Thread {
                public constructor(param0: java.lang.ThreadGroup, param1: java.lang.Runnable, param2: string);
                public constructor(param0: java.lang.ThreadGroup, param1: java.lang.Runnable);
                public constructor(param0: string);
                public constructor();

                public getPoolIndex(): number;

                public constructor(param0: java.lang.Runnable, param1: string);

                public getPool(): java.util.concurrent.ForkJoinPool;

                public constructor(param0: java.util.concurrent.ForkJoinPool);

                public run(): void;

                public onStart(): void;

                public constructor(param0: java.lang.ThreadGroup, param1: string);

                public onTermination(param0: java.lang.Throwable): void;

                public constructor(param0: java.lang.ThreadGroup, param1: java.lang.Runnable, param2: string, param3: number);
                public constructor(param0: java.lang.Runnable);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class Future extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.concurrent.Future interface with the provided implementation.
                 */
                public constructor(implementation: {
                    cancel(param0: boolean): boolean;
                    isCancelled(): boolean;
                    isDone(): boolean;
                    get(): java.lang.Object;
                    get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                });

                public isDone(): boolean;

                public get(): java.lang.Object;

                public cancel(param0: boolean): boolean;

                public isCancelled(): boolean;

                public get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class FutureTask extends java.lang.Object implements java.util.concurrent.RunnableFuture {
                public constructor(param0: java.util.concurrent.Callable);

                public isDone(): boolean;

                public done(): void;

                public setException(param0: java.lang.Throwable): void;

                public run(): void;

                public set(param0: java.lang.Object): void;

                public runAndReset(): boolean;

                public constructor(param0: java.lang.Runnable, param1: java.lang.Object);

                public get(): java.lang.Object;

                public cancel(param0: boolean): boolean;

                public isCancelled(): boolean;

                public get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class LinkedBlockingDeque extends java.util.AbstractQueue implements java.util.concurrent.BlockingDeque, java.io.Serializable {
                public constructor(param0: java.util.Collection);

                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public toArray(): native.Array<java.lang.Object>;

                public removeLastOccurrence(param0: java.lang.Object): boolean;

                public push(param0: java.lang.Object): void;

                public hashCode(): number;

                public removeLast(): java.lang.Object;

                public pollLast(): java.lang.Object;

                public removeFirstOccurrence(param0: java.lang.Object): boolean;

                public pop(): java.lang.Object;

                public contains(param0: java.lang.Object): boolean;

                public offerLast(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public pollFirst(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public element(): java.lang.Object;

                public offerLast(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public takeFirst(): java.lang.Object;

                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public pollFirst(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public toString(): string;

                public pollLast(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public addFirst(param0: java.lang.Object): void;

                public remainingCapacity(): number;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public putLast(param0: java.lang.Object): void;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public offerFirst(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public put(param0: java.lang.Object): void;

                public getFirst(): java.lang.Object;

                public putFirst(param0: java.lang.Object): void;

                public removeFirst(): java.lang.Object;

                public peekFirst(): java.lang.Object;

                public clear(): void;

                public offer(param0: java.lang.Object): boolean;

                public takeLast(): java.lang.Object;

                public take(): java.lang.Object;

                public offerFirst(param0: java.lang.Object): boolean;

                public iterator(): java.util.Iterator;

                public addLast(param0: java.lang.Object): void;

                public getLast(): java.lang.Object;

                public descendingIterator(): java.util.Iterator;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public constructor(param0: number);

                public peekLast(): java.lang.Object;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class LinkedBlockingQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue, java.io.Serializable {
                public constructor(param0: java.util.Collection);

                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public toArray(): native.Array<java.lang.Object>;

                public put(param0: java.lang.Object): void;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public take(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public element(): java.lang.Object;

                public iterator(): java.util.Iterator;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public toString(): string;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public remainingCapacity(): number;

                public constructor(param0: number);

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class LinkedTransferQueue extends java.util.AbstractQueue implements java.util.concurrent.TransferQueue, java.io.Serializable {
                public constructor(param0: java.util.Collection);

                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public hasWaitingConsumer(): boolean;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public toArray(): native.Array<java.lang.Object>;

                public put(param0: java.lang.Object): void;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public take(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public element(): java.lang.Object;

                public iterator(): java.util.Iterator;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public transfer(param0: java.lang.Object): void;

                public getWaitingConsumerCount(): number;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public remainingCapacity(): number;

                public tryTransfer(param0: java.lang.Object): boolean;
                public tryTransfer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class Phaser extends java.lang.Object {
                public bulkRegister(param0: number): number;

                public arrive(): number;

                public getPhase(): number;

                public constructor(param0: java.util.concurrent.Phaser, param1: number);

                public getRoot(): java.util.concurrent.Phaser;

                public isTerminated(): boolean;

                public getUnarrivedParties(): number;

                public forceTermination(): void;

                public register(): number;

                public awaitAdvance(param0: number): number;

                public constructor(param0: java.util.concurrent.Phaser);

                public getParent(): java.util.concurrent.Phaser;

                public onAdvance(param0: number, param1: number): boolean;

                public toString(): string;

                public constructor();

                public getArrivedParties(): number;

                public arriveAndDeregister(): number;

                public constructor(param0: number);

                public arriveAndAwaitAdvance(): number;

                public getRegisteredParties(): number;

                public awaitAdvanceInterruptibly(param0: number): number;
                public awaitAdvanceInterruptibly(param0: number, param1: number, param2: java.util.concurrent.TimeUnit): number;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Comparator.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class PriorityBlockingQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue, java.io.Serializable {
                public constructor(param0: java.util.Collection);

                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public constructor(param0: number, param1: java.util.Comparator);

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public toArray(): native.Array<java.lang.Object>;

                public put(param0: java.lang.Object): void;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public take(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public element(): java.lang.Object;

                public iterator(): java.util.Iterator;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public toString(): string;

                public comparator(): java.util.Comparator;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public remainingCapacity(): number;

                public constructor(param0: number);

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Void.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export abstract class RecursiveAction extends java.util.concurrent.ForkJoinTask {
                public getRawResult(): java.lang.Void;

                public isDone(): boolean;

                public setRawResult(param0: java.lang.Void): void;

                public getRawResult(): java.lang.Object;

                public setRawResult(param0: java.lang.Object): void;

                public exec(): boolean;

                public get(): java.lang.Object;

                public cancel(param0: boolean): boolean;

                public compute(): void;

                public isCancelled(): boolean;

                public constructor();

                public get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export abstract class RecursiveTask extends java.util.concurrent.ForkJoinTask {
                public isDone(): boolean;

                public getRawResult(): java.lang.Object;

                public setRawResult(param0: java.lang.Object): void;

                public exec(): boolean;

                public get(): java.lang.Object;

                public cancel(param0: boolean): boolean;

                public compute(): java.lang.Object;

                public isCancelled(): boolean;

                public constructor();

                public get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class RejectedExecutionException extends java.lang.RuntimeException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.util.concurrent.ThreadPoolExecutor.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class RejectedExecutionHandler extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.concurrent.RejectedExecutionHandler interface with the provided implementation.
                 */
                public constructor(implementation: {
                    rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor): void;
                });

                public rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor): void;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class RunnableFuture extends java.lang.Object implements java.lang.Runnable, java.util.concurrent.Future {
                /**
                 * Constructs a new instance of the java.util.concurrent.RunnableFuture interface with the provided implementation.
                 */
                public constructor(implementation: {
                    run(): void;
                    run(): void;
                    cancel(param0: boolean): boolean;
                    isCancelled(): boolean;
                    isDone(): boolean;
                    get(): java.lang.Object;
                    get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                });

                public isDone(): boolean;

                public run(): void;

                public get(): java.lang.Object;

                public cancel(param0: boolean): boolean;

                public isCancelled(): boolean;

                public get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class RunnableScheduledFuture extends java.lang.Object implements java.util.concurrent.RunnableFuture, java.util.concurrent.ScheduledFuture {
                /**
                 * Constructs a new instance of the java.util.concurrent.RunnableScheduledFuture interface with the provided implementation.
                 */
                public constructor(implementation: {
                    isPeriodic(): boolean;
                    run(): void;
                    run(): void;
                    cancel(param0: boolean): boolean;
                    isCancelled(): boolean;
                    isDone(): boolean;
                    get(): java.lang.Object;
                    get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                    getDelay(param0: java.util.concurrent.TimeUnit): number;
                    cancel(param0: boolean): boolean;
                    isCancelled(): boolean;
                    isDone(): boolean;
                    get(): java.lang.Object;
                    get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                });

                public getDelay(param0: java.util.concurrent.TimeUnit): number;

                public isPeriodic(): boolean;

                public isDone(): boolean;

                public run(): void;

                public get(): java.lang.Object;

                public cancel(param0: boolean): boolean;

                public isCancelled(): boolean;

                public get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.Future.d.ts" />
/// <reference path="./java.util.concurrent.ScheduledFuture.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ScheduledExecutorService extends java.lang.Object implements java.util.concurrent.ExecutorService {
                /**
                 * Constructs a new instance of the java.util.concurrent.ScheduledExecutorService interface with the provided implementation.
                 */
                public constructor(implementation: {
                    schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                    schedule(param0: java.util.concurrent.Callable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                    scheduleAtFixedRate(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                    scheduleWithFixedDelay(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
                    shutdown(): void;
                    shutdownNow(): java.util.List;
                    isShutdown(): boolean;
                    isTerminated(): boolean;
                    awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;
                    submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;
                    submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                    invokeAll(param0: java.util.Collection): java.util.List;
                    invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;
                    invokeAny(param0: java.util.Collection): java.lang.Object;
                    invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.lang.Object;
                    execute(param0: java.lang.Runnable): void;
                });

                public invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;

                public schedule(param0: java.util.concurrent.Callable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;

                public isTerminated(): boolean;

                public submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                public submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;

                public invokeAny(param0: java.util.Collection): java.lang.Object;
                public invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.lang.Object;

                public awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                public submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;

                public shutdown(): void;

                public execute(param0: java.lang.Runnable): void;

                public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;

                public isShutdown(): boolean;

                public invokeAll(param0: java.util.Collection): java.util.List;

                public shutdownNow(): java.util.List;

                public scheduleWithFixedDelay(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;

                public scheduleAtFixedRate(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ScheduledFuture extends java.lang.Object implements java.util.concurrent.Delayed, java.util.concurrent.Future {
                /**
                 * Constructs a new instance of the java.util.concurrent.ScheduledFuture interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getDelay(param0: java.util.concurrent.TimeUnit): number;
                    cancel(param0: boolean): boolean;
                    isCancelled(): boolean;
                    isDone(): boolean;
                    get(): java.lang.Object;
                    get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                });

                public getDelay(param0: java.util.concurrent.TimeUnit): number;

                public isDone(): boolean;

                public get(): java.lang.Object;

                public cancel(param0: boolean): boolean;

                public isCancelled(): boolean;

                public get(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.concurrent.BlockingQueue.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.Future.d.ts" />
/// <reference path="./java.util.concurrent.RejectedExecutionHandler.d.ts" />
/// <reference path="./java.util.concurrent.RunnableScheduledFuture.d.ts" />
/// <reference path="./java.util.concurrent.ScheduledFuture.d.ts" />
/// <reference path="./java.util.concurrent.ThreadFactory.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ScheduledThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor implements java.util.concurrent.ScheduledExecutorService {
                public decorateTask(param0: java.lang.Runnable, param1: java.util.concurrent.RunnableScheduledFuture): java.util.concurrent.RunnableScheduledFuture;

                public isTerminated(): boolean;

                public submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                public submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;

                public constructor();
                public constructor(param0: number, param1: number, param2: number, param3: java.util.concurrent.TimeUnit, param4: java.util.concurrent.BlockingQueue, param5: java.util.concurrent.RejectedExecutionHandler);
                public constructor(param0: number, param1: number, param2: number, param3: java.util.concurrent.TimeUnit, param4: java.util.concurrent.BlockingQueue);

                public submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;

                public getExecuteExistingDelayedTasksAfterShutdownPolicy(): boolean;

                public awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                public decorateTask(param0: java.util.concurrent.Callable, param1: java.util.concurrent.RunnableScheduledFuture): java.util.concurrent.RunnableScheduledFuture;

                public setRemoveOnCancelPolicy(param0: boolean): void;

                public shutdown(): void;

                public schedule(param0: java.lang.Runnable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;

                public isShutdown(): boolean;

                public shutdownNow(): java.util.List;

                public scheduleWithFixedDelay(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;

                public constructor(param0: number, param1: java.util.concurrent.RejectedExecutionHandler);
                public constructor(param0: number, param1: java.util.concurrent.ThreadFactory);

                public invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;

                public schedule(param0: java.util.concurrent.Callable, param1: number, param2: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;

                public setContinueExistingPeriodicTasksAfterShutdownPolicy(param0: boolean): void;

                public getContinueExistingPeriodicTasksAfterShutdownPolicy(): boolean;

                public constructor(param0: number, param1: number, param2: number, param3: java.util.concurrent.TimeUnit, param4: java.util.concurrent.BlockingQueue, param5: java.util.concurrent.ThreadFactory);

                public getRemoveOnCancelPolicy(): boolean;

                public invokeAny(param0: java.util.Collection): java.lang.Object;
                public invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.lang.Object;

                public setExecuteExistingDelayedTasksAfterShutdownPolicy(param0: boolean): void;

                public execute(param0: java.lang.Runnable): void;

                public constructor(param0: number, param1: java.util.concurrent.ThreadFactory, param2: java.util.concurrent.RejectedExecutionHandler);

                public getQueue(): java.util.concurrent.BlockingQueue;

                public constructor(param0: number);

                public invokeAll(param0: java.util.Collection): java.util.List;

                public constructor(param0: number, param1: number, param2: number, param3: java.util.concurrent.TimeUnit, param4: java.util.concurrent.BlockingQueue, param5: java.util.concurrent.ThreadFactory, param6: java.util.concurrent.RejectedExecutionHandler);

                public scheduleAtFixedRate(param0: java.lang.Runnable, param1: number, param2: number, param3: java.util.concurrent.TimeUnit): java.util.concurrent.ScheduledFuture;
            }
        }
    }
}

/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class Semaphore extends java.lang.Object implements java.io.Serializable {
                public reducePermits(param0: number): void;

                public release(): void;

                public acquire(param0: number): void;

                public getQueuedThreads(): java.util.Collection;

                public constructor(param0: number, param1: boolean);

                public release(param0: number): void;

                public availablePermits(): number;

                public tryAcquire(param0: number, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public drainPermits(): number;

                public toString(): string;

                public hasQueuedThreads(): boolean;

                public acquireUninterruptibly(): void;
                public acquireUninterruptibly(param0: number): void;

                public tryAcquire(): boolean;
                public tryAcquire(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                public constructor(param0: number);

                public isFair(): boolean;

                public acquire(): void;

                public tryAcquire(param0: number): boolean;

                public getQueueLength(): number;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class SynchronousQueue extends java.util.AbstractQueue implements java.util.concurrent.BlockingQueue, java.io.Serializable {
                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public constructor(param0: boolean);

                public remove(): java.lang.Object;

                public retainAll(param0: java.util.Collection): boolean;

                public constructor();

                public toArray(): native.Array<java.lang.Object>;

                public put(param0: java.lang.Object): void;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public take(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public element(): java.lang.Object;

                public iterator(): java.util.Iterator;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public remainingCapacity(): number;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.lang.Thread.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ThreadFactory extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.concurrent.ThreadFactory interface with the provided implementation.
                 */
                public constructor(implementation: {
                    newThread(param0: java.lang.Runnable): java.lang.Thread;
                });

                public newThread(param0: java.lang.Runnable): java.lang.Thread;
            }
        }
    }
}

declare module java {
    export module util {
        export module concurrent {
            export class ThreadLocalRandom extends java.util.Random {
                public nextInt(): number;

                public nextLong(): number;
                public nextLong(param0: number): number;

                public nextInt(param0: number): number;

                public nextDouble(param0: number): number;

                public next(param0: number): number;

                public nextLong(param0: number, param1: number): number;

                public nextDouble(param0: number, param1: number): number;

                public setSeed(param0: number): void;

                public nextDouble(): number;

                public static current(): java.util.concurrent.ThreadLocalRandom;

                public nextInt(param0: number, param1: number): number;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Runnable.d.ts" />
/// <reference path="./java.lang.Thread.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.List.d.ts" />
/// <reference path="./java.util.concurrent.BlockingQueue.d.ts" />
/// <reference path="./java.util.concurrent.Callable.d.ts" />
/// <reference path="./java.util.concurrent.Future.d.ts" />
/// <reference path="./java.util.concurrent.RejectedExecutionHandler.d.ts" />
/// <reference path="./java.util.concurrent.ThreadFactory.d.ts" />
/// <reference path="./java.util.concurrent.ThreadPoolExecutor.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class ThreadPoolExecutor extends java.util.concurrent.AbstractExecutorService {
                public setMaximumPoolSize(param0: number): void;

                public setRejectedExecutionHandler(param0: java.util.concurrent.RejectedExecutionHandler): void;

                public afterExecute(param0: java.lang.Runnable, param1: java.lang.Throwable): void;

                public isTerminated(): boolean;

                public setCorePoolSize(param0: number): void;

                public allowsCoreThreadTimeOut(): boolean;

                public allowCoreThreadTimeOut(param0: boolean): void;

                public finalize(): void;

                public submit(param0: java.lang.Runnable): java.util.concurrent.Future;
                public submit(param0: java.lang.Runnable, param1: java.lang.Object): java.util.concurrent.Future;

                public isTerminating(): boolean;

                public constructor();
                public constructor(param0: number, param1: number, param2: number, param3: java.util.concurrent.TimeUnit, param4: java.util.concurrent.BlockingQueue, param5: java.util.concurrent.RejectedExecutionHandler);
                public constructor(param0: number, param1: number, param2: number, param3: java.util.concurrent.TimeUnit, param4: java.util.concurrent.BlockingQueue);

                public awaitTermination(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                public submit(param0: java.util.concurrent.Callable): java.util.concurrent.Future;

                public shutdown(): void;

                public getActiveCount(): number;

                public isShutdown(): boolean;

                public shutdownNow(): java.util.List;

                public remove(param0: java.lang.Runnable): boolean;

                public beforeExecute(param0: java.lang.Thread, param1: java.lang.Runnable): void;

                public getPoolSize(): number;

                public setKeepAliveTime(param0: number, param1: java.util.concurrent.TimeUnit): void;

                public invokeAll(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.util.List;

                public getCorePoolSize(): number;

                public prestartAllCoreThreads(): number;

                public toString(): string;

                public constructor(param0: number, param1: number, param2: number, param3: java.util.concurrent.TimeUnit, param4: java.util.concurrent.BlockingQueue, param5: java.util.concurrent.ThreadFactory);

                public getMaximumPoolSize(): number;

                public getKeepAliveTime(param0: java.util.concurrent.TimeUnit): number;

                public invokeAny(param0: java.util.Collection): java.lang.Object;
                public invokeAny(param0: java.util.Collection, param1: number, param2: java.util.concurrent.TimeUnit): java.lang.Object;

                public purge(): void;

                public getCompletedTaskCount(): number;

                public terminated(): void;

                public execute(param0: java.lang.Runnable): void;

                public getLargestPoolSize(): number;

                public setThreadFactory(param0: java.util.concurrent.ThreadFactory): void;

                public getTaskCount(): number;

                public getQueue(): java.util.concurrent.BlockingQueue;

                public invokeAll(param0: java.util.Collection): java.util.List;

                public prestartCoreThread(): boolean;

                public constructor(param0: number, param1: number, param2: number, param3: java.util.concurrent.TimeUnit, param4: java.util.concurrent.BlockingQueue, param5: java.util.concurrent.ThreadFactory, param6: java.util.concurrent.RejectedExecutionHandler);

                public getRejectedExecutionHandler(): java.util.concurrent.RejectedExecutionHandler;

                public getThreadFactory(): java.util.concurrent.ThreadFactory;
            }
            export module ThreadPoolExecutor {
                export class AbortPolicy extends java.lang.Object implements java.util.concurrent.RejectedExecutionHandler {
                    public constructor();

                    public rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor): void;
                }
                export class CallerRunsPolicy extends java.lang.Object implements java.util.concurrent.RejectedExecutionHandler {
                    public constructor();

                    public rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor): void;
                }
                export class DiscardOldestPolicy extends java.lang.Object implements java.util.concurrent.RejectedExecutionHandler {
                    public constructor();

                    public rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor): void;
                }
                export class DiscardPolicy extends java.lang.Object implements java.util.concurrent.RejectedExecutionHandler {
                    public constructor();

                    public rejectedExecution(param0: java.lang.Runnable, param1: java.util.concurrent.ThreadPoolExecutor): void;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Enum.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Thread.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class TimeUnit extends java.lang.Enum {
                public static DAYS: java.util.concurrent.TimeUnit;
                public static HOURS: java.util.concurrent.TimeUnit;
                public static MICROSECONDS: java.util.concurrent.TimeUnit;
                public static MILLISECONDS: java.util.concurrent.TimeUnit;
                public static MINUTES: java.util.concurrent.TimeUnit;
                public static NANOSECONDS: java.util.concurrent.TimeUnit;
                public static SECONDS: java.util.concurrent.TimeUnit;

                public toSeconds(param0: number): number;

                public toMinutes(param0: number): number;

                public timedWait(param0: java.lang.Object, param1: number): void;

                public static values(): native.Array<java.util.concurrent.TimeUnit>;

                public toMicros(param0: number): number;

                public toNanos(param0: number): number;

                public toMillis(param0: number): number;

                public static valueOf(param0: string): java.util.concurrent.TimeUnit;

                public sleep(param0: number): void;

                public timedJoin(param0: java.lang.Thread, param1: number): void;

                public toDays(param0: number): number;

                public static valueOf(param0: java.lang.Class, param1: string): java.lang.Enum;

                public convert(param0: number, param1: java.util.concurrent.TimeUnit): number;

                public toHours(param0: number): number;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class TimeoutException extends java.lang.Exception {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Iterator.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export class TransferQueue extends java.lang.Object implements java.util.concurrent.BlockingQueue {
                /**
                 * Constructs a new instance of the java.util.concurrent.TransferQueue interface with the provided implementation.
                 */
                public constructor(implementation: {
                    tryTransfer(param0: java.lang.Object): boolean;
                    transfer(param0: java.lang.Object): void;
                    tryTransfer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                    hasWaitingConsumer(): boolean;
                    getWaitingConsumerCount(): number;
                    add(param0: java.lang.Object): boolean;
                    offer(param0: java.lang.Object): boolean;
                    put(param0: java.lang.Object): void;
                    offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;
                    take(): java.lang.Object;
                    poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;
                    remainingCapacity(): number;
                    remove(param0: java.lang.Object): boolean;
                    contains(param0: java.lang.Object): boolean;
                    drainTo(param0: java.util.Collection): number;
                    drainTo(param0: java.util.Collection, param1: number): number;
                    add(param0: java.lang.Object): boolean;
                    offer(param0: java.lang.Object): boolean;
                    remove(): java.lang.Object;
                    poll(): java.lang.Object;
                    element(): java.lang.Object;
                    peek(): java.lang.Object;
                    add(param0: java.lang.Object): boolean;
                    addAll(param0: java.util.Collection): boolean;
                    clear(): void;
                    contains(param0: java.lang.Object): boolean;
                    containsAll(param0: java.util.Collection): boolean;
                    equals(param0: java.lang.Object): boolean;
                    hashCode(): number;
                    isEmpty(): boolean;
                    iterator(): java.util.Iterator;
                    remove(param0: java.lang.Object): boolean;
                    removeAll(param0: java.util.Collection): boolean;
                    retainAll(param0: java.util.Collection): boolean;
                    size(): number;
                    toArray(): native.Array<java.lang.Object>;
                    toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;
                    iterator(): java.util.Iterator;
                });

                public drainTo(param0: java.util.Collection): number;

                public equals(param0: java.lang.Object): boolean;

                public poll(): java.lang.Object;

                public remove(): java.lang.Object;

                public hasWaitingConsumer(): boolean;

                public retainAll(param0: java.util.Collection): boolean;

                public toArray(): native.Array<java.lang.Object>;

                public put(param0: java.lang.Object): void;

                public hashCode(): number;

                public clear(): void;

                public contains(param0: java.lang.Object): boolean;

                public offer(param0: java.lang.Object): boolean;

                public removeAll(param0: java.util.Collection): boolean;

                public isEmpty(): boolean;

                public take(): java.lang.Object;

                public toArray(param0: native.Array<java.lang.Object>): native.Array<java.lang.Object>;

                public element(): java.lang.Object;

                public iterator(): java.util.Iterator;

                public drainTo(param0: java.util.Collection, param1: number): number;

                public offer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public poll(param0: number, param1: java.util.concurrent.TimeUnit): java.lang.Object;

                public size(): number;

                public transfer(param0: java.lang.Object): void;

                public getWaitingConsumerCount(): number;

                public peek(): java.lang.Object;

                public addAll(param0: java.util.Collection): boolean;

                public remainingCapacity(): number;

                public tryTransfer(param0: java.lang.Object): boolean;
                public tryTransfer(param0: java.lang.Object, param1: number, param2: java.util.concurrent.TimeUnit): boolean;

                public remove(param0: java.lang.Object): boolean;

                public add(param0: java.lang.Object): boolean;

                public containsAll(param0: java.util.Collection): boolean;
            }
        }
    }
}

declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicBoolean extends java.lang.Object implements java.io.Serializable {
                    public getAndSet(param0: boolean): boolean;

                    public toString(): string;

                    public constructor(param0: boolean);

                    public set(param0: boolean): void;

                    public constructor();

                    public lazySet(param0: boolean): void;

                    public get(): boolean;

                    public compareAndSet(param0: boolean, param1: boolean): boolean;

                    public weakCompareAndSet(param0: boolean, param1: boolean): boolean;
                }
            }
        }
    }
}

declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicInteger extends java.lang.Number implements java.io.Serializable {
                    public addAndGet(param0: number): number;

                    public doubleValue(): number;

                    public floatValue(): number;

                    public incrementAndGet(): number;

                    public compareAndSet(param0: number, param1: number): boolean;

                    public lazySet(param0: number): void;

                    public intValue(): number;

                    public getAndAdd(param0: number): number;

                    public decrementAndGet(): number;

                    public toString(): string;

                    public getAndIncrement(): number;

                    public constructor();

                    public set(param0: number): void;

                    public get(): number;

                    public weakCompareAndSet(param0: number, param1: number): boolean;

                    public longValue(): number;

                    public getAndSet(param0: number): number;

                    public constructor(param0: number);

                    public getAndDecrement(): number;
                }
            }
        }
    }
}

declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicIntegerArray extends java.lang.Object implements java.io.Serializable {
                    public incrementAndGet(param0: number): number;

                    public addAndGet(param0: number, param1: number): number;

                    public weakCompareAndSet(param0: number, param1: number, param2: number): boolean;

                    public getAndSet(param0: number, param1: number): number;

                    public getAndDecrement(param0: number): number;

                    public length(): number;

                    public compareAndSet(param0: number, param1: number, param2: number): boolean;

                    public get(param0: number): number;

                    public toString(): string;

                    public constructor(param0: native.Array<number>);

                    public set(param0: number, param1: number): void;

                    public getAndAdd(param0: number, param1: number): number;

                    public lazySet(param0: number, param1: number): void;

                    public decrementAndGet(param0: number): number;

                    public getAndIncrement(param0: number): number;

                    public constructor(param0: number);
                }
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export abstract class AtomicIntegerFieldUpdater extends java.lang.Object {
                    public get(param0: java.lang.Object): number;

                    public getAndSet(param0: java.lang.Object, param1: number): number;

                    public set(param0: java.lang.Object, param1: number): void;

                    public weakCompareAndSet(param0: java.lang.Object, param1: number, param2: number): boolean;

                    public lazySet(param0: java.lang.Object, param1: number): void;

                    public compareAndSet(param0: java.lang.Object, param1: number, param2: number): boolean;

                    public addAndGet(param0: java.lang.Object, param1: number): number;

                    public getAndDecrement(param0: java.lang.Object): number;

                    public getAndIncrement(param0: java.lang.Object): number;

                    public constructor();

                    public decrementAndGet(param0: java.lang.Object): number;

                    public static newUpdater(param0: java.lang.Class, param1: string): java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

                    public getAndAdd(param0: java.lang.Object, param1: number): number;

                    public incrementAndGet(param0: java.lang.Object): number;
                }
            }
        }
    }
}

declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicLong extends java.lang.Number implements java.io.Serializable {
                    public addAndGet(param0: number): number;

                    public doubleValue(): number;

                    public floatValue(): number;

                    public incrementAndGet(): number;

                    public compareAndSet(param0: number, param1: number): boolean;

                    public lazySet(param0: number): void;

                    public intValue(): number;

                    public getAndAdd(param0: number): number;

                    public decrementAndGet(): number;

                    public toString(): string;

                    public getAndIncrement(): number;

                    public constructor();

                    public set(param0: number): void;

                    public get(): number;

                    public weakCompareAndSet(param0: number, param1: number): boolean;

                    public longValue(): number;

                    public getAndSet(param0: number): number;

                    public constructor(param0: number);

                    public getAndDecrement(): number;
                }
            }
        }
    }
}

declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicLongArray extends java.lang.Object implements java.io.Serializable {
                    public incrementAndGet(param0: number): number;

                    public addAndGet(param0: number, param1: number): number;

                    public weakCompareAndSet(param0: number, param1: number, param2: number): boolean;

                    public getAndSet(param0: number, param1: number): number;

                    public getAndDecrement(param0: number): number;

                    public length(): number;

                    public compareAndSet(param0: number, param1: number, param2: number): boolean;

                    public get(param0: number): number;

                    public toString(): string;

                    public constructor(param0: native.Array<number>);

                    public set(param0: number, param1: number): void;

                    public getAndAdd(param0: number, param1: number): number;

                    public lazySet(param0: number, param1: number): void;

                    public decrementAndGet(param0: number): number;

                    public getAndIncrement(param0: number): number;

                    public constructor(param0: number);
                }
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export abstract class AtomicLongFieldUpdater extends java.lang.Object {
                    public get(param0: java.lang.Object): number;

                    public getAndSet(param0: java.lang.Object, param1: number): number;

                    public set(param0: java.lang.Object, param1: number): void;

                    public weakCompareAndSet(param0: java.lang.Object, param1: number, param2: number): boolean;

                    public lazySet(param0: java.lang.Object, param1: number): void;

                    public compareAndSet(param0: java.lang.Object, param1: number, param2: number): boolean;

                    public addAndGet(param0: java.lang.Object, param1: number): number;

                    public static newUpdater(param0: java.lang.Class, param1: string): java.util.concurrent.atomic.AtomicLongFieldUpdater;

                    public getAndDecrement(param0: java.lang.Object): number;

                    public getAndIncrement(param0: java.lang.Object): number;

                    public constructor();

                    public decrementAndGet(param0: java.lang.Object): number;

                    public getAndAdd(param0: java.lang.Object, param1: number): number;

                    public incrementAndGet(param0: java.lang.Object): number;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicMarkableReference extends java.lang.Object {
                    public getReference(): java.lang.Object;

                    public compareAndSet(param0: java.lang.Object, param1: java.lang.Object, param2: boolean, param3: boolean): boolean;

                    public get(param0: native.Array<boolean>): java.lang.Object;

                    public set(param0: java.lang.Object, param1: boolean): void;

                    public attemptMark(param0: java.lang.Object, param1: boolean): boolean;

                    public constructor(param0: java.lang.Object, param1: boolean);

                    public weakCompareAndSet(param0: java.lang.Object, param1: java.lang.Object, param2: boolean, param3: boolean): boolean;

                    public isMarked(): boolean;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicReference extends java.lang.Object implements java.io.Serializable {
                    public lazySet(param0: java.lang.Object): void;

                    public toString(): string;

                    public constructor();

                    public weakCompareAndSet(param0: java.lang.Object, param1: java.lang.Object): boolean;

                    public get(): java.lang.Object;

                    public constructor(param0: java.lang.Object);

                    public getAndSet(param0: java.lang.Object): java.lang.Object;

                    public compareAndSet(param0: java.lang.Object, param1: java.lang.Object): boolean;

                    public set(param0: java.lang.Object): void;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicReferenceArray extends java.lang.Object implements java.io.Serializable {
                    public lazySet(param0: number, param1: java.lang.Object): void;

                    public toString(): string;

                    public weakCompareAndSet(param0: number, param1: java.lang.Object, param2: java.lang.Object): boolean;

                    public constructor(param0: native.Array<java.lang.Object>);

                    public get(param0: number): java.lang.Object;

                    public compareAndSet(param0: number, param1: java.lang.Object, param2: java.lang.Object): boolean;

                    public set(param0: number, param1: java.lang.Object): void;

                    public getAndSet(param0: number, param1: java.lang.Object): java.lang.Object;

                    public constructor(param0: number);

                    public length(): number;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export abstract class AtomicReferenceFieldUpdater extends java.lang.Object {
                    public lazySet(param0: java.lang.Object, param1: java.lang.Object): void;

                    public static newUpdater(param0: java.lang.Class, param1: java.lang.Class, param2: string): java.util.concurrent.atomic.AtomicReferenceFieldUpdater;

                    public getAndSet(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                    public weakCompareAndSet(param0: java.lang.Object, param1: java.lang.Object, param2: java.lang.Object): boolean;

                    public constructor();

                    public compareAndSet(param0: java.lang.Object, param1: java.lang.Object, param2: java.lang.Object): boolean;

                    public set(param0: java.lang.Object, param1: java.lang.Object): void;

                    public get(param0: java.lang.Object): java.lang.Object;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicStampedReference extends java.lang.Object {
                    public getReference(): java.lang.Object;

                    public get(param0: native.Array<number>): java.lang.Object;

                    public set(param0: java.lang.Object, param1: number): void;

                    public attemptStamp(param0: java.lang.Object, param1: number): boolean;

                    public getStamp(): number;

                    public compareAndSet(param0: java.lang.Object, param1: java.lang.Object, param2: number, param3: number): boolean;

                    public constructor(param0: java.lang.Object, param1: number);

                    public weakCompareAndSet(param0: java.lang.Object, param1: java.lang.Object, param2: number, param3: number): boolean;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Thread.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module locks {
                export abstract class AbstractOwnableSynchronizer extends java.lang.Object implements java.io.Serializable {
                    public constructor();

                    public getExclusiveOwnerThread(): java.lang.Thread;

                    public setExclusiveOwnerThread(param0: java.lang.Thread): void;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Thread.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
/// <reference path="./java.util.concurrent.locks.AbstractQueuedLongSynchronizer.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module locks {
                export abstract class AbstractQueuedLongSynchronizer extends java.util.concurrent.locks.AbstractOwnableSynchronizer implements java.io.Serializable {
                    public getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject): java.util.Collection;

                    public getQueuedThreads(): java.util.Collection;

                    public release(param0: number): boolean;

                    public tryReleaseShared(param0: number): boolean;

                    public acquireShared(param0: number): void;

                    public owns(param0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject): boolean;

                    public acquire(param0: number): void;

                    public compareAndSetState(param0: number, param1: number): boolean;

                    public toString(): string;

                    public tryAcquire(param0: number): boolean;

                    public constructor();

                    public getFirstQueuedThread(): java.lang.Thread;

                    public tryAcquireSharedNanos(param0: number, param1: number): boolean;

                    public setState(param0: number): void;

                    public releaseShared(param0: number): boolean;

                    public tryAcquireNanos(param0: number, param1: number): boolean;

                    public acquireSharedInterruptibly(param0: number): void;

                    public getQueueLength(): number;

                    public hasQueuedPredecessors(): boolean;

                    public getSharedQueuedThreads(): java.util.Collection;

                    public getExclusiveQueuedThreads(): java.util.Collection;

                    public hasQueuedThreads(): boolean;

                    public hasContended(): boolean;

                    public hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject): boolean;

                    public tryAcquireShared(param0: number): number;

                    public isQueued(param0: java.lang.Thread): boolean;

                    public acquireInterruptibly(param0: number): void;

                    public tryRelease(param0: number): boolean;

                    public getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject): number;

                    public isHeldExclusively(): boolean;

                    public getState(): number;
                }
                export module AbstractQueuedLongSynchronizer {
                    export class ConditionObject extends java.lang.Object implements java.util.concurrent.locks.Condition, java.io.Serializable {
                        public await(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                        public constructor(param0: java.util.concurrent.locks.AbstractQueuedLongSynchronizer);

                        public awaitUninterruptibly(): void;

                        public getWaitingThreads(): java.util.Collection;

                        public signalAll(): void;

                        public awaitNanos(param0: number): number;

                        public hasWaiters(): boolean;

                        public getWaitQueueLength(): number;

                        public signal(): void;

                        public await(): void;

                        public awaitUntil(param0: java.util.Date): boolean;
                    }
                }
            }
        }
    }
}

/// <reference path="./java.lang.Thread.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
/// <reference path="./java.util.concurrent.locks.AbstractQueuedSynchronizer.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module locks {
                export abstract class AbstractQueuedSynchronizer extends java.util.concurrent.locks.AbstractOwnableSynchronizer implements java.io.Serializable {
                    public getQueuedThreads(): java.util.Collection;

                    public release(param0: number): boolean;

                    public tryReleaseShared(param0: number): boolean;

                    public acquireShared(param0: number): void;

                    public acquire(param0: number): void;

                    public compareAndSetState(param0: number, param1: number): boolean;

                    public toString(): string;

                    public tryAcquire(param0: number): boolean;

                    public constructor();

                    public getFirstQueuedThread(): java.lang.Thread;

                    public tryAcquireSharedNanos(param0: number, param1: number): boolean;

                    public setState(param0: number): void;

                    public releaseShared(param0: number): boolean;

                    public tryAcquireNanos(param0: number, param1: number): boolean;

                    public hasWaiters(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject): boolean;

                    public acquireSharedInterruptibly(param0: number): void;

                    public getQueueLength(): number;

                    public hasQueuedPredecessors(): boolean;

                    public getSharedQueuedThreads(): java.util.Collection;

                    public getExclusiveQueuedThreads(): java.util.Collection;

                    public hasQueuedThreads(): boolean;

                    public hasContended(): boolean;

                    public tryAcquireShared(param0: number): number;

                    public isQueued(param0: java.lang.Thread): boolean;

                    public owns(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject): boolean;

                    public acquireInterruptibly(param0: number): void;

                    public getWaitingThreads(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject): java.util.Collection;

                    public tryRelease(param0: number): boolean;

                    public getWaitQueueLength(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject): number;

                    public isHeldExclusively(): boolean;

                    public getState(): number;
                }
                export module AbstractQueuedSynchronizer {
                    export class ConditionObject extends java.lang.Object implements java.util.concurrent.locks.Condition, java.io.Serializable {
                        public await(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                        public awaitUninterruptibly(): void;

                        public getWaitingThreads(): java.util.Collection;

                        public signalAll(): void;

                        public awaitNanos(param0: number): number;

                        public hasWaiters(): boolean;

                        public getWaitQueueLength(): number;

                        public signal(): void;

                        public await(): void;

                        public awaitUntil(param0: java.util.Date): boolean;

                        public constructor(param0: java.util.concurrent.locks.AbstractQueuedSynchronizer);
                    }
                }
            }
        }
    }
}

/// <reference path="./java.util.Date.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module locks {
                export class Condition extends java.lang.Object {
                    /**
                     * Constructs a new instance of the java.util.concurrent.locks.Condition interface with the provided implementation.
                     */
                    public constructor(implementation: {
                        await(): void;
                        awaitUninterruptibly(): void;
                        awaitNanos(param0: number): number;
                        await(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                        awaitUntil(param0: java.util.Date): boolean;
                        signal(): void;
                        signalAll(): void;
                    });

                    public await(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                    public signal(): void;

                    public await(): void;

                    public awaitUninterruptibly(): void;

                    public signalAll(): void;

                    public awaitNanos(param0: number): number;

                    public awaitUntil(param0: java.util.Date): boolean;
                }
            }
        }
    }
}

/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
/// <reference path="./java.util.concurrent.locks.Condition.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module locks {
                export class Lock extends java.lang.Object {
                    /**
                     * Constructs a new instance of the java.util.concurrent.locks.Lock interface with the provided implementation.
                     */
                    public constructor(implementation: {
                        lock(): void;
                        lockInterruptibly(): void;
                        tryLock(): boolean;
                        tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                        unlock(): void;
                        newCondition(): java.util.concurrent.locks.Condition;
                    });

                    public lockInterruptibly(): void;

                    public unlock(): void;

                    public newCondition(): java.util.concurrent.locks.Condition;

                    public lock(): void;

                    public tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;
                    public tryLock(): boolean;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.Thread.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module locks {
                export class LockSupport extends java.lang.Object {
                    public static park(param0: java.lang.Object): void;

                    public static parkUntil(param0: java.lang.Object, param1: number): void;

                    public static parkNanos(param0: number): void;

                    public static getBlocker(param0: java.lang.Thread): java.lang.Object;

                    public static parkUntil(param0: number): void;

                    public static parkNanos(param0: java.lang.Object, param1: number): void;

                    public static park(): void;

                    public static unpark(param0: java.lang.Thread): void;
                }
            }
        }
    }
}

/// <reference path="./java.util.concurrent.locks.Lock.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module locks {
                export class ReadWriteLock extends java.lang.Object {
                    /**
                     * Constructs a new instance of the java.util.concurrent.locks.ReadWriteLock interface with the provided implementation.
                     */
                    public constructor(implementation: {
                        readLock(): java.util.concurrent.locks.Lock;
                        writeLock(): java.util.concurrent.locks.Lock;
                    });

                    public readLock(): java.util.concurrent.locks.Lock;

                    public writeLock(): java.util.concurrent.locks.Lock;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Thread.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
/// <reference path="./java.util.concurrent.locks.Condition.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module locks {
                export class ReentrantLock extends java.lang.Object implements java.util.concurrent.locks.Lock, java.io.Serializable {
                    public lockInterruptibly(): void;

                    public isHeldByCurrentThread(): boolean;

                    public isFair(): boolean;

                    public getQueuedThreads(): java.util.Collection;

                    public getQueueLength(): number;

                    public tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                    public getWaitQueueLength(param0: java.util.concurrent.locks.Condition): number;

                    public getHoldCount(): number;

                    public tryLock(): boolean;

                    public hasQueuedThreads(): boolean;

                    public isLocked(): boolean;

                    public unlock(): void;

                    public toString(): string;

                    public constructor(param0: boolean);

                    public newCondition(): java.util.concurrent.locks.Condition;

                    public lock(): void;

                    public constructor();

                    public hasWaiters(param0: java.util.concurrent.locks.Condition): boolean;

                    public getOwner(): java.lang.Thread;

                    public hasQueuedThread(param0: java.lang.Thread): boolean;

                    public getWaitingThreads(param0: java.util.concurrent.locks.Condition): java.util.Collection;
                }
            }
        }
    }
}

/// <reference path="./java.lang.Thread.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.concurrent.TimeUnit.d.ts" />
/// <reference path="./java.util.concurrent.locks.Condition.d.ts" />
/// <reference path="./java.util.concurrent.locks.Lock.d.ts" />
/// <reference path="./java.util.concurrent.locks.ReentrantReadWriteLock.d.ts" />
declare module java {
    export module util {
        export module concurrent {
            export module locks {
                export class ReentrantReadWriteLock extends java.lang.Object implements java.util.concurrent.locks.ReadWriteLock, java.io.Serializable {
                    public getReadLockCount(): number;

                    public isFair(): boolean;

                    public getQueuedThreads(): java.util.Collection;

                    public getReadHoldCount(): number;

                    public getQueuedWriterThreads(): java.util.Collection;

                    public readLock(): java.util.concurrent.locks.Lock;

                    public getQueueLength(): number;

                    public getWaitQueueLength(param0: java.util.concurrent.locks.Condition): number;

                    public hasQueuedThreads(): boolean;

                    public readLock(): java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;

                    public toString(): string;

                    public constructor(param0: boolean);
                    public constructor();

                    public isWriteLocked(): boolean;

                    public getWriteHoldCount(): number;

                    public writeLock(): java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;

                    public hasWaiters(param0: java.util.concurrent.locks.Condition): boolean;

                    public getOwner(): java.lang.Thread;

                    public getQueuedReaderThreads(): java.util.Collection;

                    public isWriteLockedByCurrentThread(): boolean;

                    public writeLock(): java.util.concurrent.locks.Lock;

                    public hasQueuedThread(param0: java.lang.Thread): boolean;

                    public getWaitingThreads(param0: java.util.concurrent.locks.Condition): java.util.Collection;
                }
                export module ReentrantReadWriteLock {
                    export class ReadLock extends java.lang.Object implements java.util.concurrent.locks.Lock, java.io.Serializable {
                        public tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                        public unlock(): void;

                        public lockInterruptibly(): void;

                        public lock(): void;

                        public tryLock(): boolean;

                        public constructor(param0: java.util.concurrent.locks.ReentrantReadWriteLock);

                        public newCondition(): java.util.concurrent.locks.Condition;

                        public toString(): string;
                    }
                    export class WriteLock extends java.lang.Object implements java.util.concurrent.locks.Lock, java.io.Serializable {
                        public tryLock(param0: number, param1: java.util.concurrent.TimeUnit): boolean;

                        public unlock(): void;

                        public getHoldCount(): number;

                        public lockInterruptibly(): void;

                        public lock(): void;

                        public tryLock(): boolean;

                        public constructor(param0: java.util.concurrent.locks.ReentrantReadWriteLock);

                        public isHeldByCurrentThread(): boolean;

                        public newCondition(): java.util.concurrent.locks.Condition;

                        public toString(): string;
                    }
                }
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Collection.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.Set.d.ts" />
declare module java {
    export module util {
        export module jar {
            export class Attributes extends java.lang.Object implements java.lang.Cloneable, java.util.Map {
                public map: java.util.Map;

                public keySet(): java.util.Set;

                public containsKey(param0: java.lang.Object): boolean;

                public equals(param0: java.lang.Object): boolean;

                public getValue(param0: java.util.jar.Attributes.Name): string;

                public values(): java.util.Collection;

                public containsValue(param0: java.lang.Object): boolean;

                public put(param0: java.lang.Object, param1: java.lang.Object): java.lang.Object;

                public constructor(param0: java.util.jar.Attributes);

                public putAll(param0: java.util.Map): void;

                public getValue(param0: string): string;

                public entrySet(): java.util.Set;

                public clone(): java.lang.Object;

                public constructor();

                public get(param0: java.lang.Object): java.lang.Object;

                public size(): number;

                public putValue(param0: string, param1: string): string;

                public hashCode(): number;

                public clear(): void;

                public constructor(param0: number);

                public isEmpty(): boolean;

                public remove(param0: java.lang.Object): java.lang.Object;
            }
            export module Attributes {
                export class Name extends java.lang.Object {
                    public static CLASS_PATH: java.util.jar.Attributes.Name;
                    public static CONTENT_TYPE: java.util.jar.Attributes.Name;
                    public static EXTENSION_INSTALLATION: java.util.jar.Attributes.Name;
                    public static EXTENSION_LIST: java.util.jar.Attributes.Name;
                    public static EXTENSION_NAME: java.util.jar.Attributes.Name;
                    public static IMPLEMENTATION_TITLE: java.util.jar.Attributes.Name;
                    public static IMPLEMENTATION_URL: java.util.jar.Attributes.Name;
                    public static IMPLEMENTATION_VENDOR: java.util.jar.Attributes.Name;
                    public static IMPLEMENTATION_VENDOR_ID: java.util.jar.Attributes.Name;
                    public static IMPLEMENTATION_VERSION: java.util.jar.Attributes.Name;
                    public static MAIN_CLASS: java.util.jar.Attributes.Name;
                    public static MANIFEST_VERSION: java.util.jar.Attributes.Name;
                    public static SEALED: java.util.jar.Attributes.Name;
                    public static SIGNATURE_VERSION: java.util.jar.Attributes.Name;
                    public static SPECIFICATION_TITLE: java.util.jar.Attributes.Name;
                    public static SPECIFICATION_VENDOR: java.util.jar.Attributes.Name;
                    public static SPECIFICATION_VERSION: java.util.jar.Attributes.Name;

                    public toString(): string;

                    public constructor(param0: string);

                    public equals(param0: java.lang.Object): boolean;

                    public hashCode(): number;
                }
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.CodeSigner.d.ts" />
/// <reference path="./java.security.cert.Certificate.d.ts" />
/// <reference path="./java.util.jar.Attributes.d.ts" />
/// <reference path="./java.util.zip.ZipEntry.d.ts" />
declare module java {
    export module util {
        export module jar {
            export class JarEntry extends java.util.zip.ZipEntry {
                public constructor(param0: java.util.jar.JarEntry);

                public getAttributes(): java.util.jar.Attributes;

                public constructor(param0: java.util.zip.ZipEntry);

                public getCertificates(): native.Array<java.security.cert.Certificate>;

                public getCodeSigners(): native.Array<java.security.CodeSigner>;

                public constructor(param0: string);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module jar {
            export class JarException extends java.util.zip.ZipException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.jar.JarEntry.d.ts" />
/// <reference path="./java.util.jar.Manifest.d.ts" />
/// <reference path="./java.util.zip.ZipEntry.d.ts" />
declare module java {
    export module util {
        export module jar {
            export class JarFile extends java.util.zip.ZipFile {
                public static MANIFEST_NAME: string;

                public constructor(param0: java.io.File, param1: boolean, param2: number);

                public getJarEntry(param0: string): java.util.jar.JarEntry;

                public getManifest(): java.util.jar.Manifest;

                public entries(): java.util.Enumeration;

                public close(): void;

                public constructor(param0: java.io.File, param1: boolean);

                public getInputStream(param0: java.util.zip.ZipEntry): java.io.InputStream;

                public constructor(param0: java.io.File);
                public constructor(param0: string, param1: boolean);

                public getEntry(param0: string): java.util.zip.ZipEntry;

                public constructor(param0: string);
                public constructor(param0: java.io.File, param1: number);
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.jar.JarEntry.d.ts" />
/// <reference path="./java.util.jar.Manifest.d.ts" />
/// <reference path="./java.util.zip.Inflater.d.ts" />
/// <reference path="./java.util.zip.ZipEntry.d.ts" />
declare module java {
    export module util {
        export module jar {
            export class JarInputStream extends java.util.zip.ZipInputStream {
                public constructor(param0: java.io.InputStream, param1: java.util.zip.Inflater, param2: number);

                public close(): void;

                public read(param0: native.Array<number>, param1: number, param2: number): number;

                public closeEntry(): void;

                public createZipEntry(param0: string): java.util.zip.ZipEntry;

                public constructor(param0: java.io.InputStream);
                public constructor(param0: java.io.InputStream, param1: java.util.zip.Inflater);
                public constructor();

                public getNextJarEntry(): java.util.jar.JarEntry;

                public getManifest(): java.util.jar.Manifest;

                public read(): number;
                public read(param0: native.Array<number>): number;

                public getNextEntry(): java.util.zip.ZipEntry;

                public constructor(param0: java.io.InputStream, param1: boolean);
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.util.jar.Manifest.d.ts" />
/// <reference path="./java.util.zip.Deflater.d.ts" />
/// <reference path="./java.util.zip.ZipEntry.d.ts" />
declare module java {
    export module util {
        export module jar {
            export class JarOutputStream extends java.util.zip.ZipOutputStream {
                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: boolean);
                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: number, param3: boolean);

                public close(): void;

                public constructor(param0: java.io.OutputStream);
                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: number);
                public constructor(param0: java.io.OutputStream, param1: java.util.jar.Manifest);
                public constructor(param0: java.io.OutputStream, param1: boolean);
                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater);
                public constructor();

                public putNextEntry(param0: java.util.zip.ZipEntry): void;

                public flush(): void;
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Map.d.ts" />
/// <reference path="./java.util.jar.Attributes.d.ts" />
declare module java {
    export module util {
        export module jar {
            export class Manifest extends java.lang.Object implements java.lang.Cloneable {
                public getMainAttributes(): java.util.jar.Attributes;

                public getAttributes(param0: string): java.util.jar.Attributes;

                public equals(param0: java.lang.Object): boolean;

                public getEntries(): java.util.Map;

                public write(param0: java.io.OutputStream): void;

                public hashCode(): number;

                public read(param0: java.io.InputStream): void;

                public clear(): void;

                public constructor(param0: java.io.InputStream);

                public clone(): java.lang.Object;

                public constructor(param0: java.util.jar.Manifest);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.beans.PropertyChangeListener.d.ts" />
/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.util.SortedMap.d.ts" />
/// <reference path="./java.util.jar.JarFile.d.ts" />
/// <reference path="./java.util.jar.JarInputStream.d.ts" />
/// <reference path="./java.util.jar.JarOutputStream.d.ts" />
declare module java {
    export module util {
        export module jar {
            export abstract class Pack200 extends java.lang.Object {
                public static newUnpacker(): java.util.jar.Pack200.Unpacker;

                public static newPacker(): java.util.jar.Pack200.Packer;
            }
            export module Pack200 {
                export class Packer extends java.lang.Object {
                    /**
                     * Constructs a new instance of the java.util.jar.Pack200$Packer interface with the provided implementation.
                     */
                    public constructor(implementation: {
                        properties(): java.util.SortedMap;
                        pack(param0: java.util.jar.JarFile, param1: java.io.OutputStream): void;
                        pack(param0: java.util.jar.JarInputStream, param1: java.io.OutputStream): void;
                        addPropertyChangeListener(param0: java.beans.PropertyChangeListener): void;
                        removePropertyChangeListener(param0: java.beans.PropertyChangeListener): void;
                    });

                    public static CODE_ATTRIBUTE_PFX: string;
                    public static EFFORT: string;
                    public static FIELD_ATTRIBUTE_PFX: string;
                    public static PASS: string;
                    public static DEFLATE_HINT: string;
                    public static PROGRESS: string;
                    public static UNKNOWN_ATTRIBUTE: string;
                    public static KEEP_FILE_ORDER: string;
                    public static ERROR: string;
                    public static FALSE: string;
                    public static STRIP: string;
                    public static MODIFICATION_TIME: string;
                    public static PASS_FILE_PFX: string;
                    public static SEGMENT_LIMIT: string;
                    public static KEEP: string;
                    public static TRUE: string;
                    public static METHOD_ATTRIBUTE_PFX: string;
                    public static LATEST: string;
                    public static CLASS_ATTRIBUTE_PFX: string;

                    public removePropertyChangeListener(param0: java.beans.PropertyChangeListener): void;

                    public properties(): java.util.SortedMap;

                    public addPropertyChangeListener(param0: java.beans.PropertyChangeListener): void;

                    public pack(param0: java.util.jar.JarInputStream, param1: java.io.OutputStream): void;
                    public pack(param0: java.util.jar.JarFile, param1: java.io.OutputStream): void;
                }
                export class Unpacker extends java.lang.Object {
                    /**
                     * Constructs a new instance of the java.util.jar.Pack200$Unpacker interface with the provided implementation.
                     */
                    public constructor(implementation: {
                        properties(): java.util.SortedMap;
                        unpack(param0: java.io.InputStream, param1: java.util.jar.JarOutputStream): void;
                        unpack(param0: java.io.File, param1: java.util.jar.JarOutputStream): void;
                        addPropertyChangeListener(param0: java.beans.PropertyChangeListener): void;
                        removePropertyChangeListener(param0: java.beans.PropertyChangeListener): void;
                    });

                    public static DEFLATE_HINT: string;
                    public static PROGRESS: string;
                    public static KEEP: string;
                    public static TRUE: string;
                    public static FALSE: string;

                    public removePropertyChangeListener(param0: java.beans.PropertyChangeListener): void;

                    public unpack(param0: java.io.File, param1: java.util.jar.JarOutputStream): void;

                    public properties(): java.util.SortedMap;

                    public unpack(param0: java.io.InputStream, param1: java.util.jar.JarOutputStream): void;

                    public addPropertyChangeListener(param0: java.beans.PropertyChangeListener): void;
                }
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.util.logging.Formatter.d.ts" />
/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class ConsoleHandler extends java.util.logging.StreamHandler {
                public close(): void;

                public publish(param0: java.util.logging.LogRecord): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.logging.Formatter);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Exception.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class ErrorManager extends java.lang.Object {
                public static CLOSE_FAILURE: number;
                public static FLUSH_FAILURE: number;
                public static FORMAT_FAILURE: number;
                public static GENERIC_FAILURE: number;
                public static OPEN_FAILURE: number;
                public static WRITE_FAILURE: number;

                public error(param0: string, param1: java.lang.Exception, param2: number): void;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.logging.Formatter.d.ts" />
/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class FileHandler extends java.util.logging.StreamHandler {
                public close(): void;

                public constructor(param0: string, param1: boolean);
                public constructor(param0: string, param1: number, param2: number);
                public constructor(param0: string, param1: number, param2: number, param3: boolean);

                public publish(param0: java.util.logging.LogRecord): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.logging.Formatter);
                public constructor(param0: string);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class Filter extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.logging.Filter interface with the provided implementation.
                 */
                public constructor(implementation: {
                    isLoggable(param0: java.util.logging.LogRecord): boolean;
                });

                public isLoggable(param0: java.util.logging.LogRecord): boolean;
            }
        }
    }
}

/// <reference path="./java.util.logging.Handler.d.ts" />
/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export abstract class Formatter extends java.lang.Object {
                public formatMessage(param0: java.util.logging.LogRecord): string;

                public format(param0: java.util.logging.LogRecord): string;

                public getHead(param0: java.util.logging.Handler): string;

                public getTail(param0: java.util.logging.Handler): string;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.lang.Exception.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.logging.ErrorManager.d.ts" />
/// <reference path="./java.util.logging.Filter.d.ts" />
/// <reference path="./java.util.logging.Formatter.d.ts" />
/// <reference path="./java.util.logging.Level.d.ts" />
/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export abstract class Handler extends java.lang.Object {
                public getEncoding(): string;

                public close(): void;

                public setFilter(param0: java.util.logging.Filter): void;

                public getErrorManager(): java.util.logging.ErrorManager;

                public publish(param0: java.util.logging.LogRecord): void;

                public getFormatter(): java.util.logging.Formatter;

                public setLevel(param0: java.util.logging.Level): void;

                public constructor();

                public flush(): void;

                public getLevel(): java.util.logging.Level;

                public getFilter(): java.util.logging.Filter;

                public isLoggable(param0: java.util.logging.LogRecord): boolean;

                public setErrorManager(param0: java.util.logging.ErrorManager): void;

                public setFormatter(param0: java.util.logging.Formatter): void;

                public reportError(param0: string, param1: java.lang.Exception, param2: number): void;

                public setEncoding(param0: string): void;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class Level extends java.lang.Object implements java.io.Serializable {
                public static ALL: java.util.logging.Level;
                public static CONFIG: java.util.logging.Level;
                public static FINE: java.util.logging.Level;
                public static FINER: java.util.logging.Level;
                public static FINEST: java.util.logging.Level;
                public static INFO: java.util.logging.Level;
                public static OFF: java.util.logging.Level;
                public static SEVERE: java.util.logging.Level;
                public static WARNING: java.util.logging.Level;

                public constructor(param0: string, param1: number, param2: string);

                public equals(param0: java.lang.Object): boolean;

                public getLocalizedName(): string;

                public hashCode(): number;

                public constructor(param0: string, param1: number);

                public intValue(): number;

                public getName(): string;

                public getResourceBundleName(): string;

                public static parse(param0: string): java.util.logging.Level;

                public toString(): string;
            }
        }
    }
}

/// <reference path="./java.beans.PropertyChangeListener.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.logging.Logger.d.ts" />
/// <reference path="./java.util.logging.LoggingMXBean.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class LogManager extends java.lang.Object {
                public static LOGGING_MXBEAN_NAME: string;

                public getLoggerNames(): java.util.Enumeration;

                public static getLogManager(): java.util.logging.LogManager;

                public getLogger(param0: string): java.util.logging.Logger;

                public addPropertyChangeListener(param0: java.beans.PropertyChangeListener): void;

                public constructor();

                public checkAccess(): void;

                public removePropertyChangeListener(param0: java.beans.PropertyChangeListener): void;

                public reset(): void;

                public getProperty(param0: string): string;

                public readConfiguration(param0: java.io.InputStream): void;

                public static getLoggingMXBean(): java.util.logging.LoggingMXBean;

                public readConfiguration(): void;

                public addLogger(param0: java.util.logging.Logger): boolean;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.ResourceBundle.d.ts" />
/// <reference path="./java.util.logging.Level.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class LogRecord extends java.lang.Object implements java.io.Serializable {
                public constructor(param0: java.util.logging.Level, param1: string);

                public getThrown(): java.lang.Throwable;

                public getThreadID(): number;

                public setSourceMethodName(param0: string): void;

                public setThreadID(param0: number): void;

                public setThrown(param0: java.lang.Throwable): void;

                public getSourceMethodName(): string;

                public getLevel(): java.util.logging.Level;

                public setSequenceNumber(param0: number): void;

                public setResourceBundleName(param0: string): void;

                public getSourceClassName(): string;

                public setMessage(param0: string): void;

                public getMessage(): string;

                public getParameters(): native.Array<java.lang.Object>;

                public getMillis(): number;

                public setResourceBundle(param0: java.util.ResourceBundle): void;

                public getResourceBundleName(): string;

                public setLevel(param0: java.util.logging.Level): void;

                public setSourceClassName(param0: string): void;

                public getResourceBundle(): java.util.ResourceBundle;

                public getLoggerName(): string;

                public setMillis(param0: number): void;

                public setParameters(param0: native.Array<java.lang.Object>): void;

                public getSequenceNumber(): number;

                public setLoggerName(param0: string): void;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
/// <reference path="./java.util.ResourceBundle.d.ts" />
/// <reference path="./java.util.logging.Filter.d.ts" />
/// <reference path="./java.util.logging.Handler.d.ts" />
/// <reference path="./java.util.logging.Level.d.ts" />
/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class Logger extends java.lang.Object {
                public static GLOBAL_LOGGER_NAME: string;
                public static global: java.util.logging.Logger;

                public config(param0: string): void;

                public logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: native.Array<java.lang.Object>): void;

                public warning(param0: string): void;

                public setUseParentHandlers(param0: boolean): void;

                public log(param0: java.util.logging.Level, param1: string): void;
                public log(param0: java.util.logging.Level, param1: string, param2: java.lang.Object): void;

                public logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string, param5: java.lang.Object): void;

                public addHandler(param0: java.util.logging.Handler): void;

                public getLevel(): java.util.logging.Level;

                public setParent(param0: java.util.logging.Logger): void;

                public logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string): void;

                public static getLogger(param0: string): java.util.logging.Logger;

                public getFilter(): java.util.logging.Filter;

                public exiting(param0: string, param1: string, param2: java.lang.Object): void;

                public entering(param0: string, param1: string, param2: native.Array<java.lang.Object>): void;

                public logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: java.lang.Throwable): void;

                public getUseParentHandlers(): boolean;

                public getParent(): java.util.logging.Logger;

                public static getLogger(param0: string, param1: string): java.util.logging.Logger;

                public constructor(param0: string, param1: string);

                public logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string): void;

                public static getAnonymousLogger(): java.util.logging.Logger;

                public removeHandler(param0: java.util.logging.Handler): void;

                public fine(param0: string): void;

                public finest(param0: string): void;

                public setFilter(param0: java.util.logging.Filter): void;

                public getHandlers(): native.Array<java.util.logging.Handler>;

                public entering(param0: string, param1: string, param2: java.lang.Object): void;

                public log(param0: java.util.logging.Level, param1: string, param2: native.Array<java.lang.Object>): void;

                public logp(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: java.lang.Object): void;

                public finer(param0: string): void;

                public getName(): string;

                public getResourceBundleName(): string;

                public setLevel(param0: java.util.logging.Level): void;

                public static getGlobal(): java.util.logging.Logger;

                public getResourceBundle(): java.util.ResourceBundle;

                public entering(param0: string, param1: string): void;

                public info(param0: string): void;

                public static getAnonymousLogger(param0: string): java.util.logging.Logger;

                public isLoggable(param0: java.util.logging.Level): boolean;

                public exiting(param0: string, param1: string): void;

                public logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string, param5: java.lang.Throwable): void;

                public throwing(param0: string, param1: string, param2: java.lang.Throwable): void;

                public severe(param0: string): void;

                public log(param0: java.util.logging.Level, param1: string, param2: java.lang.Throwable): void;
                public log(param0: java.util.logging.LogRecord): void;

                public logrb(param0: java.util.logging.Level, param1: string, param2: string, param3: string, param4: string, param5: native.Array<java.lang.Object>): void;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.List.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class LoggingMXBean extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.logging.LoggingMXBean interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getLoggerLevel(param0: string): string;
                    getLoggerNames(): java.util.List;
                    getParentLoggerName(param0: string): string;
                    setLoggerLevel(param0: string, param1: string): void;
                });

                public getParentLoggerName(param0: string): string;

                public setLoggerLevel(param0: string, param1: string): void;

                public getLoggerLevel(param0: string): string;

                public getLoggerNames(): java.util.List;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.security.Permission.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class LoggingPermission extends java.security.BasicPermission implements java.security.Guard, java.io.Serializable {
                public implies(param0: java.security.Permission): boolean;

                public getActions(): string;

                public checkGuard(param0: java.lang.Object): void;

                public constructor(param0: string);
                public constructor(param0: string, param1: string);
            }
        }
    }
}

/// <reference path="./java.util.logging.Handler.d.ts" />
/// <reference path="./java.util.logging.Level.d.ts" />
/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class MemoryHandler extends java.util.logging.Handler {
                public setPushLevel(param0: java.util.logging.Level): void;

                public close(): void;

                public isLoggable(param0: java.util.logging.LogRecord): boolean;

                public constructor(param0: java.util.logging.Handler, param1: number, param2: java.util.logging.Level);

                public push(): void;

                public publish(param0: java.util.logging.LogRecord): void;

                public getPushLevel(): java.util.logging.Level;

                public constructor();

                public flush(): void;
            }
        }
    }
}

/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class SimpleFormatter extends java.util.logging.Formatter {
                public format(param0: java.util.logging.LogRecord): string;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.logging.Formatter.d.ts" />
/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class SocketHandler extends java.util.logging.StreamHandler {
                public close(): void;

                public constructor(param0: string, param1: number);

                public publish(param0: java.util.logging.LogRecord): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.logging.Formatter);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.logging.Formatter.d.ts" />
/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class StreamHandler extends java.util.logging.Handler {
                public close(): void;

                public isLoggable(param0: java.util.logging.LogRecord): boolean;

                public publish(param0: java.util.logging.LogRecord): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.logging.Formatter);
                public constructor();

                public setOutputStream(param0: java.io.OutputStream): void;

                public setEncoding(param0: string): void;

                public flush(): void;
            }
        }
    }
}

/// <reference path="./java.util.logging.Handler.d.ts" />
/// <reference path="./java.util.logging.LogRecord.d.ts" />
declare module java {
    export module util {
        export module logging {
            export class XMLFormatter extends java.util.logging.Formatter {
                public format(param0: java.util.logging.LogRecord): string;

                public getHead(param0: java.util.logging.Handler): string;

                public getTail(param0: java.util.logging.Handler): string;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.prefs.NodeChangeListener.d.ts" />
/// <reference path="./java.util.prefs.PreferenceChangeListener.d.ts" />
/// <reference path="./java.util.prefs.Preferences.d.ts" />
declare module java {
    export module util {
        export module prefs {
            export abstract class AbstractPreferences extends java.util.prefs.Preferences {
                public lock: java.lang.Object;
                public newNode: boolean;

                public sync(): void;

                public putInt(param0: string, param1: number): void;

                public constructor(param0: java.util.prefs.AbstractPreferences, param1: string);

                public getSpi(param0: string): string;

                public putLong(param0: string, param1: number): void;

                public childSpi(param0: string): java.util.prefs.AbstractPreferences;

                public childrenNames(): native.Array<string>;

                public constructor();

                public removeSpi(param0: string): void;

                public flush(): void;

                public getFloat(param0: string, param1: number): number;

                public keysSpi(): native.Array<string>;

                public getByteArray(param0: string, param1: native.Array<number>): native.Array<number>;

                public flushSpi(): void;

                public putSpi(param0: string, param1: string): void;

                public clear(): void;

                public putDouble(param0: string, param1: number): void;

                public removeNode(): void;

                public syncSpi(): void;

                public getDouble(param0: string, param1: number): number;

                public put(param0: string, param1: string): void;

                public get(param0: string, param1: string): string;

                public addPreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener): void;

                public cachedChildren(): native.Array<java.util.prefs.AbstractPreferences>;

                public absolutePath(): string;

                public parent(): java.util.prefs.Preferences;

                public removeNodeSpi(): void;

                public isRemoved(): boolean;

                public removeNodeChangeListener(param0: java.util.prefs.NodeChangeListener): void;

                public getBoolean(param0: string, param1: boolean): boolean;

                public childrenNamesSpi(): native.Array<string>;

                public exportSubtree(param0: java.io.OutputStream): void;

                public getInt(param0: string, param1: number): number;

                public toString(): string;

                public nodeExists(param0: string): boolean;

                public putByteArray(param0: string, param1: native.Array<number>): void;

                public exportNode(param0: java.io.OutputStream): void;

                public removePreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener): void;

                public name(): string;

                public getLong(param0: string, param1: number): number;

                public node(param0: string): java.util.prefs.Preferences;

                public remove(param0: string): void;

                public addNodeChangeListener(param0: java.util.prefs.NodeChangeListener): void;

                public keys(): native.Array<string>;

                public isUserNode(): boolean;

                public putFloat(param0: string, param1: number): void;

                public putBoolean(param0: string, param1: boolean): void;

                public getChild(param0: string): java.util.prefs.AbstractPreferences;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module prefs {
            export class BackingStoreException extends java.lang.Exception {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module prefs {
            export class InvalidPreferencesFormatException extends java.lang.Exception {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.util.prefs.Preferences.d.ts" />
declare module java {
    export module util {
        export module prefs {
            export class NodeChangeEvent extends java.util.EventObject implements java.io.Serializable {
                public constructor(param0: java.util.prefs.Preferences, param1: java.util.prefs.Preferences);

                public getChild(): java.util.prefs.Preferences;

                public getParent(): java.util.prefs.Preferences;

                public constructor(param0: java.lang.Object);
            }
        }
    }
}

/// <reference path="./java.util.prefs.NodeChangeEvent.d.ts" />
declare module java {
    export module util {
        export module prefs {
            export class NodeChangeListener extends java.lang.Object implements java.util.EventListener {
                /**
                 * Constructs a new instance of the java.util.prefs.NodeChangeListener interface with the provided implementation.
                 */
                public constructor(implementation: {
                    childAdded(param0: java.util.prefs.NodeChangeEvent): void;
                    childRemoved(param0: java.util.prefs.NodeChangeEvent): void;
                });

                public childAdded(param0: java.util.prefs.NodeChangeEvent): void;

                public childRemoved(param0: java.util.prefs.NodeChangeEvent): void;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.prefs.Preferences.d.ts" />
declare module java {
    export module util {
        export module prefs {
            export class PreferenceChangeEvent extends java.util.EventObject implements java.io.Serializable {
                public getNode(): java.util.prefs.Preferences;

                public constructor(param0: java.util.prefs.Preferences, param1: string, param2: string);
                public constructor(param0: java.lang.Object);

                public getKey(): string;

                public getNewValue(): string;
            }
        }
    }
}

/// <reference path="./java.util.prefs.PreferenceChangeEvent.d.ts" />
declare module java {
    export module util {
        export module prefs {
            export class PreferenceChangeListener extends java.lang.Object implements java.util.EventListener {
                /**
                 * Constructs a new instance of the java.util.prefs.PreferenceChangeListener interface with the provided implementation.
                 */
                public constructor(implementation: {
                    preferenceChange(param0: java.util.prefs.PreferenceChangeEvent): void;
                });

                public preferenceChange(param0: java.util.prefs.PreferenceChangeEvent): void;
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.Class.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.prefs.NodeChangeListener.d.ts" />
/// <reference path="./java.util.prefs.PreferenceChangeListener.d.ts" />
declare module java {
    export module util {
        export module prefs {
            export abstract class Preferences extends java.lang.Object {
                public static MAX_KEY_LENGTH: number;
                public static MAX_NAME_LENGTH: number;
                public static MAX_VALUE_LENGTH: number;

                public sync(): void;

                public static systemNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;

                public putInt(param0: string, param1: number): void;

                public putLong(param0: string, param1: number): void;

                public childrenNames(): native.Array<string>;

                public constructor();

                public flush(): void;

                public getFloat(param0: string, param1: number): number;

                public getByteArray(param0: string, param1: native.Array<number>): native.Array<number>;

                public static systemRoot(): java.util.prefs.Preferences;

                public clear(): void;

                public putDouble(param0: string, param1: number): void;

                public removeNode(): void;

                public getDouble(param0: string, param1: number): number;

                public put(param0: string, param1: string): void;

                public get(param0: string, param1: string): string;

                public addPreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener): void;

                public absolutePath(): string;

                public parent(): java.util.prefs.Preferences;

                public removeNodeChangeListener(param0: java.util.prefs.NodeChangeListener): void;

                public getBoolean(param0: string, param1: boolean): boolean;

                public exportSubtree(param0: java.io.OutputStream): void;

                public getInt(param0: string, param1: number): number;

                public toString(): string;

                public nodeExists(param0: string): boolean;

                public putByteArray(param0: string, param1: native.Array<number>): void;

                public exportNode(param0: java.io.OutputStream): void;

                public removePreferenceChangeListener(param0: java.util.prefs.PreferenceChangeListener): void;

                public name(): string;

                public getLong(param0: string, param1: number): number;

                public node(param0: string): java.util.prefs.Preferences;

                public static userNodeForPackage(param0: java.lang.Class): java.util.prefs.Preferences;

                public remove(param0: string): void;

                public addNodeChangeListener(param0: java.util.prefs.NodeChangeListener): void;

                public keys(): native.Array<string>;

                public isUserNode(): boolean;

                public static userRoot(): java.util.prefs.Preferences;

                public static importPreferences(param0: java.io.InputStream): void;

                public putFloat(param0: string, param1: number): void;

                public putBoolean(param0: string, param1: boolean): void;
            }
        }
    }
}

/// <reference path="./java.util.prefs.Preferences.d.ts" />
declare module java {
    export module util {
        export module prefs {
            export class PreferencesFactory extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.prefs.PreferencesFactory interface with the provided implementation.
                 */
                public constructor(implementation: {
                    userRoot(): java.util.prefs.Preferences;
                    systemRoot(): java.util.prefs.Preferences;
                });

                public systemRoot(): java.util.prefs.Preferences;

                public userRoot(): java.util.prefs.Preferences;
            }
        }
    }
}

declare module java {
    export module util {
        export module regex {
            export class MatchResult extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.regex.MatchResult interface with the provided implementation.
                 */
                public constructor(implementation: {
                    end(): number;
                    end(param0: number): number;
                    group(): string;
                    group(param0: number): string;
                    groupCount(): number;
                    start(): number;
                    start(param0: number): number;
                });

                public end(param0: number): number;
                public end(): number;

                public group(): string;

                public start(): number;

                public group(param0: number): string;

                public start(param0: number): number;

                public groupCount(): number;
            }
        }
    }
}

/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.StringBuffer.d.ts" />
/// <reference path="./java.util.regex.MatchResult.d.ts" />
/// <reference path="./java.util.regex.Pattern.d.ts" />
declare module java {
    export module util {
        export module regex {
            export class Matcher extends java.lang.Object implements java.util.regex.MatchResult {
                public pattern(): java.util.regex.Pattern;

                public end(param0: number): number;

                public hasTransparentBounds(): boolean;

                public hitEnd(): boolean;

                public finalize(): void;

                public useTransparentBounds(param0: boolean): java.util.regex.Matcher;

                public appendTail(param0: java.lang.StringBuffer): java.lang.StringBuffer;

                public replaceFirst(param0: string): string;

                public end(): number;

                public lookingAt(): boolean;

                public start(param0: number): number;

                public appendReplacement(param0: java.lang.StringBuffer, param1: string): java.util.regex.Matcher;

                public hasAnchoringBounds(): boolean;

                public requireEnd(): boolean;

                public reset(): java.util.regex.Matcher;

                public find(param0: number): boolean;

                public usePattern(param0: java.util.regex.Pattern): java.util.regex.Matcher;

                public replaceAll(param0: string): string;

                public find(): boolean;

                public matches(): boolean;

                public region(param0: number, param1: number): java.util.regex.Matcher;

                public group(): string;

                public start(): number;

                public static quoteReplacement(param0: string): string;

                public group(param0: number): string;

                public regionStart(): number;

                public regionEnd(): number;

                public toString(): string;

                public reset(param0: string): java.util.regex.Matcher;

                public useAnchoringBounds(param0: boolean): java.util.regex.Matcher;

                public groupCount(): number;

                public toMatchResult(): java.util.regex.MatchResult;
            }
        }
    }
}

/// <reference path="./java.lang.CharSequence.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.regex.Matcher.d.ts" />
declare module java {
    export module util {
        export module regex {
            export class Pattern extends java.lang.Object implements java.io.Serializable {
                public static CANON_EQ: number;
                public static CASE_INSENSITIVE: number;
                public static COMMENTS: number;
                public static DOTALL: number;
                public static LITERAL: number;
                public static MULTILINE: number;
                public static UNICODE_CASE: number;
                public static UNIX_LINES: number;

                public static matches(param0: string, param1: string): boolean;

                public static compile(param0: string): java.util.regex.Pattern;

                public finalize(): void;

                public pattern(): string;

                public flags(): number;

                public static compile(param0: string, param1: number): java.util.regex.Pattern;

                public matcher(param0: string): java.util.regex.Matcher;

                public split(param0: string, param1: number): native.Array<string>;
                public split(param0: string): native.Array<string>;

                public toString(): string;

                public static quote(param0: string): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module regex {
            export class PatternSyntaxException extends java.lang.IllegalArgumentException {
                public constructor(param0: string, param1: string, param2: number);
                public constructor(param0: string, param1: java.lang.Throwable);

                public getDescription(): string;

                public getIndex(): number;

                public getPattern(): string;

                public getMessage(): string;

                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

declare module java {
    export module util {
        export module zip {
            export class Adler32 extends java.lang.Object implements java.util.zip.Checksum {
                public reset(): void;

                public update(param0: native.Array<number>): void;
                public update(param0: native.Array<number>, param1: number, param2: number): void;
                public update(param0: number): void;

                public getValue(): number;

                public constructor();
            }
        }
    }
}

declare module java {
    export module util {
        export module zip {
            export class CRC32 extends java.lang.Object implements java.util.zip.Checksum {
                public reset(): void;

                public update(param0: native.Array<number>): void;
                public update(param0: native.Array<number>, param1: number, param2: number): void;
                public update(param0: number): void;

                public getValue(): number;

                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.util.zip.Checksum.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class CheckedInputStream extends java.io.FilterInputStream {
                public getChecksum(): java.util.zip.Checksum;

                public read(): number;

                public skip(param0: number): number;

                public close(): void;

                public constructor(param0: java.io.InputStream, param1: java.util.zip.Checksum);

                public read(param0: native.Array<number>): number;
                public read(param0: native.Array<number>, param1: number, param2: number): number;

                public constructor(param0: java.io.InputStream);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.util.zip.Checksum.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class CheckedOutputStream extends java.io.FilterOutputStream {
                public getChecksum(): java.util.zip.Checksum;

                public close(): void;

                public constructor(param0: java.io.OutputStream);

                public write(param0: native.Array<number>, param1: number, param2: number): void;
                public write(param0: number): void;
                public write(param0: native.Array<number>): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Checksum);
                public constructor();

                public flush(): void;
            }
        }
    }
}

declare module java {
    export module util {
        export module zip {
            export class Checksum extends java.lang.Object {
                /**
                 * Constructs a new instance of the java.util.zip.Checksum interface with the provided implementation.
                 */
                public constructor(implementation: {
                    getValue(): number;
                    reset(): void;
                    update(param0: native.Array<number>, param1: number, param2: number): void;
                    update(param0: number): void;
                });

                public reset(): void;

                public update(param0: native.Array<number>, param1: number, param2: number): void;
                public update(param0: number): void;

                public getValue(): number;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class DataFormatException extends java.lang.Exception {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

declare module java {
    export module util {
        export module zip {
            export class Deflater extends java.lang.Object {
                public static BEST_COMPRESSION: number;
                public static BEST_SPEED: number;
                public static DEFAULT_COMPRESSION: number;
                public static DEFAULT_STRATEGY: number;
                public static DEFLATED: number;
                public static FILTERED: number;
                public static FULL_FLUSH: number;
                public static HUFFMAN_ONLY: number;
                public static NO_COMPRESSION: number;
                public static NO_FLUSH: number;
                public static SYNC_FLUSH: number;

                public getAdler(): number;

                public setDictionary(param0: native.Array<number>, param1: number, param2: number): void;

                public deflate(param0: native.Array<number>, param1: number, param2: number, param3: number): number;

                public getTotalIn(): number;

                public setStrategy(param0: number): void;

                public getTotalOut(): number;

                public finalize(): void;

                public constructor(param0: number, param1: boolean);

                public needsInput(): boolean;

                public getBytesWritten(): number;

                public finish(): void;

                public setLevel(param0: number): void;

                public constructor();

                public end(): void;

                public setInput(param0: native.Array<number>): void;

                public getBytesRead(): number;

                public deflate(param0: native.Array<number>, param1: number, param2: number): number;

                public reset(): void;

                public deflate(param0: native.Array<number>): number;

                public constructor(param0: number);

                public setInput(param0: native.Array<number>, param1: number, param2: number): void;

                public finished(): boolean;

                public setDictionary(param0: native.Array<number>): void;
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.util.zip.Deflater.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class DeflaterInputStream extends java.io.FilterInputStream {
                public buf: native.Array<number>;
                public def: java.util.zip.Deflater;

                public markSupported(): boolean;

                public close(): void;

                public read(param0: native.Array<number>, param1: number, param2: number): number;

                public constructor(param0: java.io.InputStream);
                public constructor();

                public reset(): void;

                public read(): number;

                public skip(param0: number): number;

                public constructor(param0: java.io.InputStream, param1: java.util.zip.Deflater, param2: number);
                public constructor(param0: java.io.InputStream, param1: java.util.zip.Deflater);

                public read(param0: native.Array<number>): number;

                public available(): number;

                public mark(param0: number): void;
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.util.zip.Deflater.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class DeflaterOutputStream extends java.io.FilterOutputStream {
                public buf: native.Array<number>;
                public def: java.util.zip.Deflater;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: number, param3: boolean);

                public close(): void;

                public constructor(param0: java.io.OutputStream);

                public write(param0: native.Array<number>, param1: number, param2: number): void;
                public write(param0: native.Array<number>): void;

                public finish(): void;

                public deflate(): void;

                public constructor(param0: java.io.OutputStream, param1: boolean);
                public constructor();

                public flush(): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: boolean);

                public write(param0: number): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: number);
                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater);
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.util.zip.CRC32.d.ts" />
/// <reference path="./java.util.zip.Inflater.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class GZIPInputStream extends java.util.zip.InflaterInputStream {
                public static GZIP_MAGIC: number;
                public crc: java.util.zip.CRC32;
                public eos: boolean;

                public constructor(param0: java.io.InputStream, param1: java.util.zip.Inflater, param2: number);

                public close(): void;

                public read(): number;
                public read(param0: native.Array<number>): number;

                public constructor(param0: java.io.InputStream, param1: number);

                public read(param0: native.Array<number>, param1: number, param2: number): number;

                public constructor(param0: java.io.InputStream);
                public constructor(param0: java.io.InputStream, param1: java.util.zip.Inflater);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.util.zip.CRC32.d.ts" />
/// <reference path="./java.util.zip.Deflater.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class GZIPOutputStream extends java.util.zip.DeflaterOutputStream {
                public crc: java.util.zip.CRC32;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: number, param3: boolean);

                public close(): void;

                public constructor(param0: java.io.OutputStream);

                public write(param0: native.Array<number>, param1: number, param2: number): void;
                public write(param0: native.Array<number>): void;

                public finish(): void;

                public constructor(param0: java.io.OutputStream, param1: boolean);
                public constructor();

                public flush(): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: boolean);

                public write(param0: number): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: number);
                public constructor(param0: java.io.OutputStream, param1: number, param2: boolean);
                public constructor(param0: java.io.OutputStream, param1: number);
                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater);
            }
        }
    }
}

declare module java {
    export module util {
        export module zip {
            export class Inflater extends java.lang.Object {
                public getAdler(): number;

                public setDictionary(param0: native.Array<number>, param1: number, param2: number): void;

                public getTotalIn(): number;

                public getRemaining(): number;

                public getTotalOut(): number;

                public finalize(): void;

                public constructor(param0: boolean);

                public getBytesWritten(): number;

                public needsInput(): boolean;

                public inflate(param0: native.Array<number>, param1: number, param2: number): number;

                public constructor();

                public end(): void;

                public getBytesRead(): number;

                public setInput(param0: native.Array<number>): void;

                public reset(): void;

                public needsDictionary(): boolean;

                public inflate(param0: native.Array<number>): number;

                public setInput(param0: native.Array<number>, param1: number, param2: number): void;

                public finished(): boolean;

                public setDictionary(param0: native.Array<number>): void;
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.util.zip.Inflater.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class InflaterInputStream extends java.io.FilterInputStream {
                public buf: native.Array<number>;
                public inf: java.util.zip.Inflater;
                public len: number;

                public constructor(param0: java.io.InputStream, param1: java.util.zip.Inflater, param2: number);

                public markSupported(): boolean;

                public close(): void;

                public read(param0: native.Array<number>, param1: number, param2: number): number;

                public constructor(param0: java.io.InputStream);
                public constructor();
                public constructor(param0: java.io.InputStream, param1: java.util.zip.Inflater);

                public reset(): void;

                public read(): number;

                public skip(param0: number): number;

                public read(param0: native.Array<number>): number;

                public available(): number;

                public fill(): void;

                public mark(param0: number): void;
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.util.zip.Inflater.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class InflaterOutputStream extends java.io.FilterOutputStream {
                public buf: native.Array<number>;
                public inf: java.util.zip.Inflater;

                public close(): void;

                public constructor(param0: java.io.OutputStream);

                public write(param0: native.Array<number>, param1: number, param2: number): void;
                public write(param0: number): void;
                public write(param0: native.Array<number>): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Inflater);

                public finish(): void;

                public constructor();
                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Inflater, param2: number);

                public flush(): void;
            }
        }
    }
}

/// <reference path="./java.lang.Object.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class ZipEntry extends java.lang.Object implements java.lang.Cloneable {
                public static CENATT: number;
                public static CENATX: number;
                public static CENCOM: number;
                public static CENCRC: number;
                public static CENDSK: number;
                public static CENEXT: number;
                public static CENFLG: number;
                public static CENHDR: number;
                public static CENHOW: number;
                public static CENLEN: number;
                public static CENNAM: number;
                public static CENOFF: number;
                public static CENSIG: number;
                public static CENSIZ: number;
                public static CENTIM: number;
                public static CENVEM: number;
                public static CENVER: number;
                public static DEFLATED: number;
                public static ENDCOM: number;
                public static ENDHDR: number;
                public static ENDOFF: number;
                public static ENDSIG: number;
                public static ENDSIZ: number;
                public static ENDSUB: number;
                public static ENDTOT: number;
                public static EXTCRC: number;
                public static EXTHDR: number;
                public static EXTLEN: number;
                public static EXTSIG: number;
                public static EXTSIZ: number;
                public static LOCCRC: number;
                public static LOCEXT: number;
                public static LOCFLG: number;
                public static LOCHDR: number;
                public static LOCHOW: number;
                public static LOCLEN: number;
                public static LOCNAM: number;
                public static LOCSIG: number;
                public static LOCSIZ: number;
                public static LOCTIM: number;
                public static LOCVER: number;
                public static STORED: number;

                public setComment(param0: string): void;

                public getCompressedSize(): number;

                public getExtra(): native.Array<number>;

                public setCompressedSize(param0: number): void;

                public getName(): string;

                public setCrc(param0: number): void;

                public setSize(param0: number): void;

                public toString(): string;

                public getTime(): number;

                public clone(): java.lang.Object;

                public constructor(param0: string);

                public getMethod(): number;

                public setExtra(param0: native.Array<number>): void;

                public getSize(): number;

                public hashCode(): number;

                public getCrc(): number;

                public setMethod(param0: number): void;

                public constructor(param0: java.util.zip.ZipEntry);

                public isDirectory(): boolean;

                public setTime(param0: number): void;

                public getComment(): string;
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class ZipError extends java.lang.InternalError {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor();
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
            }
        }
    }
}

/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.lang.Throwable.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class ZipException extends java.io.IOException {
                public constructor(param0: string, param1: java.lang.Throwable);
                public constructor(param0: java.lang.Throwable);
                public constructor(param0: string);
                public constructor(param0: string, param1: java.lang.Throwable, param2: boolean, param3: boolean);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.File.d.ts" />
/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.Enumeration.d.ts" />
/// <reference path="./java.util.zip.ZipEntry.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class ZipFile extends java.lang.Object implements java.io.Closeable {
                public static CENATT: number;
                public static CENATX: number;
                public static CENCOM: number;
                public static CENCRC: number;
                public static CENDSK: number;
                public static CENEXT: number;
                public static CENFLG: number;
                public static CENHDR: number;
                public static CENHOW: number;
                public static CENLEN: number;
                public static CENNAM: number;
                public static CENOFF: number;
                public static CENSIG: number;
                public static CENSIZ: number;
                public static CENTIM: number;
                public static CENVEM: number;
                public static CENVER: number;
                public static ENDCOM: number;
                public static ENDHDR: number;
                public static ENDOFF: number;
                public static ENDSIG: number;
                public static ENDSIZ: number;
                public static ENDSUB: number;
                public static ENDTOT: number;
                public static EXTCRC: number;
                public static EXTHDR: number;
                public static EXTLEN: number;
                public static EXTSIG: number;
                public static EXTSIZ: number;
                public static LOCCRC: number;
                public static LOCEXT: number;
                public static LOCFLG: number;
                public static LOCHDR: number;
                public static LOCHOW: number;
                public static LOCLEN: number;
                public static LOCNAM: number;
                public static LOCSIG: number;
                public static LOCSIZ: number;
                public static LOCTIM: number;
                public static LOCVER: number;
                public static OPEN_DELETE: number;
                public static OPEN_READ: number;

                public entries(): java.util.Enumeration;

                public close(): void;

                public getInputStream(param0: java.util.zip.ZipEntry): java.io.InputStream;

                public constructor(param0: java.io.File);

                public getEntry(param0: string): java.util.zip.ZipEntry;

                public finalize(): void;

                public getName(): string;

                public constructor(param0: string);
                public constructor(param0: java.io.File, param1: number);

                public getComment(): string;

                public size(): number;
            }
        }
    }
}

/// <reference path="./java.io.InputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.zip.Inflater.d.ts" />
/// <reference path="./java.util.zip.ZipEntry.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class ZipInputStream extends java.util.zip.InflaterInputStream {
                public static CENATT: number;
                public static CENATX: number;
                public static CENCOM: number;
                public static CENCRC: number;
                public static CENDSK: number;
                public static CENEXT: number;
                public static CENFLG: number;
                public static CENHDR: number;
                public static CENHOW: number;
                public static CENLEN: number;
                public static CENNAM: number;
                public static CENOFF: number;
                public static CENSIG: number;
                public static CENSIZ: number;
                public static CENTIM: number;
                public static CENVEM: number;
                public static CENVER: number;
                public static ENDCOM: number;
                public static ENDHDR: number;
                public static ENDOFF: number;
                public static ENDSIG: number;
                public static ENDSIZ: number;
                public static ENDSUB: number;
                public static ENDTOT: number;
                public static EXTCRC: number;
                public static EXTHDR: number;
                public static EXTLEN: number;
                public static EXTSIG: number;
                public static EXTSIZ: number;
                public static LOCCRC: number;
                public static LOCEXT: number;
                public static LOCFLG: number;
                public static LOCHDR: number;
                public static LOCHOW: number;
                public static LOCLEN: number;
                public static LOCNAM: number;
                public static LOCSIG: number;
                public static LOCSIZ: number;
                public static LOCTIM: number;
                public static LOCVER: number;

                public constructor(param0: java.io.InputStream, param1: java.util.zip.Inflater, param2: number);

                public close(): void;

                public read(): number;
                public read(param0: native.Array<number>): number;

                public getNextEntry(): java.util.zip.ZipEntry;

                public available(): number;

                public read(param0: native.Array<number>, param1: number, param2: number): number;

                public closeEntry(): void;

                public createZipEntry(param0: string): java.util.zip.ZipEntry;

                public constructor(param0: java.io.InputStream);
                public constructor(param0: java.io.InputStream, param1: java.util.zip.Inflater);
                public constructor();
            }
        }
    }
}

/// <reference path="./java.io.OutputStream.d.ts" />
/// <reference path="./java.lang.String.d.ts" />
/// <reference path="./java.util.zip.Deflater.d.ts" />
/// <reference path="./java.util.zip.ZipEntry.d.ts" />
declare module java {
    export module util {
        export module zip {
            export class ZipOutputStream extends java.util.zip.DeflaterOutputStream {
                public static CENATT: number;
                public static CENATX: number;
                public static CENCOM: number;
                public static CENCRC: number;
                public static CENDSK: number;
                public static CENEXT: number;
                public static CENFLG: number;
                public static CENHDR: number;
                public static CENHOW: number;
                public static CENLEN: number;
                public static CENNAM: number;
                public static CENOFF: number;
                public static CENSIG: number;
                public static CENSIZ: number;
                public static CENTIM: number;
                public static CENVEM: number;
                public static CENVER: number;
                public static DEFLATED: number;
                public static ENDCOM: number;
                public static ENDHDR: number;
                public static ENDOFF: number;
                public static ENDSIG: number;
                public static ENDSIZ: number;
                public static ENDSUB: number;
                public static ENDTOT: number;
                public static EXTCRC: number;
                public static EXTHDR: number;
                public static EXTLEN: number;
                public static EXTSIG: number;
                public static EXTSIZ: number;
                public static LOCCRC: number;
                public static LOCEXT: number;
                public static LOCFLG: number;
                public static LOCHDR: number;
                public static LOCHOW: number;
                public static LOCLEN: number;
                public static LOCNAM: number;
                public static LOCSIG: number;
                public static LOCSIZ: number;
                public static LOCTIM: number;
                public static LOCVER: number;
                public static STORED: number;

                public setComment(param0: string): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: number, param3: boolean);

                public close(): void;

                public constructor(param0: java.io.OutputStream);

                public write(param0: native.Array<number>, param1: number, param2: number): void;
                public write(param0: native.Array<number>): void;

                public closeEntry(): void;

                public finish(): void;

                public setLevel(param0: number): void;

                public constructor(param0: java.io.OutputStream, param1: boolean);
                public constructor();

                public flush(): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: boolean);

                public write(param0: number): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater, param2: number);

                public setMethod(param0: number): void;

                public constructor(param0: java.io.OutputStream, param1: java.util.zip.Deflater);

                public putNextEntry(param0: java.util.zip.ZipEntry): void;
            }
        }
    }
}
